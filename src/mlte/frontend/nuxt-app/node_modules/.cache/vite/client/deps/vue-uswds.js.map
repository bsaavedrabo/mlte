{
  "version": 3,
  "sources": ["../../../../../../../../../../../node_modules/vue-uswds/node_modules/just-kebab-case/index.mjs", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/just-split/index.mjs", "../../../../../../../../../../../node_modules/vue-uswds/src/utils/common.js", "../../../../../../../../../../../node_modules/vue-uswds/src/utils/unique-id.js", "../../../../../../../../../../../node_modules/vue-uswds/src/utils/constants.js", "../../../../../../../../../../../node_modules/vue-uswds/src/core.js", "../../../../../../../../../../../node_modules/vue-uswds/plugin-vue:export-helper", "../../../../../../../../../../../node_modules/vue-uswds/src/components/BaseLink/BaseLink.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/composables/useAccordion.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaAccordion/UsaAccordion.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaAccordionItem/UsaAccordionItem.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaAlert/UsaAlert.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/composables/useToggle.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaBannerContent/UsaBannerContent.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaBanner/UsaBanner.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaBreadcrumbItem/UsaBreadcrumbItem.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaBreadcrumb/UsaBreadcrumb.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaButton/UsaButton.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaButtonGroup/UsaButtonGroup.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaCard/UsaCard.vue", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/@vueuse/shared/index.mjs", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/@vueuse/core/index.mjs", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaCharacterCount/UsaCharacterCount.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaCheckbox/UsaCheckbox.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaChecklistItem/UsaChecklistItem.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaCollection/UsaCollection.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaCollectionCalendar/UsaCollectionCalendar.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/composables/useComboBox.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFormGroup/UsaFormGroup.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaLabel/UsaLabel.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaComboBox/UsaComboBox.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTextInput/UsaTextInput.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaSelect/UsaSelect.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDateInput/UsaDateInput.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/utils/dates.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/tabbable/dist/index.esm.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/focus-trap/dist/focus-trap.esm.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/@vueuse/integrations/useFocusTrap.mjs", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/_lib/toInteger/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/_lib/requiredArgs/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/toDate/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/addDays/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/addMonths/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/_lib/defaultOptions/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/startOfWeek/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/startOfDay/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/differenceInCalendarDays/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/addYears/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/isSameDay/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/endOfMonth/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/startOfMonth/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/endOfWeek/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/isAfter/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/isBefore/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/isSameMonth/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/subDays/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/setDate/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/subMonths/index.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/date-fns/esm/subYears/index.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePickerCalendarDay/useDayPicker.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePickerCalendarDay/UsaDatePickerCalendarDay.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePickerCalendarMonth/useMonthPicker.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePickerCalendarMonth/UsaDatePickerCalendarMonth.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePickerCalendarYear/useYearPicker.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePickerCalendarYear/UsaDatePickerCalendarYear.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePickerCalendar/UsaDatePickerCalendar.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDatePicker/UsaDatePicker.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaDateRangePicker/UsaDateRangePicker.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/composables/useFileInput.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFileInput/UsaFileInput.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooter/UsaFooter.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterAddress/UsaFooterAddress.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterCollapsibleMenuSection/UsaFooterCollapsibleMenuSection.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterCollapsibleMenu/UsaFooterCollapsibleMenu.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterLogo/UsaFooterLogo.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterMenu/UsaFooterMenu.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterNav/UsaFooterNav.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterSecondarySection/UsaFooterSecondarySection.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaFooterSocialLinks/UsaFooterSocialLinks.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaGraphicList/UsaGraphicList.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaHeader/UsaHeader.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaHero/UsaHero.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaHeroCallout/UsaHeroCallout.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaIcon/UsaIcon.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaIconList/UsaIconList.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaLink/UsaLink.vue", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/@vueuse/integrations/useFocusTrap/component.mjs", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaModalCloseButton/UsaModalCloseButton.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaModal/UsaModal.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaOverlay/UsaOverlay.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNav/UsaNav.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavDropdown/UsaNavDropdown.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavDropdownButton/UsaNavDropdownButton.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavPrimaryItem/UsaNavPrimaryItem.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavSubmenu/UsaNavSubmenu.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavSubmenuItem/UsaNavSubmenuItem.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavPrimary/UsaNavPrimary.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavSecondary/UsaNavSecondary.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/composables/useMobileMenu.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaNavbar/UsaNavbar.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/composables/usePagination.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaPaginationArrow/UsaPaginationArrow.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaPaginationItem/UsaPaginationItem.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaPagination/UsaPagination.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaPasswordMask/UsaPasswordMask.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaProcessList/UsaProcessList.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaProcessListItem/UsaProcessListItem.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaRadio/UsaRadio.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaRange/UsaRange.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaSearch/UsaSearch.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaSiteAlert/UsaSiteAlert.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaStepIndicatorSegment/UsaStepIndicatorSegment.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaStepIndicatorHeader/UsaStepIndicatorHeader.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaStepIndicator/UsaStepIndicator.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaSummaryBox/UsaSummaryBox.vue", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/fast-sort/dist/sort.es.js", "../../../../../../../../../../../node_modules/vue-uswds/src/utils/sorting.js", "../../../../../../../../../../../node_modules/vue-uswds/src/composables/useTableSort.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTableSortButton/UsaTableSortButton.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTableHeaderCell/UsaTableHeaderCell.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTable/UsaTable.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTag/UsaTag.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTextarea/UsaTextarea.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTimePicker/UsaTimePicker.vue", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/@floating-ui/core/dist/floating-ui.core.esm.js", "../../../../../../../../../../../node_modules/vue-uswds/node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaTooltip/UsaTooltip.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/components/UsaValidation/UsaValidation.vue", "../../../../../../../../../../../node_modules/vue-uswds/src/index.js"],
  "sourcesContent": ["var stringKebabCase = kebabCase;\n\n/*\n  kebabCase('the quick brown fox'); // 'the-quick-brown-fox'\n  kebabCase('the-quick-brown-fox'); // 'the-quick-brown-fox'\n  kebabCase('the_quick_brown_fox'); // 'the-quick-brown-fox'\n  kebabCase('theQuickBrownFox'); // 'the-quick-brown-fox'\n  kebabCase('theQuickBrown Fox'); // 'the-quick-brown-fox'\n  kebabCase('thequickbrownfox'); // 'thequickbrownfox'\n  kebabCase('the - quick * brown# fox'); // 'the-quick-brown-fox'\n  kebabCase('theQUICKBrownFox'); // 'the-quick-brown-fox'\n*/\n\n// any combination of spaces and punctuation characters\n// thanks to http://stackoverflow.com/a/25575009\nvar wordSeparators = /[\\s\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,\\-.\\/:;<=>?@\\[\\]^_`{|}~]+/;\nvar capital_plus_lower = /[A-ZÀ-Ý\\u00C0-\\u00D6\\u00D9-\\u00DD][a-zà-ÿ]/g;\nvar capitals = /[A-ZÀ-Ý\\u00C0-\\u00D6\\u00D9-\\u00DD]+/g;\n\nfunction kebabCase(str) {\n  // replace word starts with space + lower case equivalent for later parsing\n  // 1) treat cap + lower as start of new word\n  str = str.replace(capital_plus_lower, function(match) {\n    // match is one caps followed by one non-cap\n    return ' ' + (match[0].toLowerCase() || match[0]) + match[1];\n  });\n  // 2) treat all remaining capitals as words\n  str = str.replace(capitals, function(match) {\n    // match is a series of caps\n    return ' ' + match.toLowerCase();\n  });\n  return str\n    .trim()\n    .split(wordSeparators)\n    .join('-')\n    .replace(/^-/, '')\n    .replace(/-\\s*$/, '');\n}\n\nexport {stringKebabCase as default};\n", "var arraySplit = split;\n\n/*\n    split([]); // []\n    split([1, 2, 3, 4, 5]); // [[1, 2, 3, 4, 5]]\n    split([1, 2, 3, 4, 5], null); // [[1, 2, 3, 4, 5]]\n    split([1, 2, 3, 4, 5, 6, 7, 8, 9], 3); // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    split(['a', 'b', 'c', 'd', 'e'], 2); // [['a', 'b'], ['c', 'd'], ['e']]\n    split([1, 2, 3, 4, 5, 6, 7, 8], 3); // [[1, 2, 3], [4, 5, 6], [7, 8]]\n    split(null, 3); // throws\n    split([1, 2, 3, 4, 5, 6], '3'); // throws\n    split([1, 2, 3, 4, 5, 6], {}); // throws\n*/\n\nfunction split(arr, n) {\n  if (!Array.isArray(arr)) {\n    throw new Error('expected an array for the first argument');\n  }\n  if (n != null && typeof n != 'number') {\n    throw new Error('expected a number or null/undefined for the second argument');\n  }\n  n = n != null ? n : arr.length;\n  var len = arr.length;\n  var groups = [];\n  for (var i = 0; i < len; i += n) {\n    groups.push(arr.slice(i, i + n));\n  }\n  return groups;\n}\n\nexport {arraySplit as default};\n", "import justKebabCase from 'just-kebab-case'\nimport split from 'just-split'\n\nexport const objectHasKey = (object, key) =>\n  Object.prototype.hasOwnProperty.call(object, key)\n\nexport const kebabCase = value => justKebabCase(value)\n\nexport const escapeRegExp = string =>\n  string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n\nexport const splitArray = (array, splitAt) => split(array, splitAt)\n", "import { getCurrentInstance } from 'vue'\nimport { kebabCase } from '@/utils/common.js'\n\nconst idPrefix = 'vuswds-id-'\nconst idRegistry = {}\n\n// Adapted from:\n// https://github.com/wearebraid/vue-formulate/blob/master/src/Formulate.js\nexport function nextId(componentName = '') {\n  const vm = getCurrentInstance()\n  const route = vm.appContext.config.globalProperties?.$route\n\n  const pathPrefix = route?.path ? kebabCase(route.path) : 'global'\n\n  if (!idRegistry[pathPrefix]) {\n    idRegistry[pathPrefix] = 0\n  }\n\n  return `${idPrefix}${pathPrefix}-${kebabCase(componentName)}-${++idRegistry[\n    pathPrefix\n  ]}`\n}\n", "export const PREFIX_SEPARATOR = ':'\nexport const GRID_NAMESPACE = 'grid-'\nexport const UTILITY_NAMESPACE = 'u-'\nexport const IMAGE_PATH = '/assets/img'\nexport const SVG_SPRITE_PATH = '/assets/img/sprite.svg'\nexport const ROUTER_COMPONENT_NAME = null\nexport const MOBILE_MENU_BREAKPOINT = '64em'\nexport const FOOTER_NAV_COLLAPSIBLE_BREAKPOINT = '30em'\nexport const MIN_DATE = '0000-01-01'\nexport const MAX_DATE = '9999-12-31'\nexport const USA_DATE_REGEX_PATTERN =\n  /^(0[1-9]|1[0-2])\\/(0[1-9]|[12][0-9]|3[01])\\/\\d{4}$/\nexport const ISO_DATE_REGEX_PATTERN =\n  /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/\nexport const MONTH_LABELS = [\n  'January',\n  'February',\n  'March',\n  'April',\n  'May',\n  'June',\n  'July',\n  'August',\n  'September',\n  'October',\n  'November',\n  'December',\n]\nexport const DAY_OF_WEEK_LABELS = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n]\nexport const DAY_OF_WEEK_ABBREVIATION_LABELS = [\n  'S',\n  'M',\n  'T',\n  'W',\n  'Th',\n  'Fr',\n  'S',\n]\nexport const YEAR_GROUP = 12\n", "import { version } from '../package.json'\nimport { nextId } from '@/utils/unique-id.js'\nimport {\n  PREFIX_SEPARATOR,\n  GRID_NAMESPACE,\n  UTILITY_NAMESPACE,\n  IMAGE_PATH,\n  SVG_SPRITE_PATH,\n  ROUTER_COMPONENT_NAME,\n  MOBILE_MENU_BREAKPOINT,\n  FOOTER_NAV_COLLAPSIBLE_BREAKPOINT,\n} from '@/utils/constants.js'\n\nexport default {\n  install: (app, options) => {\n    const customOptions = options || {}\n\n    const vueUswdsOptions = {\n      prefixSeparator: PREFIX_SEPARATOR,\n      gridNamespace: GRID_NAMESPACE,\n      utilityNamespace: UTILITY_NAMESPACE,\n      imagePath: IMAGE_PATH,\n      svgSpritePath: SVG_SPRITE_PATH,\n      routerComponentName: ROUTER_COMPONENT_NAME,\n      mobileMenuBreakpoint: MOBILE_MENU_BREAKPOINT,\n      footerNavBigBreakpoint: FOOTER_NAV_COLLAPSIBLE_BREAKPOINT,\n      ...customOptions,\n      version: version,\n    }\n\n    if (!app.config.globalProperties.$vueUswds) {\n      app.config.globalProperties.$vueUswds = vueUswdsOptions\n    }\n\n    app.provide('vueUswds', vueUswdsOptions)\n    app.provide('nextId', nextId)\n  },\n}\n", "\nexport default (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n}\n", "<script>\nimport { ROUTER_COMPONENT_NAME } from '@/utils/constants.js'\n\nexport default {\n  name: 'BaseLink',\n  inject: {\n    globalRouterComponentName: {\n      from: 'vueUswds.routerComponentName',\n      default: ROUTER_COMPONENT_NAME,\n    },\n  },\n  inheritAttrs: false,\n  props: {\n    href: {\n      type: String,\n      default: '',\n    },\n    to: {\n      type: [String, Object],\n      default: '',\n    },\n    routerComponentName: {\n      type: String,\n      default: '',\n    },\n  },\n  data() {\n    return {\n      // Router link checks here instead of computed to avoid Vue warning\n      // about $nuxt and $router not being defined on the instance when they\n      // are not installed.\n      isNuxt: this?.$nuxt,\n      isVueRouter: this?.$router,\n    }\n  },\n  computed: {\n    isHrefLink() {\n      return (\n        !!this.href ||\n        (typeof this.to === 'string' && this.to.startsWith('http'))\n      )\n    },\n    linkComponent() {\n      if (this.routerComponentName) {\n        return this.routerComponentName\n      }\n\n      if (this.globalRouterComponentName) {\n        return this.globalRouterComponentName\n      }\n\n      if (this.isNuxt) {\n        return 'nuxt-link'\n      }\n\n      if (this.isVueRouter) {\n        return 'router-link'\n      }\n\n      return 'a'\n    },\n  },\n}\n</script>\n\n<template>\n  <a v-if=\"isHrefLink\" v-bind=\"$attrs\" :href=\"href || to\"><slot></slot></a>\n  <component :is=\"linkComponent\" v-else v-bind=\"$attrs\" :to=\"to\"\n    ><slot></slot\n  ></component>\n</template>\n", "import { reactive } from 'vue'\n\nexport default (_accordionItems, multiselectable = false) => {\n  const accordionItems = reactive(_accordionItems)\n\n  const registerAccordionItem = (id, isOpen) => {\n    if (accordionItems[id] === undefined) {\n      accordionItems[id] = isOpen\n    }\n\n    if (multiselectable.value) {\n      return\n    }\n\n    for (const accordionId in accordionItems) {\n      if (accordionId !== id && isOpen) {\n        accordionItems[accordionId] = false\n      }\n    }\n  }\n\n  const unregisterAccordionItem = id => {\n    delete accordionItems[id]\n  }\n\n  const closeItem = id => {\n    accordionItems[id] = false\n  }\n\n  const openItem = id => {\n    accordionItems[id] = true\n\n    if (multiselectable.value) {\n      return\n    }\n\n    for (const accordionId in accordionItems) {\n      if (accordionId !== id) {\n        closeItem(accordionId)\n      }\n    }\n  }\n\n  const toggleItem = id => {\n    if (accordionItems[id]) {\n      closeItem(id)\n    } else {\n      openItem(id)\n    }\n  }\n\n  const closeAllItems = () => {\n    for (const accordionId in accordionItems) {\n      closeItem(accordionId)\n    }\n  }\n\n  return {\n    registerAccordionItem,\n    unregisterAccordionItem,\n    openItem,\n    closeItem,\n    toggleItem,\n    closeAllItems,\n  }\n}\n", "<script setup>\nimport { computed, provide, reactive, watch, toRef } from 'vue'\nimport useAccordion from '@/composables/useAccordion.js'\n\nconst emit = defineEmits(['update:accordionItems'])\n\nconst props = defineProps({\n  bordered: {\n    type: Boolean,\n    default: false,\n  },\n  multiselectable: {\n    type: Boolean,\n    default: false,\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n})\n\nconst accordionItems = reactive({})\nconst isMultiSelectable = toRef(props, 'multiselectable')\n\nconst {\n  registerAccordionItem,\n  unregisterAccordionItem,\n  openItem,\n  closeItem,\n  toggleItem,\n} = useAccordion(accordionItems, isMultiSelectable)\n\nwatch(accordionItems, () => {\n  emit('update:accordionItems', accordionItems)\n})\n\nprovide(\n  'accordionHeadingTag',\n  computed(() => props.headingTag)\n)\nprovide('registerAccordionItem', registerAccordionItem)\nprovide('unregisterAccordionItem', unregisterAccordionItem)\nprovide('toggleItem', toggleItem)\nprovide('accordionItems', accordionItems)\n\nconst classes = computed(() => [{ 'usa-accordion--bordered': props.bordered }])\n\ndefineExpose({\n  openItem,\n  closeItem,\n  toggleItem,\n})\n</script>\n\n<template>\n  <div\n    class=\"usa-accordion\"\n    :class=\"classes\"\n    :aria-multiselectable=\"isMultiSelectable || null\"\n    ><slot></slot\n  ></div>\n</template>\n", "<script setup>\nimport { computed, inject, toRef, onBeforeUnmount } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst accordionHeadingTag = inject('accordionHeadingTag')\nconst registerAccordionItem = inject('registerAccordionItem')\nconst unregisterAccordionItem = inject('unregisterAccordionItem')\nconst toggleItem = inject('toggleItem')\nconst accordionItems = inject('accordionItems')\n\nconst props = defineProps({\n  id: {\n    type: String,\n    default: '',\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  open: {\n    type: Boolean,\n    default: false,\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        heading: [],\n        button: [],\n        content: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-accordion-item'))\nconst isOpen = toRef(accordionItems, computedId.value)\n\nregisterAccordionItem(computedId.value, props.open)\n\nonBeforeUnmount(() => {\n  unregisterAccordionItem(computedId.value)\n})\n</script>\n\n<template>\n  <BaseHeading\n    v-bind=\"$attrs\"\n    class=\"usa-accordion__heading\"\n    :class=\"customClasses?.heading\"\n    :tag=\"accordionHeadingTag\"\n    ><button\n      type=\"button\"\n      class=\"usa-accordion__button\"\n      :class=\"customClasses?.button\"\n      :aria-expanded=\"isOpen\"\n      :aria-controls=\"computedId\"\n      @click=\"toggleItem(computedId)\"\n      ><slot name=\"label\">{{ label }}</slot></button\n    ></BaseHeading\n  >\n  <div\n    :id=\"computedId\"\n    class=\"usa-accordion__content\"\n    :class=\"customClasses?.content\"\n    :hidden=\"!isOpen\"\n    ><slot></slot\n  ></div>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst props = defineProps({\n  variant: {\n    type: String,\n    default: '',\n    validator(variant) {\n      const isValidVariant = [\n        '',\n        'info',\n        'warning',\n        'error',\n        'success',\n        'emergency',\n        'validation',\n      ].includes(variant)\n\n      if (!isValidVariant) {\n        console.warn(`'${variant}' is not a valid alert variant`)\n      }\n\n      return isValidVariant\n    },\n  },\n  slim: {\n    type: Boolean,\n    default: false,\n  },\n  noIcon: {\n    type: Boolean,\n    default: false,\n  },\n  role: {\n    type: String,\n    default: '',\n  },\n  heading: {\n    type: String,\n    default: '',\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        body: [],\n        heading: [],\n      }\n    },\n  },\n})\n\nconst classes = computed(() => {\n  return {\n    'usa-alert--no-icon': props.noIcon,\n    'usa-alert--slim': props.slim,\n    'usa-alert--info':\n      props.variant === 'info' || props.variant === 'validation',\n    'usa-alert--warning': props.variant === 'warning',\n    'usa-alert--error': props.variant === 'error',\n    'usa-alert--success': props.variant === 'success',\n    'usa-alert--emergency': props.variant === 'emergency',\n    'usa-alert--validation': props.variant === 'validation',\n  }\n})\n\nconst ariaRole = computed(() => {\n  if (props.role) {\n    return props.role\n  }\n\n  if (!props.role && props.variant === 'error') {\n    return 'alert'\n  }\n\n  return null\n})\n</script>\n\n<template>\n  <div class=\"usa-alert\" :class=\"classes\" :role=\"ariaRole\">\n    <div class=\"usa-alert__body\" :class=\"customClasses?.body\">\n      <BaseHeading\n        v-if=\"heading || $slots.heading\"\n        :tag=\"headingTag\"\n        class=\"usa-alert__heading\"\n        :class=\"[{ 'usa-sr-only': slim }, customClasses?.heading]\"\n        ><slot name=\"heading\">{{ heading }}</slot></BaseHeading\n      >\n      <slot name=\"message\">\n        <p class=\"usa-alert__text\"><slot></slot></p>\n      </slot>\n    </div>\n  </div>\n</template>\n", "import { ref, computed, readonly, watch } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\n\nexport default (_id, idPrefix = '', defaultOpen = false, emit) => {\n  const propValue = ref(defaultOpen)\n  const isOpen = ref(propValue.value)\n\n  const toggleId = computed(() => _id || nextId(idPrefix))\n\n  const closeContent = () => {\n    isOpen.value = false\n  }\n\n  const openContent = () => {\n    isOpen.value = true\n  }\n\n  const toggleContent = () => {\n    if (isOpen.value) {\n      closeContent()\n    } else {\n      openContent()\n    }\n  }\n\n  watch(isOpen, newValue => {\n    if (emit) {\n      emit('update:open', newValue)\n    }\n  })\n\n  watch(propValue, newValue => {\n    if (propValue.value !== newValue) {\n      toggleContent()\n    }\n  })\n\n  return {\n    isOpen: readonly(isOpen),\n    toggleId: readonly(toggleId),\n    closeContent,\n    openContent,\n    toggleContent,\n  }\n}\n", "<script setup>\nimport { inject, useSlots } from 'vue'\nimport {\n  PREFIX_SEPARATOR,\n  GRID_NAMESPACE,\n  IMAGE_PATH,\n} from '@/utils/constants.js'\n\nconst slots = useSlots()\n\nif (slots?.tldIcon) {\n  console.warn(`The 'tldIcon' slot is deprecated, use 'tld-icon' instead.`)\n}\n\nif (slots?.tldDescription) {\n  console.warn(\n    `The 'tldDescription' slot is deprecated, use 'tld-description' instead.`\n  )\n}\n\nif (slots?.httpsIcon) {\n  console.warn(`The 'httpsIcon' slot is deprecated, use 'https-icon' instead.`)\n}\n\nif (slots?.httpsDescription) {\n  console.warn(\n    `The 'httpsDescription' slot is deprecated, use 'https-description' instead.`\n  )\n}\n\nconst prefixSeparator = inject('vueUswds.prefixSeparator', PREFIX_SEPARATOR)\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\nconst imagePath = inject('vueUswds.imagePath', IMAGE_PATH)\n</script>\n\n<template>\n  <div :class=\"`${gridNamespace}row ${gridNamespace}gap-lg`\">\n    <div\n      :class=\"`usa-banner__guidance tablet${prefixSeparator}${gridNamespace}col-6`\"\n    >\n      <slot v-if=\"$slots['tld-icon']\" name=\"tld-icon\"></slot>\n      <!--\n      \t@slot tldIcon\n    \t\t@deprecated Use the `tld-icon` slot instead.\n    \t-->\n      <slot v-else-if=\"$slots.tldIcon\" name=\"tldIcon\"></slot>\n      <template v-else>\n        <img\n          class=\"usa-banner__icon usa-media-block__img\"\n          :src=\"`${imagePath}/icon-dot-gov.svg`\"\n          role=\"img\"\n          alt=\"\"\n          aria-hidden=\"true\"\n        />\n      </template>\n      <div class=\"usa-media-block__body\">\n        <slot v-if=\"$slots['tld-description']\" name=\"tld-description\"></slot>\n        <!--\n        \t@slot tldDescription\n      \t\t@deprecated Use the `tld-description` slot instead.\n      \t-->\n        <slot v-else-if=\"$slots.tldDescription\" name=\"tldDescription\"></slot>\n        <template v-else>\n          <p>\n            <strong>Official websites use .gov</strong>\n            <br />\n            A <strong>.gov</strong> website belongs to an official government\n            organization in the United States.\n          </p>\n        </template>\n      </div>\n    </div>\n    <div\n      :class=\"`usa-banner__guidance tablet${prefixSeparator}${gridNamespace}col-6`\"\n    >\n      <slot v-if=\"$slots['https-icon']\" name=\"https-icon\"></slot>\n      <!--\n      \t@slot httpsIcon\n    \t\t@deprecated Use the `https-icon` slot instead.\n    \t-->\n      <slot v-else-if=\"$slots.httpsIcon\" name=\"httpsIcon\"></slot>\n      <template v-else>\n        <img\n          class=\"usa-banner__icon usa-media-block__img\"\n          :src=\"`${imagePath}/icon-https.svg`\"\n          role=\"img\"\n          alt=\"\"\n          aria-hidden=\"true\"\n        />\n      </template>\n      <div class=\"usa-media-block__body\">\n        <slot\n          v-if=\"$slots['https-description']\"\n          name=\"https-description\"\n        ></slot>\n        <!--\n        \t@slot httpsDescription\n      \t\t@deprecated Use the `https-description` slot instead.\n      \t-->\n        <slot\n          v-else-if=\"$slots.httpsDescription\"\n          name=\"httpsDescription\"\n        ></slot>\n        <template v-else>\n          <p>\n            <strong>Secure .gov websites use HTTPS</strong>\n            <br />\n            A <strong>lock</strong> (\n            <span class=\"icon-lock\"\n              ><svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"52\"\n                height=\"64\"\n                viewBox=\"0 0 52 64\"\n                class=\"usa-banner__lock-image\"\n                role=\"img\"\n                aria-labelledby=\"banner-lock-description\"\n                focusable=\"false\"\n              >\n                <title id=\"banner-lock-title\">Lock</title>\n                <desc id=\"banner-lock-description\">Locked padlock icon</desc>\n                <path\n                  fill=\"#000000\"\n                  fill-rule=\"evenodd\"\n                  d=\"M26 0c10.493 0 19 8.507 19 19v9h3a4 4 0 0 1 4 4v28a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V32a4 4 0 0 1 4-4h3v-9C7 8.507 15.507 0 26 0zm0 8c-5.979 0-10.843 4.77-10.996 10.712L15 19v9h22v-9c0-6.075-4.925-11-11-11z\"\n                ></path></svg\n            ></span>\n            ) or <strong>https://</strong> means you've safely connected to the\n            .gov website. Share sensitive information only on official, secure\n            websites.\n          </p>\n        </template>\n      </div>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { computed, toRef, inject } from 'vue'\nimport {\n  PREFIX_SEPARATOR,\n  GRID_NAMESPACE,\n  IMAGE_PATH,\n} from '@/utils/constants.js'\nimport useToggle from '@/composables/useToggle.js'\nimport UsaBannerContent from '@/components/UsaBannerContent'\n\nconst prefixSeparator = inject('vueUswds.prefixSeparator', PREFIX_SEPARATOR)\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\nconst imagePath = inject('vueUswds.imagePath', IMAGE_PATH)\n\nconst emit = defineEmits(['update:open'])\n\nconst props = defineProps({\n  open: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  ariaLabel: {\n    type: String,\n    default: 'Official website of the United States government',\n  },\n  headerText: {\n    type: String,\n    default: 'An official website of the United States government',\n  },\n  actionText: {\n    type: String,\n    default: \"Here's how you know\",\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        accordion: [],\n        bannerHeader: [],\n        bannerInner: [],\n        button: [],\n        bannerContent: [],\n      }\n    },\n  },\n})\n\nconst { isOpen, toggleId, openContent, closeContent, toggleContent } =\n  useToggle(props.id, 'usa-banner', toRef(props, 'open'), emit)\n\nconst headerClasses = computed(() => [\n  { 'usa-banner__header--expanded': isOpen.value },\n  ...(props.customClasses?.bannerHeader || []),\n])\n\ndefineExpose({\n  openContent,\n  closeContent,\n  toggleContent,\n})\n</script>\n\n<template>\n  <section class=\"usa-banner\" :aria-label=\"ariaLabel\">\n    <div class=\"usa-accordion\" :class=\"customClasses?.accordion\">\n      <header class=\"usa-banner__header\" :class=\"headerClasses\">\n        <div class=\"usa-banner__inner\" :class=\"customClasses?.bannerInner\">\n          <div :class=\"`${gridNamespace}col-auto`\">\n            <slot name=\"flag\">\n              <img\n                aria-hidden=\"true\"\n                class=\"usa-banner__header-flag\"\n                :src=\"`${imagePath}/us_flag_small.png`\"\n                alt=\"\"\n              />\n            </slot>\n          </div>\n          <div\n            aria-hidden=\"true\"\n            :class=\"`${gridNamespace}col-fill tablet${prefixSeparator}${gridNamespace}col-auto`\"\n          >\n            <p class=\"usa-banner__header-text\">{{ headerText }}</p>\n            <p class=\"usa-banner__header-action\">{{ actionText }}</p>\n          </div>\n          <button\n            type=\"button\"\n            class=\"usa-accordion__button usa-banner__button\"\n            :class=\"customClasses?.button\"\n            :aria-expanded=\"isOpen\"\n            :aria-controls=\"toggleId\"\n            @click=\"toggleContent()\"\n          >\n            <slot name=\"button\" :is-open=\"isOpen\" :action-text=\"actionText\">\n              <span class=\"usa-banner__button-text\">{{ actionText }}</span>\n            </slot>\n          </button>\n        </div>\n      </header>\n      <div\n        :id=\"toggleId\"\n        :hidden=\"!isOpen\"\n        class=\"usa-banner__content usa-accordion__content\"\n        :class=\"customClasses?.bannerContent\"\n      >\n        <slot><UsaBannerContent></UsaBannerContent></slot>\n      </div>\n    </div>\n  </section>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport BaseLink from '@/components/BaseLink'\n\nconst props = defineProps({\n  href: {\n    type: String,\n    default: '',\n  },\n  to: {\n    type: [String, Object],\n    default: '',\n  },\n  routerComponentName: {\n    type: String,\n    default: '',\n  },\n  current: {\n    type: Boolean,\n    default: false,\n  },\n  customClasses: {\n    type: Object,\n    default: () => ({\n      link: [],\n      span: [],\n    }),\n  },\n})\n\nconst ariaCurrent = computed(() => (props.current ? 'page' : null))\n</script>\n\n<template>\n  <li class=\"usa-breadcrumb__list-item\" :aria-current=\"ariaCurrent\">\n    <span v-if=\"current\" :class=\"customClasses?.span\"><slot></slot></span>\n    <BaseLink\n      v-else\n      :href=\"href\"\n      :to=\"to\"\n      :router-component-name=\"routerComponentName\"\n      class=\"usa-breadcrumb__link\"\n      :class=\"customClasses?.link\"\n    >\n      <span :class=\"customClasses?.span\"><slot></slot></span>\n    </BaseLink>\n  </li>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport UsaBreadcrumbItem from '@/components/UsaBreadcrumbItem'\n\nconst props = defineProps({\n  items: {\n    type: Array,\n    default: () => [],\n  },\n  wrap: {\n    type: Boolean,\n    default: false,\n  },\n  ariaLabel: {\n    type: String,\n    default: 'Breadcrumbs',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        list: [],\n        item: [],\n        link: [],\n        span: [],\n      }\n    },\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-breadcrumb--wrap': props.wrap,\n  },\n])\n\nconst hasCurrent = computed(() => props.items.some(item => item?.current))\n\nconst breadcrumbItems = computed(() => {\n  if (!props.items.length) {\n    return []\n  }\n\n  if (hasCurrent.value) {\n    return props.items\n  }\n\n  const items = [...props.items]\n\n  // If no breadcrumb item has the `current` prop set, automatically set the\n  // last item to `current: true`.\n  items[items.length - 1].current = true\n\n  return items\n})\n</script>\n\n<template>\n  <nav class=\"usa-breadcrumb\" :class=\"classes\" :aria-label=\"ariaLabel\">\n    <ol class=\"usa-breadcrumb__list\" :class=\"customClasses?.list\">\n      <slot :items=\"breadcrumbItems\">\n        <UsaBreadcrumbItem\n          v-for=\"item in breadcrumbItems\"\n          :key=\"item?.id || item.text\"\n          :class=\"customClasses?.item\"\n          :to=\"item.to\"\n          :href=\"item.href\"\n          :router-component-name=\"item.routerComponentName\"\n          :current=\"item.current\"\n          :custom-classes=\"{\n            link: customClasses?.link,\n            span: customClasses?.span,\n          }\"\n          >{{ item.text }}</UsaBreadcrumbItem\n        >\n      </slot>\n    </ol>\n  </nav>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  variant: {\n    type: String,\n    default: '',\n    validator(variant) {\n      return [\n        '',\n        'secondary',\n        'accent-cool',\n        'accent-warm',\n        'base',\n        'outline',\n        'inverse',\n        'unstyled',\n      ].includes(variant)\n    },\n  },\n  size: {\n    type: String,\n    default: '',\n    validator(size) {\n      return ['', 'big'].includes(size)\n    },\n  },\n  type: {\n    type: String,\n    default: 'button',\n    validator(type) {\n      return ['button', 'submit', 'reset'].includes(type)\n    },\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-button--secondary': props.variant === 'secondary',\n    'usa-button--accent-cool': props.variant === 'accent-cool',\n    'usa-button--accent-warm': props.variant === 'accent-warm',\n    'usa-button--base': props.variant === 'base',\n    'usa-button--outline':\n      props.variant === 'outline' || props.variant === 'inverse',\n    'usa-button--inverse': props.variant === 'inverse',\n    'usa-button--unstyled': props.variant === 'unstyled',\n    'usa-button--big': props.size === 'big',\n  },\n])\n</script>\n\n<template>\n  <button\n    v-bind=\"$attrs\"\n    class=\"usa-button\"\n    :class=\"classes\"\n    :type=\"type\"\n    :disabled=\"disabled\"\n  >\n    <slot name=\"before\"></slot>\n    <slot></slot>\n    <slot name=\"after\"></slot>\n  </button>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  segmented: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [\n  { 'usa-button-group--segmented': props.segmented },\n])\n</script>\n\n<template>\n  <ul class=\"usa-button-group\" :class=\"classes\">\n    <slot></slot>\n  </ul>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst props = defineProps({\n  cardTag: {\n    type: String,\n    default: 'div',\n  },\n  heading: {\n    type: String,\n    default: '',\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  flag: {\n    type: Boolean,\n    default: false,\n  },\n  headerFirst: {\n    type: Boolean,\n    default: false,\n  },\n  insetMedia: {\n    type: Boolean,\n    default: false,\n  },\n  mediaPosition: {\n    type: String,\n    default: 'left',\n    validator(mediaPosition) {\n      return ['left', 'right'].includes(mediaPosition)\n    },\n  },\n  headerExdent: {\n    type: Boolean,\n    default: false,\n  },\n  mediaExdent: {\n    type: Boolean,\n    default: false,\n  },\n  bodyExdent: {\n    type: Boolean,\n    default: false,\n  },\n  footerExdent: {\n    type: Boolean,\n    default: false,\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        container: [],\n        header: [],\n        heading: [],\n        media: [],\n        img: [],\n        body: [],\n        footer: [],\n      }\n    },\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-card--header-first': props.headerFirst,\n    'usa-card--flag': props.flag,\n    'usa-card--media-right': props.mediaPosition === 'right',\n  },\n])\n\nconst headerClasses = computed(() => [\n  { 'usa-card__header--exdent': props.headerExdent },\n  ...(props.customClasses?.header || []),\n])\n\nconst mediaClasses = computed(() => [\n  {\n    'usa-card__media--inset': props.insetMedia,\n    'usa-card__media--exdent': props.mediaExdent,\n  },\n  ...(props.customClasses?.media || []),\n])\n\nconst bodyClasses = computed(() => [\n  { 'usa-card__body--exdent': props.bodyExdent },\n  ...(props.customClasses?.body || []),\n])\n\nconst footerClasses = computed(() => [\n  { 'usa-card__footer--exdent': props.footerExdent },\n  ...(props.customClasses?.footer || []),\n])\n</script>\n\n<template>\n  <component :is=\"cardTag\" class=\"usa-card\" :class=\"classes\">\n    <div class=\"usa-card__container\" :class=\"customClasses?.container\">\n      <header\n        v-if=\"heading || $slots.heading\"\n        class=\"usa-card__header\"\n        :class=\"headerClasses\"\n      >\n        <BaseHeading\n          :tag=\"headingTag\"\n          class=\"usa-card__heading\"\n          :class=\"customClasses?.heading\"\n          ><slot name=\"heading\">{{ heading }}</slot></BaseHeading\n        >\n      </header>\n      <div v-if=\"$slots.media\" class=\"usa-card__media\" :class=\"mediaClasses\">\n        <div class=\"usa-card__img\" :class=\"customClasses?.img\"\n          ><slot name=\"media\"></slot\n        ></div>\n      </div>\n      <div v-if=\"$slots.default\" class=\"usa-card__body\" :class=\"bodyClasses\"\n        ><slot></slot\n      ></div>\n      <div v-if=\"$slots.footer\" class=\"usa-card__footer\" :class=\"footerClasses\"\n        ><slot name=\"footer\"></slot\n      ></div>\n    </div>\n  </component>\n</template>\n", "import { shallowRef, watchEffect, readonly, unref, ref, isVue3, version, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isRef, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$6(__spreadValues$9({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nvar _a;\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    filter(() => fn.apply(this, args), { fn, thisArg: this, args });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  const filter = (invoke) => {\n    const duration = resolveUnref(ms);\n    const maxDuration = resolveUnref(options.maxWait);\n    if (timer)\n      clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return invoke();\n    }\n    if (maxDuration && !maxTimer) {\n      maxTimer = setTimeout(() => {\n        if (timer)\n          clearTimeout(timer);\n        maxTimer = null;\n        invoke();\n      }, maxDuration);\n    }\n    timer = setTimeout(() => {\n      if (maxTimer)\n        clearTimeout(maxTimer);\n      maxTimer = null;\n      invoke();\n    }, duration);\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  };\n  const filter = (invoke) => {\n    const duration = resolveUnref(ms);\n    const elapsed = Date.now() - lastExec;\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      timer = setTimeout(() => {\n        lastExec = Date.now();\n        isLeading = true;\n        clear();\n        invoke();\n      }, duration - elapsed);\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive, pause, resume, eventFilter };\n}\n\nfunction __onlyVue3(name = \"this function\") {\n  if (isVue3)\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);\n}\nfunction __onlyVue27Plus(name = \"this function\") {\n  if (isVue3 || version.startsWith(\"2.7.\"))\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 2.7 or above.`);\n}\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = isFunction(fn) ? fn : fn.get;\n  const set = isFunction(fn) ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = [];\n  const off = (fn) => {\n    const index = fns.indexOf(fn);\n    if (index !== -1)\n      fns.splice(index, 1);\n  };\n  const on = (fn) => {\n    fns.push(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (param) => {\n    fns.forEach((fn) => fn(param));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return () => {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    provide(key, composable(...args));\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  __onlyVue27Plus();\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$8({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : resolveUnref;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(keys.map((key) => {\n    const value = obj[key];\n    return [\n      key,\n      typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n    ];\n  }));\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactive(Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, resolveUnref(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true) {\n  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(ref, {\n    get,\n    set,\n    untrackedGet,\n    silentSet,\n    peek,\n    lay\n  }, { enumerable: true });\n}\nconst controlledRef = refWithControl;\n\nfunction resolveRef(r) {\n  return typeof r === \"function\" ? computed(r) : ref(r);\n}\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  var _a, _b;\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options;\n  let watchLeft;\n  let watchRight;\n  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;\n  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchLeft = watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchRight = watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });\n  }\n  return () => {\n    watchLeft == null ? void 0 : watchLeft();\n    watchRight == null ? void 0 : watchRight();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });\n          Object.setPrototypeOf(newObject, objectRef.value);\n          objectRef.value = newObject;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(r, (v) => {\n        if (condition(v) !== isNot) {\n          stop == null ? void 0 : stop();\n          resolve(v);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch([r, value], ([v1, v2]) => {\n        if (isNot !== (v1 === v2)) {\n          stop == null ? void 0 : stop();\n          resolve(v1);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {\n        stop == null ? void 0 : stop();\n        return resolveUnref(r);\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(resolveUnref(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(resolveUnref(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);\n  return computed(() => {\n    const resolved = resolveUnref(list);\n    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nconst defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n};\nconst formatDate = (date, formatStr, options = {}) => {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());\n};\nconst normalizeDate = (date) => {\n  if (date === null)\n    return new Date(NaN);\n  if (date === void 0)\n    return new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n};\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    if (unref(interval) <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, resolveUnref(interval));\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || isFunction(interval)) {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const controls = useIntervalFn(callback ? () => {\n    update();\n    callback(counter.value);\n  } : update, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$6({\n      counter\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, () => ms.value = timestamp(), options);\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, resolveUnref(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending,\n    start,\n    stop\n  };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$7.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(b)) {\n      if (__propIsEnum$7.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$5({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = resolveUnref(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${resolveUnref(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = resolveUnref(truthyValue);\n      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [\n    ...source instanceof Function ? source() : Array.isArray(source) ? source : unref(source)\n  ];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = new Array(oldList.length);\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(source, (...args) => {\n    current.value += 1;\n    if (current.value >= resolveUnref(count))\n      nextTick(() => stop());\n    cb(...args);\n  }, watchOptions);\n  return { count: current, stop };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0,\n    maxWait = void 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\",\n    \"maxWait\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {\n    eventFilter: debounceFilter(debounce, { maxWait })\n  }));\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(eventFilter, cb);\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(source, (...args) => {\n      if (!ignore.value)\n        filteredCb(...args);\n    }, watchOptions);\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(watch(source, () => {\n      syncCounter.value++;\n    }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: \"sync\" })));\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(watch(source, (...args) => {\n      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore)\n        return;\n      filteredCb(...args);\n    }, watchOptions));\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {\n    eventFilter\n  }));\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return __spreadProps(__spreadValues({}, res), {\n    trigger\n  });\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => getOneWatchSource(item));\n  return getOneWatchSource(sources);\n}\nfunction getOneWatchSource(source) {\n  return typeof source === \"function\" ? source() : unref(source);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(source, (v, ov, onInvalidate) => {\n    if (v)\n      cb(v, ov, onInvalidate);\n  }, options);\n}\n\nexport { __onlyVue27Plus, __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n", "import { noop, resolveUnref, isClient, isString, tryOnScopeDispose, tryOnMounted, computedWithControl, promiseTimeout, isFunction, resolveRef, increaseWithUnit, useTimeoutFn, pausableWatch, createEventHook, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, toRefs, containsProp, until, hasOwn, isDef, throttleFilter, useDebounceFn, useThrottleFn, isObject, isNumber, useIntervalFn, clamp, syncRef, objectPick, tryOnUnmounted, isIOS, watchWithFilter, identity } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, watchEffect, computed, inject, unref, watch, getCurrentInstance, customRef, onUpdated, reactive, shallowRef, nextTick, onMounted, markRaw, getCurrentScope, readonly, isVue2, set, del, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nconst createUnrefFn = (fn) => {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => unref(i)));\n  };\n};\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = resolveUnref(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (isString(args[0]) || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener) => {\n    el.addEventListener(event, listener, options);\n    return () => el.removeEventListener(event, listener, options);\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (!el)\n      return;\n    cleanups.push(...events.flatMap((event) => {\n      return listeners.map((listener) => register(el, event, listener));\n    }));\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return;\n  let shouldListen = true;\n  let fallback;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    window.clearTimeout(fallback);\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      if (el)\n        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);\n    }, { passive: true }),\n    useEventListener(window, \"pointerup\", (e) => {\n      if (e.button === 0) {\n        const path = e.composedPath();\n        e.composedPath = () => path;\n        fallback = window.setTimeout(() => listener(e), 50);\n      }\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      var _a;\n      const el = unrefElement(target);\n      if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n        handler(event);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nvar __defProp$m = Object.defineProperty;\nvar __defProps$9 = Object.defineProperties;\nvar __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$o = Object.getOwnPropertySymbols;\nvar __hasOwnProp$o = Object.prototype.hasOwnProperty;\nvar __propIsEnum$o = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$m = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$o.call(b, prop))\n      __defNormalProp$m(a, prop, b[prop]);\n  if (__getOwnPropSymbols$o)\n    for (var prop of __getOwnPropSymbols$o(b)) {\n      if (__propIsEnum$o.call(b, prop))\n        __defNormalProp$m(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));\nconst createKeyPredicate = (keyFilter) => {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n};\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const { target = defaultWindow, eventName = \"keydown\", passive = false } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keydown\" }));\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keypress\" }));\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keyup\" }));\n}\n\nconst DEFAULT_DELAY = 500;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    timeout = setTimeout(() => handler(ev), (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY);\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions);\n  useEventListener(elementRef, \"pointerup\", clear, listenerOptions);\n  useEventListener(elementRef, \"pointerleave\", clear, listenerOptions);\n}\n\nconst isFocusedElementEditable = () => {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n};\nconst isTypedCharValid = ({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) => {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  return false;\n};\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  const { window = defaultWindow } = options;\n  const activeElement = computedWithControl(() => null, () => window == null ? void 0 : window.document.activeElement);\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget === null)\n        return;\n      activeElement.trigger();\n    }, true);\n    useEventListener(window, \"focus\", activeElement.trigger, true);\n  }\n  return activeElement;\n}\n\nfunction useAsyncQueue(tasks, options = {}) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop\n  } = options;\n  const promiseState = {\n    pending: \"pending\",\n    rejected: \"rejected\",\n    fulfilled: \"fulfilled\"\n  };\n  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      return curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n    }).catch((e) => {\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = ref(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw error;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  return {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = resolveUnref(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || isFunction(target))\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useSupported(callback, sync = false) {\n  const isSupported = ref();\n  const update = () => isSupported.value = Boolean(callback());\n  update();\n  tryOnMounted(update, sync);\n  return isSupported;\n}\n\nfunction useBattery({ navigator = defaultNavigator } = {}) {\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator);\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      for (const event of events)\n        useEventListener(battery, event, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    device,\n    requestDevice,\n    server,\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", update);\n    else\n      mediaQuery.removeListener(update);\n  };\n  const update = () => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(resolveRef(query).value);\n    matches.value = mediaQuery.matches;\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", update);\n    else\n      mediaQuery.addListener(update);\n  };\n  watchEffect(update);\n  tryOnScopeDispose(() => cleanup());\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetify = {\n  xs: 600,\n  sm: 960,\n  md: 1264,\n  lg: 1904\n};\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 600,\n  sm: 1024,\n  md: 1440,\n  lg: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\n\nvar __defProp$l = Object.defineProperty;\nvar __getOwnPropSymbols$n = Object.getOwnPropertySymbols;\nvar __hasOwnProp$n = Object.prototype.hasOwnProperty;\nvar __propIsEnum$n = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$l = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$n.call(b, prop))\n      __defNormalProp$l(a, prop, b[prop]);\n  if (__getOwnPropSymbols$n)\n    for (var prop of __getOwnPropSymbols$n(b)) {\n      if (__propIsEnum$n.call(b, prop))\n        __defNormalProp$l(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = breakpoints[k];\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => greaterOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  return __spreadValues$l({\n    greater(k) {\n      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    greaterOrEqual,\n    smaller(k) {\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    smallerOrEqual(k) {\n      return useMediaQuery(`(max-width: ${getValue(k)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    }\n  }, shortcutMethods);\n}\n\nconst useBroadcastChannel = (options) => {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = ref(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n};\n\nfunction useBrowserLocation({ window = defaultWindow } = {}) {\n  const buildState = (trigger) => {\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window == null ? void 0 : window.location) || {};\n    return {\n      trigger,\n      state: state2,\n      length,\n      hash,\n      host,\n      hostname,\n      href,\n      origin,\n      pathname,\n      port,\n      protocol,\n      search\n    };\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const events = [\"copy\", \"cut\"];\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read) {\n    for (const event of events)\n      useEventListener(event, updateText);\n  }\n  async function copy(value = resolveUnref(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value)\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nvar __defProp$k = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$m = Object.getOwnPropertySymbols;\nvar __hasOwnProp$m = Object.prototype.hasOwnProperty;\nvar __propIsEnum$m = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$k = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$m.call(b, prop))\n      __defNormalProp$k(a, prop, b[prop]);\n  if (__getOwnPropSymbols$m)\n    for (var prop of __getOwnPropSymbols$m(b)) {\n      if (__propIsEnum$m.call(b, prop))\n        __defNormalProp$k(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(unref(source));\n  }\n  if (!manual && isRef(source)) {\n    watch(source, sync, __spreadProps$8(__spreadValues$k({}, options), {\n      deep,\n      immediate\n    }));\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\n_global[globalKey] = _global[globalKey] || {};\nconst handlers = _global[globalKey];\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nvar __defProp$j = Object.defineProperty;\nvar __getOwnPropSymbols$l = Object.getOwnPropertySymbols;\nvar __hasOwnProp$l = Object.prototype.hasOwnProperty;\nvar __propIsEnum$l = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$j = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$l.call(b, prop))\n      __defNormalProp$j(a, prop, b[prop]);\n  if (__getOwnPropSymbols$l)\n    for (var prop of __getOwnPropSymbols$l(b)) {\n      if (__propIsEnum$l.call(b, prop))\n        __defNormalProp$j(a, prop, b[prop]);\n    }\n  return a;\n};\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const data = (shallow ? shallowRef : ref)(defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = resolveUnref(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(data, () => write(data.value), { flush, deep, eventFilter });\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", update);\n  update();\n  return data;\n  function write(v) {\n    try {\n      if (v == null) {\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        const oldValue = storage.getItem(key);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          if (window) {\n            window == null ? void 0 : window.dispatchEvent(new StorageEvent(\"storage\", {\n              key,\n              oldValue,\n              newValue: serialized,\n              storageArea: storage\n            }));\n          }\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit !== null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (isFunction(mergeDefaults))\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return __spreadValues$j(__spreadValues$j({}, rawInit), value);\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nvar __defProp$i = Object.defineProperty;\nvar __getOwnPropSymbols$k = Object.getOwnPropertySymbols;\nvar __hasOwnProp$k = Object.prototype.hasOwnProperty;\nvar __propIsEnum$k = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$i = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$k.call(b, prop))\n      __defNormalProp$i(a, prop, b[prop]);\n  if (__getOwnPropSymbols$k)\n    for (var prop of __getOwnPropSymbols$k(b)) {\n      if (__propIsEnum$k.call(b, prop))\n        __defNormalProp$i(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto\n  } = options;\n  const modes = __spreadValues$i({\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\"\n  }, options.modes || {});\n  const preferredDark = usePreferredDark({ window });\n  const preferredMode = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? ref(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed({\n    get() {\n      return store.value === \"auto\" && !emitAuto ? preferredMode.value : store.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  const updateHTMLAttrs = getSSRHandler(\"updateHTMLAttrs\", (selector2, attribute2, value) => {\n    const el = window == null ? void 0 : window.document.querySelector(selector2);\n    if (!el)\n      return;\n    if (attribute2 === \"class\") {\n      const current = value.split(/\\s/g);\n      Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n        if (current.includes(v))\n          el.classList.add(v);\n        else\n          el.classList.remove(v);\n      });\n    } else {\n      el.setAttribute(attribute2, value);\n    }\n  });\n  function defaultOnChanged(mode) {\n    var _a;\n    const resolvedMode = mode === \"auto\" ? preferredMode.value : mode;\n    updateHTMLAttrs(selector, attribute, (_a = modes[resolvedMode]) != null ? _a : resolvedMode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  if (emitAuto)\n    watch(preferredMode, () => onChanged(state.value), { flush: \"post\" });\n  tryOnMounted(() => onChanged(state.value));\n  return state;\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, { window = defaultWindow, initialValue = \"\" } = {}) {\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  watch([elRef, () => resolveUnref(prop)], ([el, prop2]) => {\n    var _a;\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }, { immediate: true });\n  watch(variable, (val) => {\n    var _a;\n    if ((_a = elRef.value) == null ? void 0 : _a.style)\n      elRef.value.style.setProperty(resolveUnref(prop), val);\n  });\n  return variable;\n}\n\nfunction useCurrentElement() {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(() => null, () => vm.proxy.$el);\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  var _a;\n  const state = shallowRef((_a = options == null ? void 0 : options.initialValue) != null ? _a : list[0]);\n  const index = computed({\n    get() {\n      var _a2;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list) : list.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a2 = options == null ? void 0 : options.fallbackIndex) != null ? _a2 : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const length = list.length;\n    const index2 = (i % length + length) % length;\n    const value = list[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  return {\n    state,\n    index,\n    next,\n    prev\n  };\n}\n\nvar __defProp$h = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$j = Object.getOwnPropertySymbols;\nvar __hasOwnProp$j = Object.prototype.hasOwnProperty;\nvar __propIsEnum$j = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$h = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$j.call(b, prop))\n      __defNormalProp$h(a, prop, b[prop]);\n  if (__getOwnPropSymbols$j)\n    for (var prop of __getOwnPropSymbols$j(b)) {\n      if (__propIsEnum$j.call(b, prop))\n        __defNormalProp$h(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode(__spreadProps$7(__spreadValues$h({}, options), {\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\");\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  }));\n  const preferredDark = usePreferredDark({ window });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      if (v === preferredDark.value)\n        mode.value = \"auto\";\n      else\n        mode.value = v ? \"dark\" : \"light\";\n    }\n  });\n  return isDark;\n}\n\nconst fnBypass = (v) => v;\nconst fnSetSource = (source, value) => source.value = value;\nfunction defaultDump(clone) {\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Infinity);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nvar __defProp$g = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$i = Object.getOwnPropertySymbols;\nvar __hasOwnProp$i = Object.prototype.hasOwnProperty;\nvar __propIsEnum$i = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$g = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$i.call(b, prop))\n      __defNormalProp$g(a, prop, b[prop]);\n  if (__getOwnPropSymbols$i)\n    for (var prop of __getOwnPropSymbols$i(b)) {\n      if (__propIsEnum$i.call(b, prop))\n        __defNormalProp$g(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(source, commit, { deep, flush, eventFilter: composedFilter });\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, __spreadProps$6(__spreadValues$g({}, options), { clone: options.clone || deep, setSource }));\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return __spreadProps$6(__spreadValues$g({}, manualHistory), {\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  });\n}\n\nvar __defProp$f = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$h = Object.getOwnPropertySymbols;\nvar __hasOwnProp$h = Object.prototype.hasOwnProperty;\nvar __propIsEnum$h = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$f = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$h.call(b, prop))\n      __defNormalProp$f(a, prop, b[prop]);\n  if (__getOwnPropSymbols$h)\n    for (var prop of __getOwnPropSymbols$h(b)) {\n      if (__propIsEnum$h.call(b, prop))\n        __defNormalProp$f(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, __spreadProps$5(__spreadValues$f({}, options), { eventFilter: filter }));\n  return __spreadValues$f({}, history);\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(eventFilter, (event) => {\n      acceleration.value = event.acceleration;\n      accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n      rotationRate.value = event.rotationRate;\n      interval.value = event.interval;\n    });\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio({\n  window = defaultWindow\n} = {}) {\n  if (!window) {\n    return {\n      pixelRatio: ref(1)\n    };\n  }\n  const pixelRatio = ref(1);\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.map((i) => i());\n    cleanups.length = 0;\n  };\n  const observe = () => {\n    pixelRatio.value = window.devicePixelRatio;\n    cleanup();\n    const media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n    media.addEventListener(\"change\", observe, { once: true });\n    cleanups.push(() => {\n      media.removeEventListener(\"change\", observe);\n    });\n  };\n  observe();\n  tryOnScopeDispose(cleanup);\n  return { pixelRatio };\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      stream.getTracks().forEach((t) => t.stop());\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility({ document = defaultDocument } = {}) {\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nvar __defProp$e = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$g = Object.getOwnPropertySymbols;\nvar __hasOwnProp$g = Object.prototype.hasOwnProperty;\nvar __propIsEnum$g = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$e = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$g.call(b, prop))\n      __defNormalProp$e(a, prop, b[prop]);\n  if (__getOwnPropSymbols$g)\n    for (var prop of __getOwnPropSymbols$g(b)) {\n      if (__propIsEnum$g.call(b, prop))\n        __defNormalProp$e(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nfunction useDraggable(target, options = {}) {\n  var _a, _b, _c;\n  const draggingElement = (_a = options.draggingElement) != null ? _a : defaultWindow;\n  const draggingHandle = (_b = options.handle) != null ? _b : target;\n  const position = ref((_c = resolveUnref(options.initialValue)) != null ? _c : { x: 0, y: 0 });\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (options.pointerTypes)\n      return options.pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (resolveUnref(options.preventDefault))\n      e.preventDefault();\n    if (resolveUnref(options.stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (resolveUnref(options.exact) && e.target !== resolveUnref(target))\n      return;\n    const rect = resolveUnref(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n    if (((_a2 = options.onStart) == null ? void 0 : _a2.call(options, pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    position.value = {\n      x: e.clientX - pressedDelta.value.x,\n      y: e.clientY - pressedDelta.value.y\n    };\n    (_a2 = options.onMove) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    useEventListener(draggingHandle, \"pointerdown\", start, true);\n    useEventListener(draggingElement, \"pointermove\", move, true);\n    useEventListener(draggingElement, \"pointerup\", end, true);\n  }\n  return __spreadProps$4(__spreadValues$e({}, toRefs(position)), {\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(() => `left:${position.value.x}px;top:${position.value.y}px;`)\n  });\n}\n\nfunction useDropZone(target, onDrop) {\n  const isOverDropZone = ref(false);\n  let counter = 0;\n  if (isClient) {\n    useEventListener(target, \"dragenter\", (event) => {\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      event.preventDefault();\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a, _b;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      const files = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);\n    });\n  }\n  return {\n    isOverDropZone\n  };\n}\n\nvar __getOwnPropSymbols$f = Object.getOwnPropertySymbols;\nvar __hasOwnProp$f = Object.prototype.hasOwnProperty;\nvar __propIsEnum$f = Object.prototype.propertyIsEnumerable;\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$f)\n    for (var prop of __getOwnPropSymbols$f(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useResizeObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported.value && window && el) {\n      observer = new ResizeObserver(callback);\n      observer.observe(el, observerOptions);\n    }\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    const delta = timestamp - previousFrameTimestamp;\n    fn({ delta, timestamp });\n    previousFrameTimestamp = timestamp;\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$d = Object.defineProperty;\nvar __getOwnPropSymbols$e = Object.getOwnPropertySymbols;\nvar __hasOwnProp$e = Object.prototype.hasOwnProperty;\nvar __propIsEnum$e = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$d = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$e.call(b, prop))\n      __defNormalProp$d(a, prop, b[prop]);\n  if (__getOwnPropSymbols$e)\n    for (var prop of __getOwnPropSymbols$e(b)) {\n      if (__propIsEnum$e.call(b, prop))\n        __defNormalProp$d(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useElementByPoint(options) {\n  const element = ref(null);\n  const { x, y } = options;\n  const controls = useRafFn(() => {\n    element.value = document.elementFromPoint(resolveUnref(x), resolveUnref(y));\n  });\n  return __spreadValues$d({\n    element\n  }, controls);\n}\n\nfunction useElementHover(el) {\n  const isHovered = ref(false);\n  useEventListener(el, \"mouseenter\", () => isHovered.value = true);\n  useEventListener(el, \"mouseleave\", () => isHovered.value = false);\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { box = \"content-box\" } = options;\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  useResizeObserver(target, ([entry]) => {\n    const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n    if (boxSize) {\n      width.value = boxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n      height.value = boxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n    } else {\n      width.value = entry.contentRect.width;\n      height.value = entry.contentRect.height;\n    }\n  }, options);\n  watch(() => unrefElement(target), (ele) => {\n    width.value = ele ? initialSize.width : 0;\n    height.value = ele ? initialSize.height : 0;\n  });\n  return {\n    width,\n    height\n  };\n}\n\nfunction useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {\n  const elementIsVisible = ref(false);\n  const testBounding = () => {\n    if (!window)\n      return;\n    const document = window.document;\n    const el = unrefElement(element);\n    if (!el) {\n      elementIsVisible.value = false;\n    } else {\n      const rect = el.getBoundingClientRect();\n      elementIsVisible.value = rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;\n    }\n  };\n  watch(() => unrefElement(element), () => testBounding(), { immediate: true, flush: \"post\" });\n  if (window) {\n    useEventListener(scrollTarget || window, \"scroll\", testBounding, {\n      capture: false,\n      passive: true\n    });\n  }\n  return elementIsVisible;\n}\n\nconst events = new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || [];\n    listeners.push(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    const index = listeners.indexOf(listener);\n    if (index > -1)\n      listeners.splice(index, 1);\n    if (!listeners.length)\n      events.delete(key);\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = ref(null);\n  const {\n    withCredentials = false\n  } = options;\n  const close = () => {\n    if (eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n    }\n  };\n  const es = new EventSource(url, { withCredentials });\n  eventSource.value = es;\n  es.onopen = () => {\n    status.value = \"OPEN\";\n    error.value = null;\n  };\n  es.onerror = (e) => {\n    status.value = \"CLOSED\";\n    error.value = e;\n  };\n  es.onmessage = (e) => {\n    event.value = null;\n    data.value = e.data;\n  };\n  for (const event_name of events) {\n    useEventListener(es, event_name, (e) => {\n      event.value = event_name;\n      data.value = e.data || null;\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = resolveRef(newIcon);\n  const applyIcon = (icon) => {\n    document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`).forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(favicon, (i, o) => {\n    if (isString(i) && i !== o)\n      applyIcon(i);\n  }, { immediate: true });\n  return favicon;\n}\n\nvar __defProp$c = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$c = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$c(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$c(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries([...headers.entries()]);\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback !== void 0)\n        await callback(ctx);\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      await callbacks.reduce((prevCallback, callback) => prevCallback.then(async () => {\n        if (callback)\n          ctx = __spreadValues$c(__spreadValues$c({}, ctx), await callback(ctx));\n      }), Promise.resolve());\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = resolveUnref(config.baseUrl);\n      const targetUrl = resolveUnref(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, options), args[0]), {\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        });\n      } else {\n        fetchOptions = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, fetchOptions), args[0]), {\n          headers: __spreadValues$c(__spreadValues$c({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})\n        });\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, options), args[1]), {\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      });\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = { immediate: true, refetch: false, timeout: 0 };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = __spreadValues$c(__spreadValues$c({}, options), args[0]);\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = __spreadValues$c(__spreadValues$c({}, options), args[1]);\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort && controller)\n      controller.abort();\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  const execute = async (throwOnFailed = false) => {\n    var _a2;\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    controller = void 0;\n    if (supportsAbort) {\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = __spreadProps$3(__spreadValues$c({}, fetchOptions), {\n        signal: controller.signal\n      });\n    }\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      const payload = resolveUnref(config.payload);\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = { url: resolveUnref(url), options: __spreadValues$c(__spreadValues$c({}, defaultFetchOptions), fetchOptions), cancel: () => {\n      isCanceled = true;\n    } };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return new Promise((resolve, reject) => {\n      var _a3;\n      fetch(context.url, __spreadProps$3(__spreadValues$c(__spreadValues$c({}, defaultFetchOptions), context.options), {\n        headers: __spreadValues$c(__spreadValues$c({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))\n      })).then(async (fetchResponse) => {\n        response.value = fetchResponse;\n        statusCode.value = fetchResponse.status;\n        responseData = await fetchResponse[config.type]();\n        if (options.afterFetch && statusCode.value >= 200 && statusCode.value < 300)\n          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));\n        data.value = responseData;\n        if (!fetchResponse.ok)\n          throw new Error(fetchResponse.statusText);\n        responseEvent.trigger(fetchResponse);\n        return resolve(fetchResponse);\n      }).catch(async (fetchError) => {\n        let errorData = fetchError.message || fetchError.name;\n        if (options.onFetchError)\n          ({ data: responseData, error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }));\n        data.value = responseData;\n        error.value = errorData;\n        errorEvent.trigger(fetchError);\n        if (throwOnFailed)\n          return reject(fetchError);\n        return resolve(null);\n      }).finally(() => {\n        loading(false);\n        if (timer)\n          timer.stop();\n        finallyEvent.trigger(null);\n      });\n    });\n  };\n  const refetch = resolveRef(options.refetch);\n  watch([\n    refetch,\n    resolveRef(url)\n  ], ([refetch2]) => refetch2 && execute(), { deep: true });\n  const shell = {\n    isFinished,\n    statusCode,\n    response,\n    error,\n    data,\n    isFetching,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch([\n            refetch,\n            resolveRef(config.payload)\n          ], ([refetch2]) => refetch2 && execute(), { deep: true });\n        }\n        const rawPayload = resolveUnref(config.payload);\n        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype && !(rawPayload instanceof FormData))\n          config.payloadType = \"json\";\n        return __spreadProps$3(__spreadValues$c({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return __spreadProps$3(__spreadValues$c({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    setTimeout(execute, 0);\n  return __spreadProps$3(__spreadValues$c({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  });\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nvar __defProp$b = Object.defineProperty;\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$c.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(b)) {\n      if (__propIsEnum$c.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\"\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n    };\n  }\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = __spreadValues$b(__spreadValues$b(__spreadValues$b({}, DEFAULT_OPTIONS), options), localOptions);\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    input.click();\n  };\n  const reset = () => {\n    files.value = null;\n    if (input)\n      input.value = \"\";\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset\n  };\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = unref(options);\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    fileHandle.value = handle;\n    await updateFile();\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    data.value = void 0;\n    await updateFile();\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    if (unref(dataType) === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    if (unref(dataType) === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    if (unref(dataType) === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => unref(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false } = options;\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed({\n    get() {\n      return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;\n    },\n    set(value) {\n      var _a, _b;\n      if (!value && focused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      if (value && !focused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(targetElement, () => {\n    focused.value = initialValue;\n  }, { immediate: true, flush: \"post\" });\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst functionsMap = [\n  [\n    \"requestFullscreen\",\n    \"exitFullscreen\",\n    \"fullscreenElement\",\n    \"fullscreenEnabled\",\n    \"fullscreenchange\",\n    \"fullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullscreen\",\n    \"webkitExitFullscreen\",\n    \"webkitFullscreenElement\",\n    \"webkitFullscreenEnabled\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullScreen\",\n    \"webkitCancelFullScreen\",\n    \"webkitCurrentFullScreenElement\",\n    \"webkitCancelFullScreen\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"mozRequestFullScreen\",\n    \"mozCancelFullScreen\",\n    \"mozFullScreenElement\",\n    \"mozFullScreenEnabled\",\n    \"mozfullscreenchange\",\n    \"mozfullscreenerror\"\n  ],\n  [\n    \"msRequestFullscreen\",\n    \"msExitFullscreen\",\n    \"msFullscreenElement\",\n    \"msFullscreenEnabled\",\n    \"MSFullscreenChange\",\n    \"MSFullscreenError\"\n  ]\n];\nfunction useFullscreen(target, options = {}) {\n  const { document = defaultDocument, autoExit = false } = options;\n  const targetRef = target || (document == null ? void 0 : document.querySelector(\"html\"));\n  const isFullscreen = ref(false);\n  let map = functionsMap[0];\n  const isSupported = useSupported(() => {\n    if (!document) {\n      return false;\n    } else {\n      for (const m of functionsMap) {\n        if (m[1] in document) {\n          map = m;\n          return true;\n        }\n      }\n    }\n    return false;\n  });\n  const [REQUEST, EXIT, ELEMENT, , EVENT] = map;\n  async function exit() {\n    if (!isSupported.value)\n      return;\n    if (document == null ? void 0 : document[ELEMENT])\n      await document[EXIT]();\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value)\n      return;\n    await exit();\n    const target2 = unrefElement(targetRef);\n    if (target2) {\n      await target2[REQUEST]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    if (isFullscreen.value)\n      await exit();\n    else\n      await enter();\n  }\n  if (document) {\n    useEventListener(document, EVENT, () => {\n      isFullscreen.value = !!(document == null ? void 0 : document[ELEMENT]);\n    }, false);\n  }\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      hapticActuators,\n      index: gamepad.index,\n      mapping: gamepad.mapping,\n      connected: gamepad.connected,\n      timestamp: gamepad.timestamp,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (let i = 0; i < _gamepads.length; ++i) {\n      const gamepad = _gamepads[i];\n      if (gamepad) {\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\n        if (index > -1)\n          gamepads.value[index] = stateFromGamepad(gamepad);\n      }\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    if (_gamepads) {\n      for (let i = 0; i < _gamepads.length; ++i) {\n        const gamepad = _gamepads[i];\n        if (gamepad)\n          onGamepadConnected(gamepad);\n      }\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = ref(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Infinity,\n    longitude: Infinity,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(updatePosition, (err) => error.value = err, {\n        enableHighAccuracy,\n        maximumAge,\n        timeout\n      });\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const onEvent = createFilterWrapper(eventFilter, () => {\n    idle.value = false;\n    lastActive.value = timestamp();\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  });\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n  }\n  timer = setTimeout(() => idle.value = true, timeout);\n  return { idle, lastActive };\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nconst useImage = (options, asyncStateOptions = {}) => {\n  const state = useAsyncState(() => loadImage(resolveUnref(options)), void 0, __spreadValues$9({\n    resetOnExecute: true\n  }, asyncStateOptions));\n  watch(() => resolveUnref(options), () => state.execute(asyncStateOptions.delay), { deep: true });\n  return state;\n};\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\"\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    const _element = resolveUnref(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = resolveUnref(_y)) != null ? _a : y.value,\n      left: (_b = resolveUnref(_x)) != null ? _b : x.value,\n      behavior: resolveUnref(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = useDebounceFn((e) => {\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  }, throttle + idle);\n  const onScrollHandler = (e) => {\n    const eventTarget = e.target === document ? e.target.documentElement : e.target;\n    const scrollLeft = eventTarget.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalY.value;\n    arrivedState.left = scrollLeft <= 0 + (offset.left || 0);\n    arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    internalX.value = scrollLeft;\n    let scrollTop = eventTarget.scrollTop;\n    if (e.target === document && !scrollTop)\n      scrollTop = document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    arrivedState.top = scrollTop <= 0 + (offset.top || 0);\n    arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    internalY.value = scrollTop;\n    isScrolling.value = true;\n    onScrollEnd(e);\n    onScroll(e);\n  };\n  useEventListener(element, \"scroll\", throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler, eventListenerOptions);\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions\n  };\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a, _b;\n  const direction = (_a = options.direction) != null ? _a : \"bottom\";\n  const state = reactive(useScroll(element, __spreadProps$2(__spreadValues$8({}, options), {\n    offset: __spreadValues$8({\n      [direction]: (_b = options.distance) != null ? _b : 0\n    }, options.offset)\n  })));\n  watch(() => state.arrivedState[direction], async (v) => {\n    var _a2, _b2;\n    if (v) {\n      const elem = resolveUnref(element);\n      const previous = {\n        height: (_a2 = elem == null ? void 0 : elem.scrollHeight) != null ? _a2 : 0,\n        width: (_b2 = elem == null ? void 0 : elem.scrollWidth) != null ? _b2 : 0\n      };\n      await onLoadMore(state);\n      if (options.preserveScrollPosition && elem) {\n        nextTick(() => {\n          elem.scrollTo({\n            top: elem.scrollHeight - previous.height,\n            left: elem.scrollWidth - previous.width\n          });\n        });\n      }\n    }\n  });\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  let cleanup = noop;\n  const stopWatch = isSupported.value ? watch(() => ({\n    el: unrefElement(target),\n    root: unrefElement(root)\n  }), ({ el, root: root2 }) => {\n    cleanup();\n    if (!el)\n      return;\n    const observer = new IntersectionObserver(callback, {\n      root: root2,\n      rootMargin,\n      threshold\n    });\n    observer.observe(el);\n    cleanup = () => {\n      observer.disconnect();\n      cleanup = noop;\n    };\n  }, { immediate: true, flush: \"post\" }) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(new Set());\n  const obj = { toJSON() {\n    return {};\n  }, current };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = new Set();\n  const usedKeys = new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(refs, {\n    get(target2, prop, rec) {\n      if (typeof prop !== \"string\")\n        return Reflect.get(target2, prop, rec);\n      prop = prop.toLowerCase();\n      if (prop in aliasMap)\n        prop = aliasMap[prop];\n      if (!(prop in refs)) {\n        if (/[+_-]/.test(prop)) {\n          const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n          refs[prop] = computed(() => keys.every((key) => unref(proxy[key])));\n        } else {\n          refs[prop] = ref(false);\n        }\n      }\n      const r = Reflect.get(target2, prop, rec);\n      return useReactive ? unref(r) : r;\n    }\n  });\n  return proxy;\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction usingElRef(source, cb) {\n  if (resolveUnref(source))\n    cb(resolveUnref(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = __spreadValues$7(__spreadValues$7({}, defaultOptions), options);\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = isNumber(track) ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = isNumber(track) ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    const src = resolveUnref(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (isString(src))\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch(volume, (vol) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.volume = vol;\n  });\n  watch(muted, (mute) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.muted = mute;\n  });\n  watch(rate, (rate2) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.playbackRate = rate2;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = resolveUnref(options.tracks);\n    const el = resolveUnref(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = resolveUnref(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = resolveUnref(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(resolveUnref(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, \"waiting\", () => waiting.value = true);\n  useEventListener(target, \"playing\", () => waiting.value = false);\n  useEventListener(target, \"ratechange\", () => rate.value = resolveUnref(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    volume,\n    muted,\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nconst getMapVue2Compat = () => {\n  const data = reactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n};\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return reactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return reactive(new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  onMounted(() => {\n    isMounted.value = true;\n  });\n  return isMounted;\n}\n\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    eventFilter\n  } = options;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const mouseHandler = (event) => {\n    if (type === \"page\") {\n      x.value = event.pageX;\n      y.value = event.pageY;\n    } else if (type === \"client\") {\n      x.value = event.clientX;\n      y.value = event.clientY;\n    }\n    sourceType.value = \"mouse\";\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const touch2 = event.touches[0];\n      if (type === \"page\") {\n        x.value = touch2.pageX;\n        y.value = touch2.pageY;\n      } else if (type === \"client\") {\n        x.value = touch2.clientX;\n        y.value = touch2.clientY;\n      }\n      sourceType.value = \"touch\";\n    }\n  };\n  const mouseHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});\n  };\n  const touchHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});\n  };\n  if (window) {\n    useEventListener(window, \"mousemove\", mouseHandlerWrapper, { passive: true });\n    useEventListener(window, \"dragover\", mouseHandlerWrapper, { passive: true });\n    if (touch) {\n      useEventListener(window, \"touchstart\", touchHandlerWrapper, { passive: true });\n      useEventListener(window, \"touchmove\", touchHandlerWrapper, { passive: true });\n      if (resetOnTouchEnds)\n        useEventListener(window, \"touchend\", reset, { passive: true });\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch([targetRef, x, y], () => {\n      const el = unrefElement(targetRef);\n      if (!el)\n        return;\n      const {\n        left,\n        top,\n        width,\n        height\n      } = el.getBoundingClientRect();\n      elementPositionX.value = left + window.pageXOffset;\n      elementPositionY.value = top + window.pageYOffset;\n      elementHeight.value = height;\n      elementWidth.value = width;\n      const elX = x.value - elementPositionX.value;\n      const elY = y.value - elementPositionY.value;\n      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n      if (handleOutside || !isOutside.value) {\n        elementX.value = elX;\n        elementY.value = elY;\n      }\n    }, { immediate: true });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true });\n    useEventListener(window, \"drop\", onReleased, { passive: true });\n    useEventListener(window, \"dragend\", onReleased, { passive: true });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true });\n    useEventListener(window, \"touchend\", onReleased, { passive: true });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useMutationObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, mutationOptions = __objRest$1(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported.value && window && el) {\n      observer = new MutationObserver(callback);\n      observer.observe(el, mutationOptions);\n    }\n  }, { immediate: true });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst useNavigatorLanguage = (options = {}) => {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n};\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(new Date());\n  const update = () => now.value = new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return __spreadValues$6({\n      now\n    }, controls);\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(() => unref(object), (newObject) => {\n    release();\n    if (newObject)\n      url.value = URL.createObjectURL(newObject);\n  }, { immediate: true });\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, resolveUnref(min), resolveUnref(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, resolveUnref(min), resolveUnref(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Infinity,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Infinity);\n  const pageCount = computed(() => Math.max(1, Math.ceil(unref(total) / unref(currentPageSize))));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page))\n    syncRef(page, currentPage);\n  if (isRef(pageSize))\n    syncRef(pageSize, currentPageSize);\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = -orientation.beta / 90;\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = orientation.gamma / 90;\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    useEventListener(target, \"pointerdown\", handler, { passive: true });\n    useEventListener(target, \"pointermove\", handler, { passive: true });\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, { passive: true });\n  }\n  return __spreadProps$1(__spreadValues$5({}, toRefs(state)), {\n    isInside\n  });\n}\n\nvar SwipeDirection;\n(function(SwipeDirection2) {\n  SwipeDirection2[\"UP\"] = \"UP\";\n  SwipeDirection2[\"RIGHT\"] = \"RIGHT\";\n  SwipeDirection2[\"DOWN\"] = \"DOWN\";\n  SwipeDirection2[\"LEFT\"] = \"LEFT\";\n  SwipeDirection2[\"NONE\"] = \"NONE\";\n})(SwipeDirection || (SwipeDirection = {}));\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return SwipeDirection.NONE;\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n    } else {\n      return diffY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchend\", onTouchEnd, listenerOptions),\n    useEventListener(target, \"touchcancel\", onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = resolveRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return SwipeDirection.NONE;\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n    } else {\n      return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\n    })\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nconst useScreenOrientation = (options = {}) => {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (!isSupported.value)\n      return Promise.reject(new Error(\"Not supported\"));\n    return screenOrientation.lock(type);\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value)\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n};\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = resolveUnref(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow;\n  watch(resolveRef(element), (el) => {\n    if (el) {\n      const ele = el;\n      initialOverflow = ele.style.overflow;\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const ele = resolveUnref(element);\n    if (!ele || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(ele, \"touchmove\", preventDefault, { passive: false });\n    }\n    ele.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const ele = resolveUnref(element);\n    if (!ele || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    ele.style.overflow = initialOverflow;\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = __spreadValues$4(__spreadValues$4({}, resolveUnref(shareOptions)), resolveUnref(overrideOptions));\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...unref(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(unref(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = resolveRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = unref(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = unref(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = resolveRef(text || \"\");\n  const lang = resolveRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = unref(lang);\n    utterance2.voice = unref(options.voice) || null;\n    utterance2.pitch = pitch;\n    utterance2.rate = rate;\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = resolveUnref(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => setTimeout(() => read(e), 0));\n  if (storage) {\n    watchWithFilter(data, async () => {\n      try {\n        if (data.value == null)\n          await storage.removeItem(key);\n        else\n          await storage.setItem(key, await serializer.write(data.value));\n      } catch (e) {\n        onError(e);\n      }\n    }, {\n      flush,\n      deep,\n      eventFilter\n    });\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.type = \"text/css\";\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(cssRef, (value) => {\n      el.textContent = value;\n    }, { immediate: true });\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(document.querySelector(selector), () => dir.value = getValue(), { attributes: true });\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  const ranges = new Array(rangeCount);\n  for (let i = 0; i < rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n    ranges[i] = range;\n  }\n  return ranges;\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  function triggerResize() {\n    var _a, _b;\n    if (!textarea.value)\n      return;\n    textarea.value.style.height = \"1px\";\n    textarea.value.style.height = `${(_a = textarea.value) == null ? void 0 : _a.scrollHeight}px`;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], triggerResize, { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, __spreadProps(__spreadValues$3({}, options), { eventFilter: filter }));\n  return __spreadValues$3({}, history);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Infinity, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nconst DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const _a = useNow({ interval: updateInterval, controls: true }), { now } = _a, controls = __objRest(_a, [\"now\"]);\n  const timeAgo = computed(() => formatTimeAgo(new Date(resolveUnref(time)), options, unref(now.value)));\n  if (exposeControls) {\n    return __spreadValues$2({\n      timeAgo\n    }, controls);\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval);\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$1({\n      timestamp: ts\n    }, controls);\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b;\n  const {\n    document = defaultDocument\n  } = options;\n  const title = resolveRef((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\n  const isReadonly = newTitle && isFunction(newTitle);\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return isFunction(template) ? template(t) : unref(template).replace(/%s/g, t);\n  }\n  watch(title, (t, o) => {\n    if (t !== o && document)\n      document.title = format(isString(t) ? t : \"\");\n  }, { immediate: true });\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver((_b = document.head) == null ? void 0 : _b.querySelector(\"title\"), () => {\n      if (document && document.title !== title.value)\n        title.value = format(document.title);\n    }, { childList: true });\n  }\n  return title;\n}\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = __spreadValues({\n  linear: identity\n}, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction useTransition(source, options = {}) {\n  const {\n    delay = 0,\n    disabled = false,\n    duration = 1e3,\n    onFinished = noop,\n    onStarted = noop,\n    transition = identity\n  } = options;\n  const currentTransition = computed(() => {\n    const t = unref(transition);\n    return isFunction(t) ? t : createEasingFunction(t);\n  });\n  const sourceValue = computed(() => {\n    const s = unref(source);\n    return isNumber(s) ? s : s.map(unref);\n  });\n  const sourceVector = computed(() => isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value);\n  const outputVector = ref(sourceVector.value.slice(0));\n  let currentDuration;\n  let diffVector;\n  let endAt;\n  let startAt;\n  let startVector;\n  const { resume, pause } = useRafFn(() => {\n    const now = Date.now();\n    const progress = clamp(1 - (endAt - now) / currentDuration, 0, 1);\n    outputVector.value = startVector.map((val, i) => {\n      var _a;\n      return val + ((_a = diffVector[i]) != null ? _a : 0) * currentTransition.value(progress);\n    });\n    if (progress >= 1) {\n      pause();\n      onFinished();\n    }\n  }, { immediate: false });\n  const start = () => {\n    pause();\n    currentDuration = unref(duration);\n    diffVector = outputVector.value.map((n, i) => {\n      var _a, _b;\n      return ((_a = sourceVector.value[i]) != null ? _a : 0) - ((_b = outputVector.value[i]) != null ? _b : 0);\n    });\n    startVector = outputVector.value.slice(0);\n    startAt = Date.now();\n    endAt = startAt + currentDuration;\n    resume();\n    onStarted();\n  };\n  const timeout = useTimeoutFn(start, delay, { immediate: false });\n  watch(sourceVector, () => {\n    if (unref(disabled))\n      return;\n    if (unref(delay) <= 0)\n      start();\n    else\n      timeout.start();\n  }, { deep: true });\n  watch(() => unref(disabled), (v) => {\n    if (v) {\n      outputVector.value = sourceVector.value.slice(0);\n      pause();\n    }\n  });\n  return computed(() => {\n    const targetVector = unref(disabled) ? sourceVector : outputVector;\n    return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;\n  });\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(state, () => {\n    const params = new URLSearchParams(\"\");\n    Object.keys(state).forEach((key) => {\n      const mapEntry = state[key];\n      if (Array.isArray(mapEntry))\n        mapEntry.forEach((value) => params.append(key, value));\n      else if (removeNullishValues && mapEntry == null)\n        params.delete(key);\n      else if (removeFalsyValues && !mapEntry)\n        params.delete(key);\n      else\n        params.set(key, mapEntry);\n    });\n    write(params);\n  }, { deep: true });\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(window.history.state, window.document.title, window.location.pathname + constructQuery(params));\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const videoDeviceId = ref(options.videoDeviceId);\n  const audioDeviceId = ref(options.audioDeviceId);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(device) {\n    if (device.value === \"none\" || device.value === false)\n      return false;\n    if (device.value == null)\n      return true;\n    return {\n      deviceId: device.value\n    };\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(videoDeviceId),\n      audio: getDeviceOptions(audioDeviceId)\n    });\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  watch([videoDeviceId, audioDeviceId], () => {\n    if (autoSwitch.value && stream.value)\n      restart();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    videoDeviceId,\n    audioDeviceId,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = eventName || event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : isFunction(clone) ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    watch(() => props[key], (v) => proxy.value = cloneFn(v));\n    watch(proxy, (v) => {\n      if (v !== props[key] || deep)\n        _emit(event, v);\n    }, { deep });\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        _emit(event, value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props)\n    ret[key] = useVModel(props, key, emit, options);\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = resolveRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(vibrate, interval, {\n      immediate: false,\n      immediateCallback: false\n    });\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResourses(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerHeight) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerHeight / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const height = itemSize(i);\n      sum += height;\n      if (sum >= containerHeight) {\n        capacity = i;\n        break;\n      }\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResourses(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResourses(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nconst useWakeLock = (options = {}) => {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n};\n\nconst useWebNotification = (defaultOptions = {}) => {\n  const {\n    window = defaultWindow\n  } = defaultOptions;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const notification = ref(null);\n  const requestPermission = async () => {\n    if (!isSupported.value)\n      return;\n    if (\"permission\" in Notification && Notification.permission !== \"denied\")\n      await Notification.requestPermission();\n  };\n  const onClick = createEventHook();\n  const onShow = createEventHook();\n  const onError = createEventHook();\n  const onClose = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value)\n      return;\n    await requestPermission();\n    const options = Object.assign({}, defaultOptions, overrides);\n    notification.value = new Notification(options.title || \"\", options);\n    notification.value.onclick = (event) => onClick.trigger(event);\n    notification.value.onshow = (event) => onShow.trigger(event);\n    notification.value.onerror = (event) => onError.trigger(event);\n    notification.value.onclose = (event) => onClose.trigger(event);\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  tryOnMounted(async () => {\n    if (isSupported.value)\n      await requestPermission();\n  });\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n};\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = resolveRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const close = (code = 1e3, reason) => {\n    if (!wsRef.value)\n      return;\n    explicitlyClosed = true;\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n  };\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed)\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      wsRef.value = void 0;\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(() => {\n      send(message, false);\n      if (pongTimeoutWait != null)\n        return;\n      pongTimeoutWait = setTimeout(() => {\n        close();\n      }, pongTimeout);\n    }, interval, { immediate: false });\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    useEventListener(window, \"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = function post2(val) {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(val);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (isString(arg0))\n      worker.value = new Worker(arg0, workerOptions);\n    else if (isFunction(arg0))\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nconst jobRunner = (userFunc) => (e) => {\n  const userFuncArgs = e.data[0];\n  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n    postMessage([\"SUCCESS\", result]);\n  }).catch((error) => {\n    postMessage([\"ERROR\", error]);\n  });\n};\n\nconst depsParser = (deps) => {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n};\n\nconst createWorkerBlobUrl = (fn, deps) => {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n};\n\nconst useWebWorkerFn = (fn, options = {}) => {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(() => workerTerminate(\"TIMEOUT_EXPIRED\"), timeout);\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\"[useWebWorkerFn] You can only run one instance of the worker at a time.\");\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n};\n\nfunction useWindowFocus({ window = defaultWindow } = {}) {\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll({ window = defaultWindow } = {}) {\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const x = ref(window.pageXOffset);\n  const y = ref(window.pageYOffset);\n  useEventListener(window, \"scroll\", () => {\n    x.value = window.pageXOffset;\n    y.value = window.pageYOffset;\n  }, {\n    capture: false,\n    passive: true\n  });\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Infinity,\n    initialHeight = Infinity,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation)\n    useEventListener(\"orientationchange\", update, { passive: true });\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, SwipeDirection, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, cloneFnJSON, computedAsync, computedInject, createFetch, createUnrefFn, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, usePermission, usePointer, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n", "<script setup>\nimport { computed, ref, provide } from 'vue'\nimport { watchDebounced } from '@vueuse/core'\nimport { nextId } from '@/utils/unique-id.js'\n\nconst props = defineProps({\n  maxlength: {\n    type: Number,\n    required: true,\n    validator(maxLength) {\n      const isValidMaxLength = maxLength > 0\n\n      if (!isValidMaxLength) {\n        console.warn(`${maxLength} is not a valid maxlength`)\n      }\n\n      return isValidMaxLength\n    },\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n})\n\nconst statusMessageRef = ref('')\nconst srOnlyStatusMessage = ref('')\n\nconst charactersRemaining = ref(props.maxlength)\nconst charactersOver = computed(() =>\n  charactersRemaining.value < 0 ? charactersRemaining.value * -1 : 0\n)\nconst countStatus = computed(() => {\n  if (charactersRemaining.value === props.maxlength) {\n    return 'equal'\n  } else if (charactersOver.value > 0) {\n    return 'over'\n  }\n\n  return 'under'\n})\n\nconst computedId = computed(() => props.id || nextId('usa-character-count'))\n\nconst messageClasses = computed(() => [\n  { 'usa-character-count__message--invalid': countStatus.value === 'over' },\n])\n\nconst updateCharacterCount = inputValue =>\n  (charactersRemaining.value = props.maxlength - `${inputValue}`.length)\n\nwatchDebounced(\n  charactersRemaining,\n  () => {\n    srOnlyStatusMessage.value = statusMessageRef.value?.textContent\n  },\n  { debounce: 1000, immediate: true }\n)\n\nprovide('updateCharacterCount', updateCharacterCount)\nprovide(\n  'characterCountMaxlength',\n  computed(() => props.maxlength)\n)\nprovide(\n  'characterCountMessageId',\n  computed(() => computedId.value)\n)\n</script>\n\n<template>\n  <div class=\"usa-character-count\">\n    <slot></slot>\n    <span :id=\"computedId\" class=\"usa-character-count__message usa-sr-only\">\n      <slot name=\"default-message\"\n        >You can enter up to {{ maxlength }} characters</slot\n      >\n    </span>\n    <div\n      ref=\"statusMessageRef\"\n      class=\"usa-character-count__status usa-hint\"\n      :class=\"messageClasses\"\n      aria-hidden=\"true\"\n    >\n      <slot\n        v-if=\"countStatus === 'equal'\"\n        name=\"equal-message\"\n        :maxlength=\"maxlength\"\n        >{{ maxlength }} character<template v-if=\"maxlength !== 1\">s</template>\n        allowed</slot\n      >\n      <slot\n        v-else-if=\"countStatus === 'under'\"\n        name=\"remaining-message\"\n        :characters-remaining=\"charactersRemaining\"\n        :maxlength=\"maxlength\"\n        >{{ charactersRemaining }} character<template\n          v-if=\"charactersRemaining !== 1\"\n          >s</template\n        >\n        left</slot\n      >\n      <slot\n        v-else-if=\"countStatus === 'over'\"\n        name=\"over-message\"\n        :characters-over=\"charactersOver\"\n        :maxlength=\"maxlength\"\n        >{{ charactersOver }} character<template v-if=\"charactersOver !== 1\"\n          >s</template\n        >\n        over limit</slot\n      >\n    </div>\n    <div\n      class=\"usa-character-count__sr-status usa-sr-only\"\n      aria-live=\"polite\"\n      >{{ srOnlyStatusMessage }}</div\n    >\n  </div>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  tile: {\n    type: Boolean,\n    default: false,\n  },\n  modelValue: {\n    type: Boolean,\n    default: false,\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  description: {\n    type: String,\n    default: '',\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        component: [],\n        label: [],\n        description: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-checkbox'))\n\nconst checkboxValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(checked) {\n    emit('update:modelValue', checked)\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-checkbox__input--tile': props.tile,\n  },\n])\n</script>\n\n<template>\n  <div class=\"usa-checkbox\" :class=\"customClasses?.component\">\n    <input\n      v-bind=\"$attrs\"\n      :id=\"computedId\"\n      v-model=\"checkboxValue\"\n      class=\"usa-checkbox__input\"\n      type=\"checkbox\"\n      :class=\"classes\"\n    />\n    <label\n      class=\"usa-checkbox__label\"\n      :class=\"customClasses?.label\"\n      :htmlFor=\"computedId\"\n      ><slot>{{ label }}</slot>\n      <span\n        v-if=\"description || $slots.description\"\n        class=\"usa-checkbox__label-description\"\n        :class=\"customClasses?.description\"\n        ><slot name=\"description\">{{ description }}</slot></span\n      >\n    </label>\n  </div>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  checked: {\n    type: Boolean,\n    default: false,\n  },\n  ariaLabel: {\n    type: String,\n    default: '',\n  },\n})\n\nconst classes = computed(() => [\n  { 'usa-checklist__item--checked': props.checked },\n])\n</script>\n\n<template>\n  <li\n    class=\"usa-checklist__item\"\n    :aria-label=\"ariaLabel\"\n    :class=\"classes\"\n    tabindex=\"0\"\n    ><slot></slot\n  ></li>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  condensed: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [\n  { 'usa-collection--condensed': props.condensed },\n])\n</script>\n\n<template>\n  <ul class=\"usa-collection\" :class=\"classes\"\n    ><slot></slot\n  ></ul>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  month: {\n    type: String,\n    required: true,\n  },\n  day: {\n    type: [String, Number],\n    required: true,\n  },\n  datetime: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        datetime: [],\n        month: [],\n        day: [],\n      }\n    },\n  },\n})\n\nconst timeElement = computed(() => (props.datetime ? 'time' : 'div'))\n</script>\n\n<template>\n  <div class=\"usa-collection__calendar-date\">\n    <component\n      :is=\"timeElement\"\n      :datetime=\"datetime || null\"\n      :class=\"customClasses?.datetime\"\n    >\n      <span\n        class=\"usa-collection__calendar-date-month\"\n        :class=\"customClasses?.month\"\n        >{{ month }}</span\n      >\n      <span\n        class=\"usa-collection__calendar-date-day\"\n        :class=\"customClasses?.day\"\n        >{{ day }}</span\n      >\n    </component>\n  </div>\n</template>\n", "import { ref, computed, readonly, watch, nextTick } from 'vue'\nimport { onKeyStroke, onClickOutside, useActiveElement } from '@vueuse/core'\nimport { nextId } from '@/utils/unique-id.js'\nimport { escapeRegExp } from '@/utils/common.js'\n\nexport default (_id, _selectedOption, _options, _disabled, _readonly, emit) => {\n  const id = ref(_id)\n  const options = ref(_options)\n  const isDisabled = ref(_disabled)\n  const isReadonly = ref(_readonly)\n  const selectedOption = computed({\n    get() {\n      return _selectedOption.value\n    },\n    set(newSelectedValue) {\n      emit('update:modelValue', newSelectedValue)\n    },\n  })\n\n  const activeElement = useActiveElement()\n  const isDirty = ref(false)\n  const searchTerm = ref('')\n  const highlightedOption = ref('')\n\n  const isOpen = ref(false)\n\n  const selectedLabel = computed(() => {\n    if (selectedOption.value === '') {\n      return ''\n    }\n\n    const foundOption = options.value.find(\n      option => option.value === selectedOption.value\n    )\n\n    return foundOption?.label || ''\n  })\n\n  watch(selectedLabel, currentLabel => {\n    if (currentLabel !== '') {\n      searchTerm.value = currentLabel\n    }\n  })\n\n  watch(searchTerm, currentTerm => {\n    if (isOpen.value && currentTerm !== '') {\n      isDirty.value = true\n    }\n  })\n\n  // Set the default value.\n  if (selectedLabel.value) {\n    searchTerm.value = selectedLabel.value\n  }\n\n  const filteredOptions = computed(() => {\n    if (\n      searchTerm.value === '' ||\n      (!isDirty.value && searchTerm.value === selectedLabel.value)\n    ) {\n      return options.value\n    }\n\n    return options.value.filter(option => {\n      const regex = new RegExp(escapeRegExp(searchTerm.value), 'gi')\n      return regex.test(option.label)\n    })\n  })\n\n  const totalFilteredOptions = computed(() => filteredOptions.value?.length)\n\n  const computedId = computed(() => id.value || nextId('usa-combo-box'))\n  const computedLabelId = computed(() => `${computedId.value}-label`)\n  const computedErrorMessageId = computed(\n    () => `${computedId.value}-error-message`\n  )\n  const computedHintId = computed(() => `${computedId.value}-hint`)\n  const computedAssistiveHintId = computed(\n    () => `${computedId.value}-assistive-hint`\n  )\n  const computedListId = computed(() => `${computedId.value}-list`)\n\n  const getListItemIdByIndex = index =>\n    `${computedListId.value}-option-${index}`\n\n  const componentElement = ref(null)\n  const inputElement = ref(null)\n  const listElement = ref(null)\n  const listItemElements = ref([])\n\n  const getItemRefById = id => {\n    return listItemElements.value.find(item => item.id === id)\n  }\n\n  const getItemRefByValue = value => {\n    return listItemElements.value.find(item => item.dataset.value === value)\n  }\n\n  const firstOptionValue = computed(() => {\n    return totalFilteredOptions.value ? filteredOptions.value[0].value : ''\n  })\n\n  const firstOptionRef = computed(() => {\n    const firstItemId = totalFilteredOptions.value\n      ? listItemElements.value[0].id\n      : null\n\n    return firstItemId ? getItemRefById(firstItemId) : null\n  })\n\n  const selectedOptionRef = computed(() => {\n    if (selectedOption.value === '') {\n      return null\n    }\n\n    const foundItemRef = listItemElements.value.find(\n      itemRef => itemRef.dataset.value === selectedOption.value\n    )\n\n    return foundItemRef ? foundItemRef : null\n  })\n\n  const highlightedOptionRef = computed(() => {\n    if (highlightedOption.value === '') {\n      return null\n    }\n\n    const foundItemRef = listItemElements.value.find(itemRef => {\n      return itemRef.dataset.value === highlightedOption.value\n    })\n\n    return foundItemRef ? foundItemRef : null\n  })\n\n  const isFirstOption = computed(() => {\n    const optionIndex = filteredOptions.value.findIndex(\n      item => item.value === highlightedOption.value\n    )\n\n    return optionIndex === 0\n  })\n\n  const isLastOption = computed(() => {\n    const optionIndex = filteredOptions.value.findIndex(\n      item => item.value === highlightedOption.value\n    )\n\n    return optionIndex === totalFilteredOptions.value - 1\n  })\n\n  const activeDescendent = computed(() => {\n    const activeOptionId = activeElement.value.id\n\n    if (activeOptionId === highlightedOptionId.value) {\n      return highlightedOptionId.value\n    }\n\n    if (\n      totalFilteredOptions.value &&\n      selectedOption.value !== '' &&\n      isOpen.value &&\n      activeOptionId === computedId.value\n    ) {\n      return highlightedOptionId.value\n    }\n\n    return null\n  })\n\n  const scrollList = elementRef => {\n    if (!elementRef || !listElement?.value) {\n      return\n    }\n\n    const optionBottom = elementRef.offsetTop + elementRef.offsetHeight\n    const currentBottom =\n      listElement.value.scrollTop + listElement.value.offsetHeight\n\n    if (optionBottom > currentBottom) {\n      listElement.value.scrollTop =\n        optionBottom - listElement.value.offsetHeight\n    }\n\n    if (elementRef.offsetTop < listElement.value.scrollTop) {\n      listElement.value.scrollTop = elementRef.offsetTop\n    }\n  }\n\n  const focusInput = () => {\n    inputElement.value.focus()\n  }\n\n  const selectOption = optionValue => {\n    selectedOption.value = optionValue\n\n    const option = options.value.find(option => option.value === optionValue)\n\n    searchTerm.value = option?.label || ''\n\n    isDirty.value = false\n  }\n\n  const clearSelectedOption = () => {\n    selectOption('')\n  }\n\n  const highlightOption = optionValue => {\n    highlightedOption.value = optionValue\n  }\n\n  const clearHighlightedOption = () => {\n    highlightedOption.value = ''\n  }\n\n  const openList = () => {\n    if (!isDisabled.value && !isReadonly.value) {\n      isOpen.value = true\n    }\n  }\n\n  const closeList = () => {\n    isOpen.value = false\n    isDirty.value = false\n    clearHighlightedOption()\n    listElement.value.scrollTop = 0\n  }\n\n  const listItemTabIndex = optionValue => {\n    return highlightedOption.value === optionValue ||\n      selectedOption.value === optionValue\n      ? 0\n      : -1\n  }\n\n  const highlightedOptionId = computed(() => {\n    if (!highlightedOption.value) {\n      return null\n    }\n\n    const highlightedOptionIndex = filteredOptions.value.findIndex(\n      option => option.value === highlightedOption.value\n    )\n\n    return getListItemIdByIndex(highlightedOptionIndex)\n  })\n\n  const clearButtonIsVisible = computed(\n    () =>\n      selectedOption.value !== '' &&\n      searchTerm.value === selectedLabel.value &&\n      !isDisabled.value &&\n      !isReadonly.value\n  )\n\n  const handleFilterOnInput = () => {\n    if (!isOpen.value) {\n      openList()\n    }\n\n    if (selectedOption.value !== '') {\n      highlightOption(selectedOption.value)\n    } else {\n      highlightOption(firstOptionValue.value)\n    }\n  }\n\n  const handleEnterOnInput = () => {\n    const foundItem = filteredOptions.value.find(\n      item => item.label === searchTerm.value\n    )\n\n    if (searchTerm.value !== '' && foundItem.value) {\n      selectOption(foundItem.value)\n    }\n\n    closeList()\n  }\n\n  const handleListToggle = () => {\n    if (isOpen.value) {\n      closeList()\n      clearHighlightedOption()\n    } else {\n      openList()\n\n      if (selectedOption.value !== '') {\n        highlightOption(selectedOption.value)\n\n        nextTick(() => {\n          scrollList(selectedOptionRef.value)\n        })\n      } else {\n        highlightOption(firstOptionValue.value)\n      }\n    }\n\n    focusInput()\n  }\n\n  const handleClearInput = () => {\n    clearSelectedOption()\n    clearHighlightedOption()\n    focusInput()\n  }\n\n  const handleHoverOnListOption = value => {\n    highlightOption(value)\n\n    if (highlightedOptionRef.value) {\n      highlightedOptionRef.value.focus({ preventScroll: true })\n    }\n  }\n\n  const handleTabOnListOption = value => {\n    selectOption(value)\n    closeList()\n    focusInput()\n  }\n\n  const handleEnterOnListOption = value => {\n    selectOption(value)\n    closeList()\n    focusInput()\n  }\n\n  const handleDownOnListOption = index => {\n    if (!isLastOption.value) {\n      highlightOption(filteredOptions.value[index + 1].value)\n\n      const itemRef = getItemRefByValue(highlightedOption.value)\n\n      scrollList(itemRef.value)\n\n      if (highlightedOptionRef.value) {\n        highlightedOptionRef.value.focus()\n      }\n    }\n  }\n\n  const handleUpOnListOption = index => {\n    if (isFirstOption.value) {\n      closeList()\n      clearHighlightedOption()\n      focusInput()\n    } else {\n      highlightOption(filteredOptions.value[index - 1].value)\n\n      const itemRef = getItemRefByValue(highlightedOption.value)\n\n      scrollList(itemRef.value)\n\n      if (highlightedOptionRef.value) {\n        highlightedOptionRef.value.focus()\n      }\n    }\n  }\n\n  const handleClickOutside = () => {\n    if (isOpen.value) {\n      selectOption(selectedOption.value)\n      closeList()\n      clearHighlightedOption()\n    }\n  }\n\n  const handleClickOnListOption = value => {\n    selectOption(value)\n    closeList()\n    focusInput()\n  }\n\n  const handleEscape = () => {\n    selectOption(selectedOption.value)\n    closeList()\n    clearHighlightedOption()\n    focusInput()\n  }\n\n  const handleDownOnInput = () => {\n    if (!isOpen.value) {\n      openList()\n    }\n\n    if (!totalFilteredOptions.value) {\n      return\n    }\n\n    if (selectedOption.value) {\n      highlightOption(selectedOption.value)\n\n      nextTick(() => {\n        selectedOptionRef.value.focus()\n\n        scrollList(selectedOptionRef.value)\n      })\n    } else {\n      highlightOption(firstOptionValue.value)\n\n      nextTick(() => {\n        highlightedOptionRef.value.focus()\n\n        scrollList(highlightedOptionRef.value)\n      })\n    }\n  }\n\n  const handleClickOnInput = () => {\n    if (!isOpen.value) {\n      openList()\n    }\n\n    if (selectedOption.value) {\n      highlightOption(selectedOption.value)\n\n      nextTick(() => {\n        scrollList(selectedOptionRef.value)\n      })\n    } else if (highlightedOption.value === '') {\n      highlightOption(firstOptionValue.value)\n\n      nextTick(() => {\n        scrollList(firstOptionRef.value)\n      })\n    }\n  }\n\n  onClickOutside(componentElement, () => handleClickOutside())\n\n  onKeyStroke('Escape', () => {\n    handleEscape()\n  })\n\n  return {\n    activeDescendent,\n    clearButtonIsVisible,\n    componentElement,\n    computedAssistiveHintId,\n    computedErrorMessageId,\n    computedHintId,\n    computedId,\n    computedLabelId,\n    computedListId,\n    filteredOptions,\n    getListItemIdByIndex,\n    handleClearInput,\n    handleClickOnInput,\n    handleClickOnListOption,\n    handleDownOnInput,\n    handleDownOnListOption,\n    handleEnterOnInput,\n    handleEnterOnListOption,\n    handleFilterOnInput,\n    handleHoverOnListOption,\n    handleListToggle,\n    handleTabOnListOption,\n    handleUpOnListOption,\n    highlightedOption: readonly(highlightedOption),\n    inputElement,\n    isDisabled: readonly(isDisabled),\n    isOpen: readonly(isOpen),\n    isReadonly: readonly(isReadonly),\n    listElement,\n    listItemElements,\n    listItemTabIndex,\n    searchTerm,\n    selectedOption,\n    totalFilteredOptions,\n  }\n}\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  group: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [{ 'usa-form-group--error': props.error }])\n</script>\n\n<template>\n  <div v-if=\"group\" v-bind=\"$attrs\" class=\"usa-form-group\" :class=\"classes\">\n    <slot></slot>\n  </div>\n  <template v-else>\n    <slot></slot>\n  </template>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  for: {\n    type: String,\n    required: true,\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [{ 'usa-label--error': props.error }])\n</script>\n\n<template>\n  <label :htmlFor=\"props.for\" class=\"usa-label\" :class=\"classes\">\n    <slot></slot>\n    <template v-if=\"required\"\n      >&nbsp;<slot name=\"required\"\n        ><abbr title=\"required\" class=\"usa-hint usa-hint--required\">*</abbr>\n      </slot>\n    </template>\n  </label>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, useSlots, toRef } from 'vue'\nimport useComboBox from '@/composables/useComboBox'\nimport UsaFormGroup from '@/components/UsaFormGroup'\nimport UsaLabel from '@/components/UsaLabel'\n\nconst slots = useSlots()\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  options: {\n    type: Array,\n    default: () => [],\n  },\n  modelValue: {\n    type: [String, Number],\n    default: '',\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  clearButtonAriaLabel: {\n    type: String,\n    default: 'Clear the select contents',\n  },\n  toggleButtonAriaLabel: {\n    type: String,\n    default: 'Toggle the dropdown list',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        formGroup: [],\n        component: [],\n        label: [],\n        input: [],\n        list: [],\n      }\n    },\n  },\n})\n\nconst {\n  activeDescendent,\n  clearButtonIsVisible,\n  componentElement,\n  computedAssistiveHintId,\n  computedErrorMessageId,\n  computedHintId,\n  computedId,\n  computedLabelId,\n  computedListId,\n  filteredOptions,\n  getListItemIdByIndex,\n  handleClearInput,\n  handleClickOnInput,\n  handleClickOnListOption,\n  handleDownOnInput,\n  handleDownOnListOption,\n  handleEnterOnInput,\n  handleEnterOnListOption,\n  handleFilterOnInput,\n  handleHoverOnListOption,\n  handleListToggle,\n  handleTabOnListOption,\n  handleUpOnListOption,\n  highlightedOption,\n  inputElement,\n  isOpen,\n  isDisabled,\n  isReadonly,\n  listElement,\n  listItemElements,\n  listItemTabIndex,\n  searchTerm,\n  selectedOption,\n  totalFilteredOptions,\n} = useComboBox(\n  toRef(props, 'id'),\n  toRef(props, 'modelValue'),\n  toRef(props, 'options'),\n  toRef(props, 'disabled'),\n  toRef(props, 'readonly'),\n  emit\n)\n\nconst ariaDescribedby = computed(() => {\n  const ids = [computedAssistiveHintId.value]\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.join(' ')\n})\n\nconst classes = computed(() => [\n  { 'usa-combo-box--pristine': selectedOption.value !== '' },\n  ...(props.customClasses?.component || []),\n])\n</script>\n\n<template>\n  <UsaFormGroup\n    :group=\"!!$slots.hint || (error && !!$slots['error-message'])\"\n    :error=\"error\"\n    :class=\"props.customClasses?.formGroup\"\n  >\n    <UsaLabel\n      v-if=\"label || $slots.label\"\n      :id=\"computedLabelId\"\n      :for=\"computedId\"\n      :required=\"required\"\n      :error=\"error\"\n      :class=\"customClasses?.label\"\n      ><slot name=\"label\">{{ label }}</slot></UsaLabel\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n\n    <div\n      ref=\"componentElement\"\n      class=\"usa-combo-box\"\n      :class=\"classes\"\n      data-enhanced=\"true\"\n    >\n      <input\n        v-bind=\"$attrs\"\n        :id=\"computedId\"\n        ref=\"inputElement\"\n        v-model=\"searchTerm\"\n        :required=\"required\"\n        :disabled=\"isDisabled\"\n        :readonly=\"isReadonly\"\n        :aria-owns=\"computedListId\"\n        :aria-controls=\"computedListId\"\n        :aria-describedby=\"ariaDescribedby\"\n        :aria-expanded=\"isOpen\"\n        :aria-activedescendant=\"activeDescendent\"\n        aria-autocomplete=\"list\"\n        autocapitalize=\"off\"\n        autocomplete=\"off\"\n        class=\"usa-combo-box__input\"\n        :class=\"props.customClasses?.input\"\n        type=\"text\"\n        role=\"combobox\"\n        @click=\"handleClickOnInput\"\n        @input=\"handleFilterOnInput\"\n        @keydown.prevent.enter=\"handleEnterOnInput\"\n        @keydown.prevent.down=\"handleDownOnInput\"\n      />\n      <span class=\"usa-combo-box__clear-input__wrapper\" tabindex=\"-1\">\n        <button\n          v-show=\"clearButtonIsVisible\"\n          type=\"button\"\n          class=\"usa-combo-box__clear-input\"\n          :aria-label=\"clearButtonAriaLabel\"\n          :disabled=\"isDisabled || isReadonly\"\n          @click=\"handleClearInput\"\n          >&nbsp;</button\n        >\n      </span>\n      <span class=\"usa-combo-box__input-button-separator\">&nbsp;</span>\n      <span class=\"usa-combo-box__toggle-list__wrapper\" tabindex=\"-1\">\n        <button\n          type=\"button\"\n          tabindex=\"-1\"\n          class=\"usa-combo-box__toggle-list\"\n          :aria-label=\"toggleButtonAriaLabel\"\n          :disabled=\"isDisabled || isReadonly\"\n          @click=\"handleListToggle\"\n          >&nbsp;</button\n        >\n      </span>\n      <ul\n        :id=\"computedListId\"\n        ref=\"listElement\"\n        tabindex=\"-1\"\n        class=\"usa-combo-box__list\"\n        :class=\"props.customClasses?.list\"\n        role=\"listbox\"\n        :aria-labelledby=\"computedLabelId\"\n        :hidden=\"!isOpen\"\n      >\n        <template v-if=\"filteredOptions.length\">\n          <li\n            v-for=\"(option, index) in filteredOptions\"\n            :id=\"getListItemIdByIndex(index)\"\n            ref=\"listItemElements\"\n            :key=\"option.value\"\n            :aria-setsize=\"totalFilteredOptions\"\n            :aria-posinset=\"index + 1\"\n            :aria-selected=\"selectedOption === option.value\"\n            class=\"usa-combo-box__list-option\"\n            :class=\"[\n              {\n                'usa-combo-box__list-option--selected':\n                  selectedOption === option.value,\n                'usa-combo-box__list-option--focused':\n                  highlightedOption === option.value,\n              },\n            ]\"\n            :tabindex=\"listItemTabIndex(option.value)\"\n            role=\"option\"\n            :data-value=\"option.value\"\n            @click=\"handleClickOnListOption(option.value)\"\n            @keydown.prevent.up=\"handleUpOnListOption(index)\"\n            @keydown.prevent.down=\"handleDownOnListOption(index)\"\n            @keydown.prevent.enter=\"handleEnterOnListOption(option.value)\"\n            @keydown.prevent.tab.exact=\"handleTabOnListOption(option.value)\"\n            @mouseover=\"handleHoverOnListOption(option.value)\"\n            >{{ option.label }}</li\n          >\n        </template>\n        <li v-else class=\"usa-combo-box__list-option--no-results\"\n          ><slot name=\"no-results\">No results found</slot></li\n        >\n      </ul>\n      <div class=\"usa-combo-box__status usa-sr-only\" role=\"status\">\n        <slot v-if=\"isOpen\" name=\"status\" :filtered-options=\"filteredOptions\">\n          <template v-if=\"filteredOptions.length\"\n            >{{ filteredOptions.length }}\n            {{ filteredOptions.length > 1 ? 'results' : 'result' }}\n            available.</template\n          >\n          <template v-else>No results.</template>\n        </slot>\n      </div>\n      <span :id=\"computedAssistiveHintId\" class=\"usa-sr-only\"\n        ><slot name=\"assistive-hint\"\n          >When autocomplete results are available use up and down arrows to\n          review and enter to select. Touch device users, explore by touch or\n          with swipe gestures.</slot\n        >\n      </span>\n    </div>\n  </UsaFormGroup>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport {\n  computed,\n  ref,\n  inject,\n  useSlots,\n  useAttrs,\n  onMounted,\n  onBeforeUnmount,\n} from 'vue'\nimport { useFocus } from '@vueuse/core'\nimport { nextId } from '@/utils/unique-id.js'\nimport UsaFormGroup from '@/components/UsaFormGroup'\nimport UsaLabel from '@/components/UsaLabel'\n\nconst inputElement = ref(null)\nconst { focused } = useFocus(inputElement)\nconst slots = useSlots()\nconst attrs = useAttrs()\n\nconst updateCharacterCount = inject('updateCharacterCount', null)\nconst characterCountMaxlength = inject('characterCountMaxlength', null)\nconst characterCountMessageId = inject('characterCountMessageId', null)\nconst registerInput = inject('registerInput', null)\nconst unregisterInput = inject('unregisterInput', null)\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'text',\n  },\n  width: {\n    type: String,\n    default: '',\n    validator(width) {\n      const isValidWidth = [\n        '',\n        '2xs',\n        'xs',\n        'sm',\n        'small',\n        'md',\n        'medium',\n        'lg',\n        'xl',\n        '2xl',\n      ].includes(width)\n\n      if (!isValidWidth) {\n        console.warn(`'${width}' is not a valid text input width`)\n      }\n\n      return isValidWidth\n    },\n  },\n  modelValue: {\n    type: [String, Number],\n    default: '',\n  },\n  group: {\n    type: Boolean,\n    default: false,\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        component: [],\n        label: [],\n        inputGroup: [],\n        inputPrefix: [],\n        inputSuffix: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-text-input'))\nconst computedErrorMessageId = computed(\n  () => `${computedId.value}-error-message`\n)\nconst computedHintId = computed(() => `${computedId.value}-hint`)\n\nconst textInputValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n\n    if (updateCharacterCount) {\n      updateCharacterCount(value)\n    }\n  },\n})\n\n// Trigger any character counts for default input values.\nonMounted(() => {\n  if (updateCharacterCount) {\n    updateCharacterCount(props.modelValue)\n  }\n\n  if (registerInput) {\n    registerInput(computedId.value)\n  }\n})\n\nonBeforeUnmount(() => {\n  if (unregisterInput) {\n    unregisterInput(computedId.value)\n  }\n})\n\nconst classes = computed(() => {\n  if (slots['input-prefix'] || slots['input-suffix']) {\n    return []\n  }\n\n  return [\n    {\n      'usa-input--error': props.error,\n      'usa-input--2xs': props.width === '2xs',\n      'usa-input--xs': props.width === 'xs',\n      'usa-input--sm': props.width === 'sm',\n      'usa-input--small': props.width === 'small',\n      'usa-input--md': props.width === 'md',\n      'usa-input--medium': props.width === 'medium',\n      'usa-input--lg': props.width === 'lg',\n      'usa-input--xl': props.width === 'xl',\n      'usa-input--2xl': props.width === '2xl',\n      'usa-character-count__field': updateCharacterCount,\n    },\n  ]\n})\n\nconst inputGroupClasses = computed(() => {\n  // istanbul ignore next\n  if (!slots['input-prefix'] && !slots['input-suffix']) {\n    return []\n  }\n\n  return [\n    {\n      'usa-input-group--error': props.error,\n      'usa-input-group--2xs': props.width === '2xs',\n      'usa-input-group--xs': props.width === 'xs',\n      'usa-input-group--sm': props.width === 'sm',\n      'usa-input-group--small': props.width === 'small',\n      'usa-input-group--md': props.width === 'md',\n      'usa-input-group--medium': props.width === 'medium',\n      'usa-input-group--lg': props.width === 'lg',\n      'usa-input-group--xl': props.width === 'xl',\n      'usa-input-group--2xl': props.width === '2xl',\n      'is-focused': focused.value === true,\n    },\n    ...(props.customClasses?.inputGroup || []),\n  ]\n})\n\nconst ariaDescribedby = computed(() => {\n  const ids = []\n\n  if (attrs['aria-describedby']) {\n    ids.push(attrs['aria-describedby'])\n  }\n\n  if (characterCountMessageId) {\n    ids.push(characterCountMessageId.value)\n  }\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.length ? ids.join(' ') : null\n})\n\nconst groupElements = computed(\n  () => props.group || !!slots.hint || (props.error && !!slots['error-message'])\n)\n</script>\n\n<template>\n  <UsaFormGroup\n    :group=\"groupElements\"\n    :error=\"error\"\n    :class=\"customClasses?.component\"\n  >\n    <UsaLabel\n      v-if=\"label || $slots.label\"\n      :for=\"computedId\"\n      :required=\"required\"\n      :error=\"error\"\n      :class=\"customClasses?.label\"\n      ><slot name=\"label\">{{ label }}</slot></UsaLabel\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n\n    <div\n      v-if=\"$slots['input-prefix'] || $slots['input-suffix']\"\n      class=\"usa-input-group\"\n      :class=\"inputGroupClasses\"\n    >\n      <div\n        v-if=\"$slots['input-prefix']\"\n        class=\"usa-input-prefix\"\n        :class=\"customClasses?.inputPrefix\"\n        aria-hidden=\"true\"\n        @click=\"inputElement.focus()\"\n        ><slot name=\"input-prefix\"></slot\n      ></div>\n      <input\n        v-bind=\"$attrs\"\n        :id=\"computedId\"\n        ref=\"inputElement\"\n        v-model=\"textInputValue\"\n        :type=\"type\"\n        class=\"usa-input\"\n        :class=\"classes\"\n        :required=\"required\"\n        :maxlength=\"characterCountMaxlength || $attrs.maxlength\"\n        :aria-describedby=\"ariaDescribedby\"\n      />\n      <div\n        v-if=\"$slots['input-suffix']\"\n        class=\"usa-input-suffix\"\n        :class=\"customClasses?.inputSuffix\"\n        aria-hidden=\"true\"\n        @click=\"inputElement.focus()\"\n        ><slot name=\"input-suffix\"></slot\n      ></div>\n    </div>\n    <input\n      v-else\n      v-bind=\"$attrs\"\n      :id=\"computedId\"\n      ref=\"inputElement\"\n      v-model=\"textInputValue\"\n      :type=\"type\"\n      class=\"usa-input\"\n      :class=\"classes\"\n      :required=\"required\"\n      :maxlength=\"characterCountMaxlength || $attrs.maxlength\"\n      :aria-describedby=\"ariaDescribedby\"\n    />\n  </UsaFormGroup>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, useSlots, useAttrs } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport UsaFormGroup from '@/components/UsaFormGroup'\nimport UsaLabel from '@/components/UsaLabel'\n\nconst slots = useSlots()\nconst attrs = useAttrs()\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  options: {\n    type: Array,\n    default: () => [],\n  },\n  emptyLabel: {\n    type: String,\n    default: '- Select -',\n  },\n  modelValue: {\n    type: [String, Number],\n    default: '',\n  },\n  group: {\n    type: Boolean,\n    default: false,\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        component: [],\n        label: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-dropdown'))\nconst computedErrorMessageId = computed(\n  () => `${computedId.value}-error-message`\n)\nconst computedHintId = computed(() => `${computedId.value}-hint`)\n\nconst selectedValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  },\n})\n\nconst classes = computed(() => [{ 'usa-input--error': props.error }])\n\nconst ariaDescribedby = computed(() => {\n  const ids = []\n\n  if (attrs['aria-describedby']) {\n    ids.push(attrs['aria-describedby'])\n  }\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.length ? ids.join(' ') : null\n})\n\nconst groupElements = computed(\n  () => props.group || !!slots.hint || (props.error && !!slots['error-message'])\n)\n</script>\n\n<template>\n  <UsaFormGroup\n    :group=\"groupElements\"\n    :error=\"error\"\n    :class=\"props.customClasses?.component\"\n  >\n    <UsaLabel\n      v-if=\"label || $slots.label\"\n      :for=\"computedId\"\n      :required=\"required\"\n      :error=\"error\"\n      :class=\"customClasses?.label\"\n      ><slot name=\"label\">{{ label }}</slot></UsaLabel\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n\n    <select\n      v-bind=\"$attrs\"\n      :id=\"computedId\"\n      v-model=\"selectedValue\"\n      class=\"usa-select\"\n      :class=\"classes\"\n      :required=\"required\"\n      :aria-describedby=\"ariaDescribedby\"\n    >\n      <option v-if=\"options.length\" value=\"\">{{ emptyLabel }}</option>\n      <slot :options=\"options\">\n        <template v-for=\"option in options\" :key=\"option.value || option.group\">\n          <option\n            v-if=\"!option.group\"\n            :value=\"option.value\"\n            :disabled=\"option.disabled\"\n            >{{ option.text || option.value }}</option\n          >\n          <optgroup\n            v-else-if=\"option.group && option.options.length\"\n            :label=\"option.group\"\n            :disabled=\"option.disabled\"\n          >\n            <option\n              v-for=\"groupedOption in option.options\"\n              :key=\"groupedOption.value\"\n              :value=\"groupedOption.value\"\n              :disabled=\"groupedOption.disabled\"\n              >{{ groupedOption.text || groupedOption.value }}</option\n            >\n          </optgroup>\n        </template>\n      </slot>\n    </select>\n  </UsaFormGroup>\n</template>\n", "<script setup>\nimport { computed, useSlots } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport UsaTextInput from '@/components/UsaTextInput'\nimport UsaSelect from '@/components/UsaSelect'\n\nconst slots = useSlots()\nconst emit = defineEmits(['update:month', 'update:day', 'update:year'])\n\nconst props = defineProps({\n  label: {\n    type: String,\n    default: '',\n  },\n  day: {\n    type: [String, Number],\n    default: '',\n  },\n  month: {\n    type: [String, Number],\n    default: '',\n  },\n  year: {\n    type: [String, Number],\n    default: '',\n  },\n  dateOrder: {\n    type: Array,\n    default: () => ['month', 'day', 'year'],\n  },\n  dateLabels: {\n    type: Object,\n    default: () => ({ month: 'Month', day: 'Day', year: 'Year' }),\n  },\n  /**\n   * @deprecated\n   */\n  monthAsSelect: {\n    type: Boolean,\n    default: false,\n  },\n  monthEmptyLabel: {\n    type: String,\n    default: undefined,\n  },\n  monthOptions: {\n    type: Array,\n    default: () => [\n      {\n        value: 1,\n        text: '01 - January',\n      },\n      {\n        value: 2,\n        text: '02 - February',\n      },\n      {\n        value: 3,\n        text: '03 - March',\n      },\n      {\n        value: 4,\n        text: '04 - April',\n      },\n      {\n        value: 5,\n        text: '05 - May',\n      },\n      {\n        value: 6,\n        text: '06 - June',\n      },\n      {\n        value: 7,\n        text: '07 - July',\n      },\n      {\n        value: 8,\n        text: '08 - August',\n      },\n      {\n        value: 9,\n        text: '09 - September',\n      },\n      {\n        value: 10,\n        text: '10 - October',\n      },\n      {\n        value: 11,\n        text: '11 - November',\n      },\n      {\n        value: 12,\n        text: '12 - December',\n      },\n    ],\n  },\n  name: {\n    type: String,\n    default: 'date',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n})\n\nif (!props.monthAsSelect) {\n  console.warn(\n    `The 'monthAsSelect' prop is deprecated. Starting with vue-uswds 2.0 the month will always use a select form element. You can set the 'monthAsSelect' prop value to true to minimize changes.`\n  )\n}\n\nconst computedId = computed(() => props.id || nextId('usa-date-input'))\nconst computedErrorMessageId = computed(\n  () => `${computedId.value}-error-message`\n)\nconst computedHintId = computed(() => `${computedId.value}-hint`)\n\nconst monthValue = computed({\n  get: () => props.month,\n  set: month => emit('update:month', month),\n})\nconst dayValue = computed({\n  get: () => props.day,\n  set: day => emit('update:day', day),\n})\nconst yearValue = computed({\n  get: () => props.year,\n  set: year => emit('update:year', year),\n})\n\nconst ariaDescribedby = computed(() => {\n  const ids = []\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.length ? ids.join(' ') : null\n})\n</script>\n\n<template>\n  <fieldset class=\"usa-fieldset\">\n    <legend v-if=\"label || $slots.label\" class=\"usa-legend\"\n      ><slot name=\"label\">{{ label }}</slot></legend\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n\n    <div class=\"usa-memorable-date\">\n      <template v-for=\"date in dateOrder\" :key=\"date\">\n        <template v-if=\"date === 'month'\">\n          <UsaSelect\n            v-if=\"monthAsSelect\"\n            :id=\"`${computedId}-${name}-month`\"\n            v-model=\"monthValue\"\n            :options=\"monthOptions\"\n            :empty-label=\"monthEmptyLabel\"\n            :label=\"dateLabels[date]\"\n            :group=\"true\"\n            :name=\"`${name}_month`\"\n            :required=\"required\"\n            :aria-describedby=\"ariaDescribedby\"\n            :custom-classes=\"{ component: ['usa-form-group--month'] }\"\n          ></UsaSelect>\n          <UsaTextInput\n            v-else\n            :id=\"`${computedId}-${name}-month`\"\n            v-model=\"monthValue\"\n            :label=\"dateLabels[date]\"\n            :group=\"true\"\n            :name=\"`${name}_month`\"\n            :maxlength=\"2\"\n            :required=\"required\"\n            pattern=\"[0-9]*\"\n            inputmode=\"numeric\"\n            :aria-describedby=\"ariaDescribedby\"\n            :custom-classes=\"{ component: ['usa-form-group--month'] }\"\n          ></UsaTextInput>\n        </template>\n        <UsaTextInput\n          v-else-if=\"date === 'day'\"\n          :id=\"`${computedId}-${name}-day`\"\n          v-model=\"dayValue\"\n          :label=\"dateLabels[date]\"\n          :group=\"true\"\n          :name=\"`${name}_day`\"\n          :maxlength=\"2\"\n          :required=\"required\"\n          pattern=\"[0-9]*\"\n          inputmode=\"numeric\"\n          :aria-describedby=\"ariaDescribedby\"\n          :custom-classes=\"{ component: ['usa-form-group--day'] }\"\n        ></UsaTextInput>\n        <UsaTextInput\n          v-else-if=\"date === 'year'\"\n          :id=\"`${computedId}-${name}-year`\"\n          v-model=\"yearValue\"\n          :label=\"dateLabels[date]\"\n          :group=\"true\"\n          :name=\"`${name}_year`\"\n          :minlength=\"4\"\n          :maxlength=\"4\"\n          :required=\"required\"\n          pattern=\"[0-9]*\"\n          inputmode=\"numeric\"\n          :aria-describedby=\"ariaDescribedby\"\n          :custom-classes=\"{ component: ['usa-form-group--year'] }\"\n        ></UsaTextInput>\n      </template>\n    </div>\n  </fieldset>\n</template>\n", "import {\n  USA_DATE_REGEX_PATTERN,\n  ISO_DATE_REGEX_PATTERN,\n} from '@/utils/constants.js'\n\nexport const validateTimeString = time => {\n  let isValidTimeString = false\n\n  const [hours, minutes] = time.split(':').map(segment => parseInt(segment, 10))\n\n  if (\n    !Number.isNaN(hours) &&\n    !Number.isNaN(minutes) &&\n    hours >= 0 &&\n    hours < 24 &&\n    minutes >= 0 &&\n    minutes < 60\n  ) {\n    isValidTimeString = true\n  }\n\n  return isValidTimeString\n}\n\nexport const formatYearString = year => `${year}`.padStart(4, '0')\nexport const formatMonthString = month => `${month}`.padStart(2, '0')\nexport const formatDayString = day => `${day}`.padStart(2, '0')\n\nexport const getMonthIndex = dateObject => dateObject.getMonth()\nexport const getMonth = dateObject => getMonthIndex(dateObject) + 1\nexport const getYear = dateObject => dateObject.getFullYear()\nexport const getDay = dateObject => dateObject.getDate()\n\n/**\n * Parses a ISO-8601 formatted string into a native Date object.\n *\n * @param {string} dateIsoString\n * A ISO-8601 formatted string representing a date.\n * @returns {object}\n */\nexport const parseIsoDate = dateString => {\n  const [year, month, day] = dateString.split('-')\n\n  const newDate = new Date(\n    parseInt(year, 10),\n    parseInt(month, 10) - 1,\n    parseInt(day, 10),\n    0,\n    0,\n    0,\n    0\n  ).setFullYear(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10))\n\n  return new Date(newDate)\n}\n\nexport const today = () => {\n  const now = new Date()\n  return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0)\n}\n\nexport const parseUsaDate = date => {\n  const [month, day, year] = date.split('/')\n\n  const newDate = new Date(\n    parseInt(year, 10),\n    parseInt(month, 10) - 1,\n    parseInt(day, 10),\n    0,\n    0,\n    0,\n    0\n  ).setFullYear(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10))\n\n  return new Date(newDate)\n}\n\nexport const formatIsoDate = dateObject => {\n  const year = formatYearString(getYear(dateObject))\n  const month = formatMonthString(getMonth(dateObject))\n  const day = formatDayString(getDay(dateObject))\n\n  return `${year}-${month}-${day}`\n}\n\nexport const formatUsaDate = dateObject => {\n  const year = formatYearString(getYear(dateObject))\n  const month = formatMonthString(getMonth(dateObject))\n  const day = formatDayString(getDay(dateObject))\n\n  return `${month}/${day}/${year}`\n}\n\nexport const UsaToIsoString = usaDateString => {\n  const [month, day, year] = usaDateString.split('/')\n  return `${year}-${month}-${day}`\n}\n\nexport const isDateBefore = (date, dateToCompare) =>\n  date.getTime() < dateToCompare.getTime()\n\nexport const isDateAfter = (date, dateToCompare) =>\n  date.getTime() > dateToCompare.getTime()\n\nexport const isDateInRange = (date, minDate, maxDate) =>\n  !isDateBefore(date, minDate) && !isDateAfter(date, maxDate)\n\nexport const setYear = (dateObject, newYear) => {\n  const year = formatYearString(newYear)\n  const month = formatMonthString(getMonth(dateObject))\n  const day = formatDayString(getDay(dateObject))\n  const newDateString = `${year}-${month}-${day}`\n\n  return parseIsoDate(newDateString)\n}\nexport const setMonth = (dateObject, newMonth) => {\n  const year = formatYearString(getYear(dateObject))\n  const month = formatMonthString(newMonth)\n  const day = formatDayString(getDay(dateObject))\n  const newDateString = `${year}-${month}-${day}`\n\n  return parseIsoDate(newDateString)\n}\n\nexport const isValidDate = dateObject => {\n  return !Number.isNaN(dateObject?.getTime())\n}\n\nexport const isValidIsoDate = isoDateString =>\n  ISO_DATE_REGEX_PATTERN.test(isoDateString)\n\nexport const isValidUsaDate = usaDateString =>\n  USA_DATE_REGEX_PATTERN.test(usaDateString)\n\nexport const minDate = dates => {\n  const timestamps = dates.map(date => date.getTime())\n  const min = Math.min(...timestamps)\n\n  return new Date(min)\n}\n\nexport const maxDate = dates => {\n  const timestamps = dates.map(date => date.getTime())\n  const max = Math.max(...timestamps)\n\n  return new Date(max)\n}\n\nexport const startOfYear = dateObject => {\n  const year = getYear(dateObject)\n\n  const date = new Date(formatIsoDate(dateObject))\n  date.setFullYear(year, 0, 1)\n  date.setHours(0, 0, 0, 0)\n\n  return date\n}\n\nexport const endOfYear = dateObject => {\n  const year = getYear(dateObject)\n\n  const date = new Date(formatIsoDate(dateObject))\n  date.setFullYear(year + 1, 0, 0)\n  date.setHours(23, 59, 59, 999)\n\n  return date\n}\n", "/*!\n* tabbable 6.0.1\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRootHost;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  var nodeRootHost = getRootNode(node).host;\n  var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));\n  while (!attached && nodeRootHost) {\n    var _nodeRootHost2;\n    // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n    //  which means we need to get the host's host and check if that parent host is contained\n    //  in (i.e. attached to) the document\n    nodeRootHost = getRootNode(nodeRootHost).host;\n    attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n", "/*!\n* focus-trap 7.2.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, isFocusable } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) ||\n      // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return isTabbable(n, config.tabbableOptions);\n            });\n          }\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return isTabbable(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === doc.activeElement) {\n      return;\n    }\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var target = getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  var checkKey = function checkKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n      return;\n    }\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      if (onActivate) {\n        onActivate();\n      }\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      if (onDeactivate) {\n        onDeactivate();\n      }\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n", "import { unrefElement, tryOnScopeDispose } from '@vueuse/core';\nimport { ref, watch } from 'vue-demi';\nimport { createFocusTrap } from 'focus-trap';\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useFocusTrap(target, options = {}) {\n  let trap;\n  const _a = options, { immediate } = _a, focusTrapOptions = __objRest(_a, [\"immediate\"]);\n  const hasFocus = ref(false);\n  const isPaused = ref(false);\n  const activate = (opts) => trap && trap.activate(opts);\n  const deactivate = (opts) => trap && trap.deactivate(opts);\n  const pause = () => {\n    if (trap) {\n      trap.pause();\n      isPaused.value = true;\n    }\n  };\n  const unpause = () => {\n    if (trap) {\n      trap.unpause();\n      isPaused.value = false;\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    if (!el)\n      return;\n    trap = createFocusTrap(el, __spreadProps(__spreadValues({}, focusTrapOptions), {\n      onActivate() {\n        hasFocus.value = true;\n        if (options.onActivate)\n          options.onActivate();\n      },\n      onDeactivate() {\n        hasFocus.value = false;\n        if (options.onDeactivate)\n          options.onDeactivate();\n      }\n    }));\n    if (immediate)\n      activate();\n  }, { flush: \"post\" });\n  tryOnScopeDispose(() => deactivate());\n  return {\n    hasFocus,\n    isPaused,\n    activate,\n    deactivate,\n    pause,\n    unpause\n  };\n}\n\nexport { useFocusTrap };\n", "export default function toInteger(dirtyNumber) {\n  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {\n    return NaN;\n  }\n\n  var number = Number(dirtyNumber);\n\n  if (isNaN(number)) {\n    return number;\n  }\n\n  return number < 0 ? Math.ceil(number) : Math.floor(number);\n}", "export default function requiredArgs(required, args) {\n  if (args.length < required) {\n    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');\n  }\n}", "function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @param {Date|Number} argument - the value to convert\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\n\nexport default function toDate(argument) {\n  requiredArgs(1, arguments);\n  var argStr = Object.prototype.toString.call(argument); // Clone the date\n\n  if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime());\n  } else if (typeof argument === 'number' || argStr === '[object Number]') {\n    return new Date(argument);\n  } else {\n    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {\n      // eslint-disable-next-line no-console\n      console.warn(\"Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments\"); // eslint-disable-next-line no-console\n\n      console.warn(new Error().stack);\n    }\n\n    return new Date(NaN);\n  }\n}", "import toInteger from \"../_lib/toInteger/index.js\";\nimport toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name addDays\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} - the new date with the days added\n * @throws {TypeError} - 2 arguments required\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * const result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\n\nexport default function addDays(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var amount = toInteger(dirtyAmount);\n\n  if (isNaN(amount)) {\n    return new Date(NaN);\n  }\n\n  if (!amount) {\n    // If 0 days, no-op to avoid changing times in the hour before end of DST\n    return date;\n  }\n\n  date.setDate(date.getDate() + amount);\n  return date;\n}", "import toInteger from \"../_lib/toInteger/index.js\";\nimport toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name addMonths\n * @category Month Helpers\n * @summary Add the specified number of months to the given date.\n *\n * @description\n * Add the specified number of months to the given date.\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the months added\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Add 5 months to 1 September 2014:\n * const result = addMonths(new Date(2014, 8, 1), 5)\n * //=> Sun Feb 01 2015 00:00:00\n */\n\nexport default function addMonths(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var amount = toInteger(dirtyAmount);\n\n  if (isNaN(amount)) {\n    return new Date(NaN);\n  }\n\n  if (!amount) {\n    // If 0 months, no-op to avoid changing times in the hour before end of DST\n    return date;\n  }\n\n  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for\n  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and\n  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we\n  // want except that dates will wrap around the end of a month, meaning that\n  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So\n  // we'll default to the end of the desired month by adding 1 to the desired\n  // month and using a date of 0 to back up one day to the end of the desired\n  // month.\n\n  var endOfDesiredMonth = new Date(date.getTime());\n  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);\n  var daysInMonth = endOfDesiredMonth.getDate();\n\n  if (dayOfMonth >= daysInMonth) {\n    // If we're already at the end of the month, then this is the correct date\n    // and we're done.\n    return endOfDesiredMonth;\n  } else {\n    // Otherwise, we now know that setting the original day-of-month value won't\n    // cause an overflow, so set the desired day-of-month. Note that we can't\n    // just set the date of `endOfDesiredMonth` because that object may have had\n    // its time changed in the unusual case where where a DST transition was on\n    // the last day of the month and its local time was in the hour skipped or\n    // repeated next to a DST transition.  So we use `date` instead which is\n    // guaranteed to still have the original time.\n    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);\n    return date;\n  }\n}", "var defaultOptions = {};\nexport function getDefaultOptions() {\n  return defaultOptions;\n}\nexport function setDefaultOptions(newOptions) {\n  defaultOptions = newOptions;\n}", "import toDate from \"../toDate/index.js\";\nimport toInteger from \"../_lib/toInteger/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\nimport { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n/**\n * @name startOfWeek\n * @category Week Helpers\n * @summary Return the start of a week for the given date.\n *\n * @description\n * Return the start of a week for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|Number} date - the original date\n * @param {Object} [options] - an object with options.\n * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}\n * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)\n * @returns {Date} the start of a week\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6\n *\n * @example\n * // The start of a week for 2 September 2014 11:55:00:\n * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Sun Aug 31 2014 00:00:00\n *\n * @example\n * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:\n * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })\n * //=> Mon Sep 01 2014 00:00:00\n */\n\nexport default function startOfWeek(dirtyDate, options) {\n  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;\n\n  requiredArgs(1, arguments);\n  var defaultOptions = getDefaultOptions();\n  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN\n\n  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {\n    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');\n  }\n\n  var date = toDate(dirtyDate);\n  var day = date.getDay();\n  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n  date.setDate(date.getDate() - diff);\n  date.setHours(0, 0, 0, 0);\n  return date;\n}", "/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nexport default function getTimezoneOffsetInMilliseconds(date) {\n  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n  utcDate.setUTCFullYear(date.getFullYear());\n  return date.getTime() - utcDate.getTime();\n}", "import toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name startOfDay\n * @category Day Helpers\n * @summary Return the start of a day for the given date.\n *\n * @description\n * Return the start of a day for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|Number} date - the original date\n * @returns {Date} the start of a day\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // The start of a day for 2 September 2014 11:55:00:\n * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 02 2014 00:00:00\n */\n\nexport default function startOfDay(dirtyDate) {\n  requiredArgs(1, arguments);\n  var date = toDate(dirtyDate);\n  date.setHours(0, 0, 0, 0);\n  return date;\n}", "import getTimezoneOffsetInMilliseconds from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\nimport startOfDay from \"../startOfDay/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\nvar MILLISECONDS_IN_DAY = 86400000;\n/**\n * @name differenceInCalendarDays\n * @category Day Helpers\n * @summary Get the number of calendar days between the given dates.\n *\n * @description\n * Get the number of calendar days between the given dates. This means that the times are removed\n * from the dates and then the difference in days is calculated.\n *\n * @param {Date|Number} dateLeft - the later date\n * @param {Date|Number} dateRight - the earlier date\n * @returns {Number} the number of calendar days\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // How many calendar days are between\n * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?\n * const result = differenceInCalendarDays(\n *   new Date(2012, 6, 2, 0, 0),\n *   new Date(2011, 6, 2, 23, 0)\n * )\n * //=> 366\n * // How many calendar days are between\n * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?\n * const result = differenceInCalendarDays(\n *   new Date(2011, 6, 3, 0, 1),\n *   new Date(2011, 6, 2, 23, 59)\n * )\n * //=> 1\n */\n\nexport default function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {\n  requiredArgs(2, arguments);\n  var startOfDayLeft = startOfDay(dirtyDateLeft);\n  var startOfDayRight = startOfDay(dirtyDateRight);\n  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);\n  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer\n  // because the number of milliseconds in a day is not constant\n  // (e.g. it's different in the day of the daylight saving time clock shift)\n\n  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);\n}", "import toInteger from \"../_lib/toInteger/index.js\";\nimport addMonths from \"../addMonths/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name addYears\n * @category Year Helpers\n * @summary Add the specified number of years to the given date.\n *\n * @description\n * Add the specified number of years to the given date.\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the years added\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Add 5 years to 1 September 2014:\n * const result = addYears(new Date(2014, 8, 1), 5)\n * //=> Sun Sep 01 2019 00:00:00\n */\n\nexport default function addYears(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var amount = toInteger(dirtyAmount);\n  return addMonths(dirtyDate, amount * 12);\n}", "import startOfDay from \"../startOfDay/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name isSameDay\n * @category Day Helpers\n * @summary Are the given dates in the same day (and year and month)?\n *\n * @description\n * Are the given dates in the same day (and year and month)?\n *\n * @param {Date|Number} dateLeft - the first date to check\n * @param {Date|Number} dateRight - the second date to check\n * @returns {Boolean} the dates are in the same day (and year and month)\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?\n * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))\n * //=> true\n *\n * @example\n * // Are 4 September and 4 October in the same day?\n * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))\n * //=> false\n *\n * @example\n * // Are 4 September, 2014 and 4 September, 2015 in the same day?\n * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))\n * //=> false\n */\n\nexport default function isSameDay(dirtyDateLeft, dirtyDateRight) {\n  requiredArgs(2, arguments);\n  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);\n  var dateRightStartOfDay = startOfDay(dirtyDateRight);\n  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();\n}", "import toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name endOfMonth\n * @category Month Helpers\n * @summary Return the end of a month for the given date.\n *\n * @description\n * Return the end of a month for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|Number} date - the original date\n * @returns {Date} the end of a month\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // The end of a month for 2 September 2014 11:55:00:\n * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 30 2014 23:59:59.999\n */\n\nexport default function endOfMonth(dirtyDate) {\n  requiredArgs(1, arguments);\n  var date = toDate(dirtyDate);\n  var month = date.getMonth();\n  date.setFullYear(date.getFullYear(), month + 1, 0);\n  date.setHours(23, 59, 59, 999);\n  return date;\n}", "import toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name startOfMonth\n * @category Month Helpers\n * @summary Return the start of a month for the given date.\n *\n * @description\n * Return the start of a month for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|Number} date - the original date\n * @returns {Date} the start of a month\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // The start of a month for 2 September 2014 11:55:00:\n * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Mon Sep 01 2014 00:00:00\n */\n\nexport default function startOfMonth(dirtyDate) {\n  requiredArgs(1, arguments);\n  var date = toDate(dirtyDate);\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n  return date;\n}", "import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\nimport toDate from \"../toDate/index.js\";\nimport toInteger from \"../_lib/toInteger/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n\n/**\n * @name endOfWeek\n * @category Week Helpers\n * @summary Return the end of a week for the given date.\n *\n * @description\n * Return the end of a week for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|Number} date - the original date\n * @param {Object} [options] - an object with options.\n * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}\n * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)\n * @returns {Date} the end of a week\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6\n *\n * @example\n * // The end of a week for 2 September 2014 11:55:00:\n * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Sat Sep 06 2014 23:59:59.999\n *\n * @example\n * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:\n * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })\n * //=> Sun Sep 07 2014 23:59:59.999\n */\nexport default function endOfWeek(dirtyDate, options) {\n  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;\n\n  requiredArgs(1, arguments);\n  var defaultOptions = getDefaultOptions();\n  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN\n\n  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {\n    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');\n  }\n\n  var date = toDate(dirtyDate);\n  var day = date.getDay();\n  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);\n  date.setDate(date.getDate() + diff);\n  date.setHours(23, 59, 59, 999);\n  return date;\n}", "import toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name isAfter\n * @category Common Helpers\n * @summary Is the first date after the second one?\n *\n * @description\n * Is the first date after the second one?\n *\n * @param {Date|Number} date - the date that should be after the other one to return true\n * @param {Date|Number} dateToCompare - the date to compare with\n * @returns {Boolean} the first date is after the second date\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Is 10 July 1989 after 11 February 1987?\n * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> true\n */\n\nexport default function isAfter(dirtyDate, dirtyDateToCompare) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var dateToCompare = toDate(dirtyDateToCompare);\n  return date.getTime() > dateToCompare.getTime();\n}", "import toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name isBefore\n * @category Common Helpers\n * @summary Is the first date before the second one?\n *\n * @description\n * Is the first date before the second one?\n *\n * @param {Date|Number} date - the date that should be before the other one to return true\n * @param {Date|Number} dateToCompare - the date to compare with\n * @returns {Boolean} the first date is before the second date\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Is 10 July 1989 before 11 February 1987?\n * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> false\n */\n\nexport default function isBefore(dirtyDate, dirtyDateToCompare) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var dateToCompare = toDate(dirtyDateToCompare);\n  return date.getTime() < dateToCompare.getTime();\n}", "import toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name isSameMonth\n * @category Month Helpers\n * @summary Are the given dates in the same month (and year)?\n *\n * @description\n * Are the given dates in the same month (and year)?\n *\n * @param {Date|Number} dateLeft - the first date to check\n * @param {Date|Number} dateRight - the second date to check\n * @returns {Boolean} the dates are in the same month (and year)\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Are 2 September 2014 and 25 September 2014 in the same month?\n * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))\n * //=> true\n *\n * @example\n * // Are 2 September 2014 and 25 September 2015 in the same month?\n * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))\n * //=> false\n */\n\nexport default function isSameMonth(dirtyDateLeft, dirtyDateRight) {\n  requiredArgs(2, arguments);\n  var dateLeft = toDate(dirtyDateLeft);\n  var dateRight = toDate(dirtyDateRight);\n  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();\n}", "import addDays from \"../addDays/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\nimport toInteger from \"../_lib/toInteger/index.js\";\n/**\n * @name subDays\n * @category Day Helpers\n * @summary Subtract the specified number of days from the given date.\n *\n * @description\n * Subtract the specified number of days from the given date.\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the days subtracted\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Subtract 10 days from 1 September 2014:\n * const result = subDays(new Date(2014, 8, 1), 10)\n * //=> Fri Aug 22 2014 00:00:00\n */\n\nexport default function subDays(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var amount = toInteger(dirtyAmount);\n  return addDays(dirtyDate, -amount);\n}", "import toInteger from \"../_lib/toInteger/index.js\";\nimport toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name setDate\n * @category Day Helpers\n * @summary Set the day of the month to the given date.\n *\n * @description\n * Set the day of the month to the given date.\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} dayOfMonth - the day of the month of the new date\n * @returns {Date} the new date with the day of the month set\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Set the 30th day of the month to 1 September 2014:\n * const result = setDate(new Date(2014, 8, 1), 30)\n * //=> Tue Sep 30 2014 00:00:00\n */\n\nexport default function setDate(dirtyDate, dirtyDayOfMonth) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var dayOfMonth = toInteger(dirtyDayOfMonth);\n  date.setDate(dayOfMonth);\n  return date;\n}", "import toInteger from \"../_lib/toInteger/index.js\";\nimport addMonths from \"../addMonths/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name subMonths\n * @category Month Helpers\n * @summary Subtract the specified number of months from the given date.\n *\n * @description\n * Subtract the specified number of months from the given date.\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the months subtracted\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Subtract 5 months from 1 February 2015:\n * const result = subMonths(new Date(2015, 1, 1), 5)\n * //=> Mon Sep 01 2014 00:00:00\n */\n\nexport default function subMonths(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var amount = toInteger(dirtyAmount);\n  return addMonths(dirtyDate, -amount);\n}", "import toInteger from \"../_lib/toInteger/index.js\";\nimport addYears from \"../addYears/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name subYears\n * @category Year Helpers\n * @summary Subtract the specified number of years from the given date.\n *\n * @description\n * Subtract the specified number of years from the given date.\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of years to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the years subtracted\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Subtract 5 years from 1 September 2014:\n * const result = subYears(new Date(2014, 8, 1), 5)\n * //=> Tue Sep 01 2009 00:00:00\n */\n\nexport default function subYears(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var amount = toInteger(dirtyAmount);\n  return addYears(dirtyDate, -amount);\n}", "import { computed, shallowRef, watch } from 'vue'\nimport {\n  isBefore,\n  isAfter,\n  isSameMonth,\n  isSameDay,\n  startOfMonth,\n  startOfWeek,\n  startOfDay,\n  endOfMonth,\n  endOfWeek,\n  addDays,\n  subDays,\n  addMonths,\n  subMonths,\n  addYears,\n  subYears,\n  setDate,\n  differenceInCalendarDays,\n} from 'date-fns'\nimport { splitArray } from '@/utils/common.js'\nimport {\n  today,\n  formatIsoDate,\n  parseIsoDate,\n  isValidDate,\n} from '@/utils/dates.js'\n\nexport const useDayPicker = ({\n  activeDate,\n  minDate,\n  maxDate,\n  dayOfWeekLabels,\n  monthLabels,\n  isDateRange,\n  dateRangeStart,\n  dateRangeEnd,\n}) => {\n  const minDateObject = shallowRef(parseIsoDate(minDate.value))\n  watch(minDate, newMinDate => (minDateObject.value = parseIsoDate(newMinDate)))\n\n  const maxDateObject = shallowRef(parseIsoDate(maxDate.value))\n  watch(maxDate, newMaxDate => (maxDateObject.value = parseIsoDate(newMaxDate)))\n\n  const activeDateObject = shallowRef(parseIsoDate(activeDate.value))\n\n  watch(\n    activeDate,\n    newActiveDate => (activeDateObject.value = parseIsoDate(newActiveDate))\n  )\n\n  const activeDateStart = computed(() =>\n    startOfWeek(startOfMonth(activeDateObject.value))\n  )\n  const activeDateEnd = computed(() =>\n    endOfWeek(endOfMonth(activeDateObject.value))\n  )\n\n  const activeMonthIndex = computed(() => activeDateObject.value.getMonth())\n\n  const isPreviousMonth = (currentMonth, monthToCompare) => {\n    if (currentMonth === 0) {\n      return monthToCompare === 11\n    }\n\n    return currentMonth + 1 === monthToCompare\n  }\n\n  const isCurrentMonth = (currentMonth, monthToCompare) =>\n    currentMonth === monthToCompare\n\n  const isNextMonth = (currentMonth, monthToCompare) => {\n    if (currentMonth === 11) {\n      return monthToCompare === 0\n    }\n\n    return currentMonth - 1 === monthToCompare\n  }\n\n  const isDateInRange = date => {\n    return (\n      !isBefore(date, parseIsoDate(minDate.value)) &&\n      !isAfter(date, parseIsoDate(maxDate.value))\n    )\n  }\n\n  const isDateInCurrentRange = date => {\n    return (\n      isDateRange.value &&\n      dateRangeStart.value &&\n      dateRangeEnd.value &&\n      isDateInRange(date) &&\n      !isBefore(subDays(date, 1), parseIsoDate(dateRangeStart.value)) &&\n      !isAfter(addDays(date, 1), parseIsoDate(dateRangeEnd.value))\n    )\n  }\n\n  const formatAriaLabelDate = date => {\n    const year = `${date.getFullYear()}`.padStart(4, '0')\n    const day = date.getDate()\n    const dayOfWeekIndex = date.getDay()\n    const dayOfWeekLabel = dayOfWeekLabels.value[dayOfWeekIndex]\n    const monthIndex = date.getMonth()\n    const monthLabel = monthLabels.value[monthIndex]\n\n    return `${day} ${monthLabel} ${year} ${dayOfWeekLabel}`\n  }\n\n  const findClosestPastDate = (start, stop) => {\n    let index = start\n\n    while (!isAfter(index, stop)) {\n      if (isDateInRange(index)) {\n        return formatIsoDate(index)\n      }\n\n      index = addDays(index, 1)\n    }\n\n    return formatIsoDate(start)\n  }\n\n  const findClosestFutureDate = (start, stop) => {\n    let index = start\n\n    while (!isBefore(startOfDay(index), stop)) {\n      if (isDateInRange(index)) {\n        return formatIsoDate(index)\n      }\n\n      index = subDays(index, 1)\n    }\n\n    return formatIsoDate(start)\n  }\n\n  const findPreviousMonth = currentDateObject => {\n    return isDateInRange(subMonths(currentDateObject, 1), currentDateObject)\n      ? formatIsoDate(subMonths(currentDateObject, 1))\n      : findClosestPastDate(subMonths(currentDateObject, 1), currentDateObject)\n  }\n\n  const findNextMonth = currentDateObject => {\n    return isDateInRange(addMonths(currentDateObject, 1), currentDateObject)\n      ? formatIsoDate(addMonths(currentDateObject, 1))\n      : findClosestFutureDate(\n          addMonths(currentDateObject, 1),\n          currentDateObject\n        )\n  }\n\n  const findPreviousYear = currentDateObject => {\n    const currentDay = currentDateObject.getDate()\n    const previousYearDateObject = subYears(currentDateObject, 1)\n\n    if (isDateInRange(previousYearDateObject)) {\n      return formatIsoDate(previousYearDateObject)\n    }\n    const nextAvailableDate = parseIsoDate(\n      findClosestPastDate(previousYearDateObject, currentDateObject)\n    )\n\n    const nextDateOnSameDay = setDate(nextAvailableDate, currentDay)\n\n    if (\n      !isValidDate(nextDateOnSameDay) ||\n      !isDateInRange(nextDateOnSameDay) ||\n      isSameDay(currentDateObject, nextDateOnSameDay)\n    ) {\n      return formatIsoDate(nextAvailableDate)\n    }\n\n    return formatIsoDate(nextDateOnSameDay)\n  }\n\n  const findNextYear = currentDateObject => {\n    const currentDay = currentDateObject.getDate()\n    const nextYearDateObject = addYears(currentDateObject, 1)\n\n    if (isDateInRange(nextYearDateObject)) {\n      return formatIsoDate(nextYearDateObject)\n    }\n\n    const nextAvailableDate = parseIsoDate(\n      findClosestFutureDate(nextYearDateObject, currentDateObject)\n    )\n\n    const nextDateOnSameDay = setDate(nextAvailableDate, currentDay)\n\n    if (\n      !isValidDate(nextDateOnSameDay) ||\n      !isDateInRange(nextDateOnSameDay) ||\n      isSameDay(currentDateObject, nextDateOnSameDay)\n    ) {\n      return formatIsoDate(nextAvailableDate)\n    }\n\n    return formatIsoDate(nextDateOnSameDay)\n  }\n\n  const hasPastYear = computed(\n    () => !isSameMonth(activeDateObject.value, minDateObject.value)\n  )\n  const hasFutureYear = computed(\n    () => !isSameMonth(activeDateObject.value, maxDateObject.value)\n  )\n  const hasPastMonth = computed(\n    () => !isSameMonth(activeDateObject.value, minDateObject.value)\n  )\n  const hasFutureMonth = computed(\n    () => !isSameMonth(activeDateObject.value, maxDateObject.value)\n  )\n\n  const todaysDate = formatIsoDate(today())\n\n  const visibleDateRange = computed(() => {\n    const dates = []\n    const totalDays = differenceInCalendarDays(\n      activeDateEnd.value,\n      activeDateStart.value\n    )\n\n    let index = 0\n\n    while (index <= totalDays) {\n      const currentDate = addDays(activeDateStart.value, index)\n\n      const monthIndex = currentDate.getMonth()\n      const month = monthIndex + 1\n\n      dates.push({\n        date: formatIsoDate(currentDate),\n        label: formatAriaLabelDate(currentDate),\n        day: currentDate.getDate(),\n        month: month,\n        year: currentDate.getFullYear(),\n        isPreviousMonth: isPreviousMonth(monthIndex, activeMonthIndex.value),\n        isCurrentMonth: isCurrentMonth(monthIndex, activeMonthIndex.value),\n        isNextMonth: isNextMonth(monthIndex, activeMonthIndex.value),\n        isInCurrentRange: isDateInCurrentRange(currentDate),\n        previousMonth: findPreviousMonth(currentDate),\n        nextMonth: findNextMonth(currentDate),\n        previousYear: findPreviousYear(currentDate),\n        nextYear: findNextYear(currentDate),\n        disabled: !isDateInRange(currentDate),\n        left: isDateInRange(subDays(currentDate, 1))\n          ? formatIsoDate(subDays(currentDate, 1))\n          : null,\n        right: isDateInRange(addDays(currentDate, 1))\n          ? formatIsoDate(addDays(currentDate, 1))\n          : null,\n        up: isDateInRange(subDays(currentDate, 7))\n          ? formatIsoDate(subDays(currentDate, 7))\n          : findClosestPastDate(parseIsoDate(minDate.value), currentDate),\n        down: isDateInRange(addDays(currentDate, 7))\n          ? formatIsoDate(addDays(currentDate, 7))\n          : findClosestFutureDate(parseIsoDate(maxDate.value), currentDate),\n        home: findClosestPastDate(startOfWeek(currentDate), currentDate),\n        end: findClosestFutureDate(endOfWeek(currentDate), currentDate),\n        pageUp: findPreviousMonth(currentDate),\n        pageDown: findNextMonth(currentDate),\n        shiftPageUp: findPreviousYear(currentDate),\n        shiftPageDown: findNextYear(currentDate),\n      })\n\n      index += 1\n    }\n\n    return dates\n  })\n\n  const groupedVisibleDateRange = computed(() =>\n    splitArray(visibleDateRange.value, 7)\n  )\n\n  const dates = computed(() => {\n    return groupedVisibleDateRange.value.map(row => {\n      return row.map((item, index) => {\n        return {\n          ...item,\n          id: `${item.date}-${index}`,\n        }\n      })\n    })\n  })\n\n  return {\n    dates,\n    todaysDate,\n    hasPastYear,\n    hasFutureYear,\n    hasPastMonth,\n    hasFutureMonth,\n  }\n}\n", "<script setup>\nimport {\n  computed,\n  ref,\n  toRef,\n  watch,\n  nextTick,\n  toRaw,\n  onBeforeUnmount,\n  shallowRef,\n  onMounted,\n  inject,\n} from 'vue'\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport { isSameMonth, addMonths, subMonths, addYears, subYears } from 'date-fns'\nimport {\n  getMonthIndex,\n  getYear,\n  formatIsoDate,\n  isDateInRange,\n  parseIsoDate,\n} from '@/utils/dates.js'\nimport { useDayPicker } from './useDayPicker.js'\n\nconst inputHighlightedDate = inject('inputHighlightedDate')\nconst isDateRange = inject('isDateRange', false)\nconst dateRangeStart = inject('dateRangeStart', '')\nconst dateRangeEnd = inject('dateRangeEnd', '')\nconst rangeType = inject('rangeType', '')\n\nconst emit = defineEmits([\n  'update:open',\n  'update:selectedDate',\n  'update:activeDate',\n  'update:selectorMode',\n  'update:highlightedDate',\n  'update:isPristine',\n])\n\nconst props = defineProps({\n  selectedDate: {\n    type: String,\n    default: '',\n  },\n  activeDate: {\n    type: String,\n    required: true,\n  },\n  minDate: {\n    type: String,\n    required: true,\n  },\n  maxDate: {\n    type: String,\n    required: true,\n  },\n  monthLabels: {\n    type: Array,\n    required: true,\n  },\n  dayOfWeekLabels: {\n    type: Array,\n    required: true,\n  },\n  dayOfWeekAbbreviationLabels: {\n    type: Array,\n    required: true,\n  },\n  previousYearButtonLabel: {\n    type: String,\n    required: true,\n  },\n  nextYearButtonLabel: {\n    type: String,\n    required: true,\n  },\n  previousMonthButtonLabel: {\n    type: String,\n    required: true,\n  },\n  nextMonthButtonLabel: {\n    type: String,\n    required: true,\n  },\n  monthSelectionButtonLabel: {\n    type: String,\n    required: true,\n  },\n  yearSelectionButtonLabel: {\n    type: String,\n    required: true,\n  },\n  previousYearsButtonLabel: {\n    type: String,\n    required: true,\n  },\n  nextYearsButtonLabel: {\n    type: String,\n    required: true,\n  },\n})\n\nconst dayDatePickerRef = ref(null)\nconst dateButtonRefs = ref([])\n\nconst { activate, deactivate } = useFocusTrap(dayDatePickerRef, {\n  immediate: true,\n  clickOutsideDeactivates: true,\n  initialFocus: '.usa-date-picker__calendar__date--focused',\n  fallbackFocus: '.usa-date-picker__calendar__date-picker',\n})\n\nconst selectedDate = computed({\n  get() {\n    return props.selectedDate\n  },\n  set(newSelectedDate) {\n    emit('update:selectedDate', newSelectedDate)\n  },\n})\n\nconst activeDate = computed({\n  get() {\n    return props.activeDate\n  },\n  set(newActiveDate) {\n    emit('update:activeDate', newActiveDate)\n  },\n})\n\nconst activeDateObject = shallowRef(parseIsoDate(activeDate.value))\n\nwatch(activeDate, newActiveDate => {\n  activeDateObject.value = parseIsoDate(newActiveDate)\n})\n\nconst activeMonthIndex = computed(() => getMonthIndex(activeDateObject.value))\nconst activeMonthLabel = computed(\n  () => props.monthLabels[activeMonthIndex.value]\n)\nconst activeYear = computed(() => getYear(activeDateObject.value))\n\nconst {\n  dates,\n  hasPastMonth,\n  hasFutureMonth,\n  hasPastYear,\n  hasFutureYear,\n  todaysDate,\n} = useDayPicker({\n  activeDate: activeDate,\n  minDate: toRef(props, 'minDate'),\n  maxDate: toRef(props, 'maxDate'),\n  dayOfWeekLabels: toRef(props, 'dayOfWeekLabels'),\n  monthLabels: toRef(props, 'monthLabels'),\n  isDateRange: isDateRange,\n  dateRangeStart: dateRangeStart,\n  dateRangeEnd: dateRangeEnd,\n})\n\nconst highlightedDate = ref(activeDate.value)\nconst highlightedRowIndex = ref(null)\nconst highlightedButtonIndex = ref(null)\n\nwatch(selectedDate, newSelectedDate => {\n  if (newSelectedDate) {\n    highlightedDate.value = newSelectedDate\n    activeDate.value = newSelectedDate\n  }\n})\n\nconst monthSelectionButtonLabel = computed(() => {\n  return props.monthSelectionButtonLabel.replace('%s', activeMonthLabel.value)\n})\n\nconst yearSelectionButtonLabel = computed(() => {\n  return props.yearSelectionButtonLabel.replace('%s', activeYear.value)\n})\n\nconst visibleDateRange = computed(() => toRaw(dates.value).flat())\n\nconst tabIndex = (date, rowIndex, buttonIndex) => {\n  if (\n    date === highlightedDate.value ||\n    date === selectedDate.value ||\n    (highlightedRowIndex.value === rowIndex &&\n      highlightedButtonIndex.value === buttonIndex)\n  ) {\n    return 0\n  }\n\n  return -1\n}\n\nconst getButtonByDate = date =>\n  dateButtonRefs.value.find(button => button.dataset.value === date)\n\nconst setButtonFocusByDate = date => {\n  const foundButton = getButtonByDate(date)\n\n  if (foundButton) {\n    foundButton.focus()\n  }\n}\n\nconst toPreviousMonth = () => {\n  const previousMonth = isDateInRange(\n    subMonths(activeDateObject.value, 1),\n    parseIsoDate(props.minDate),\n    parseIsoDate(props.maxDate)\n  )\n    ? subMonths(activeDateObject.value, 1)\n    : parseIsoDate(props.minDate)\n\n  activeDate.value = formatIsoDate(previousMonth)\n}\n\nconst toNextMonth = () => {\n  const nextMonth = isDateInRange(\n    addMonths(activeDateObject.value, 1),\n    parseIsoDate(props.minDate),\n    parseIsoDate(props.maxDate)\n  )\n    ? addMonths(activeDateObject.value, 1)\n    : parseIsoDate(props.maxDate)\n\n  activeDate.value = formatIsoDate(nextMonth)\n}\n\nconst toPreviousYear = () => {\n  const previousYear = isDateInRange(\n    subYears(activeDateObject.value, 1),\n    parseIsoDate(props.minDate),\n    parseIsoDate(props.maxDate)\n  )\n    ? subYears(activeDateObject.value, 1)\n    : parseIsoDate(props.minDate)\n\n  activeDate.value = formatIsoDate(previousYear)\n}\n\nconst toNextYear = () => {\n  const nextYear = isDateInRange(\n    addYears(activeDateObject.value, 1),\n    parseIsoDate(props.minDate),\n    parseIsoDate(props.maxDate)\n  )\n    ? addYears(activeDateObject.value, 1)\n    : parseIsoDate(props.maxDate)\n\n  activeDate.value = formatIsoDate(nextYear)\n}\n\nconst handlePreviousMonth = () => {\n  const newDate =\n    dates.value[highlightedRowIndex.value][highlightedButtonIndex.value]\n      .previousMonth\n\n  toPreviousMonth()\n\n  highlightedDate.value = newDate\n}\n\nconst handleNextMonth = () => {\n  const newDate =\n    dates.value[highlightedRowIndex.value][highlightedButtonIndex.value]\n      .nextMonth\n\n  toNextMonth()\n\n  highlightedDate.value = newDate\n}\n\nconst handlePreviousYear = () => {\n  const previousYear =\n    dates.value[highlightedRowIndex.value][highlightedButtonIndex.value]\n      .previousYear\n  toPreviousYear()\n\n  highlightedDate.value = previousYear\n\n  nextTick(() => {\n    if (\n      isSameMonth(\n        parseIsoDate(highlightedDate.value),\n        parseIsoDate(props.minDate)\n      )\n    ) {\n      setButtonFocusByDate(highlightedDate.value)\n    }\n  })\n}\n\nconst handleNextYear = () => {\n  const nextYear =\n    dates.value[highlightedRowIndex.value][highlightedButtonIndex.value]\n      .nextYear\n\n  toNextYear()\n\n  highlightedDate.value = nextYear\n\n  nextTick(() => {\n    if (\n      isSameMonth(\n        parseIsoDate(highlightedDate.value),\n        parseIsoDate(props.maxDate)\n      )\n    ) {\n      setButtonFocusByDate(highlightedDate.value)\n    }\n  })\n}\n\nconst handleClickOnDate = date => {\n  selectedDate.value = date\n  highlightedDate.value = date\n  emit('update:open', false)\n}\n\nconst handleHoverOnDate = date => {\n  highlightedDate.value = date\n\n  const foundDate = visibleDateRange.value.find(item => item.date === date)\n\n  nextTick(() => {\n    if (foundDate.isCurrentMonth) {\n      setButtonFocusByDate(highlightedDate.value)\n    }\n  })\n}\n\nconst handlePreviousDate = (date, to = null) => {\n  if (!date) {\n    return\n  }\n\n  const foundDate = visibleDateRange.value.find(item => item.date === date)\n\n  if (!foundDate || !foundDate.isCurrentMonth) {\n    if (!to || to === 'month') {\n      toPreviousMonth()\n    } else if (to === 'year') {\n      toPreviousYear()\n    }\n  }\n\n  highlightedDate.value = date\n\n  nextTick(() => {\n    setButtonFocusByDate(date)\n  })\n}\n\nconst handleNextDate = (date, to = null) => {\n  if (!date) {\n    return\n  }\n\n  const foundDate = visibleDateRange.value.find(item => item.date === date)\n  if (!foundDate || !foundDate.isCurrentMonth) {\n    if (!to || to === 'month') {\n      toNextMonth()\n    } else if (to === 'year') {\n      toNextYear()\n    }\n  }\n\n  highlightedDate.value = date\n\n  nextTick(() => {\n    setButtonFocusByDate(date)\n  })\n}\n\nwatch(\n  highlightedDate,\n  newHighlightedDate => {\n    emit('update:highlightedDate', newHighlightedDate)\n\n    nextTick(() => {\n      if (\n        visibleDateRange.value.some(\n          item => item.date === newHighlightedDate && item.isCurrentMonth\n        ) &&\n        isDateInRange(\n          parseIsoDate(newHighlightedDate),\n          parseIsoDate(props.minDate),\n          parseIsoDate(props.maxDate)\n        )\n      ) {\n        const newRowIndex = dates.value.findIndex(row =>\n          row.find(({ date }) => date === newHighlightedDate)\n        )\n\n        const newButtonIndex = dates.value[newRowIndex].findIndex(\n          ({ date }) => date === newHighlightedDate\n        )\n\n        highlightedRowIndex.value = newRowIndex\n        highlightedButtonIndex.value = newButtonIndex\n      }\n    })\n  },\n  { immediate: true }\n)\n\nwatch(inputHighlightedDate, newHighlightedDate => {\n  highlightedDate.value = newHighlightedDate\n})\n\nconst stopWatchingHighlightedDate = watch(highlightedDate, () => {\n  emit('update:isPristine', false)\n  stopWatchingHighlightedDate()\n})\n\nonMounted(() => {\n  activate()\n})\n\nonBeforeUnmount(() => {\n  emit('update:isPristine', true)\n  deactivate()\n})\n</script>\n\n<template>\n  <div\n    ref=\"dayDatePickerRef\"\n    tabindex=\"-1\"\n    class=\"usa-date-picker__calendar__date-picker\"\n  >\n    <div class=\"usa-date-picker__calendar__row\">\n      <div\n        class=\"usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items\"\n      >\n        <button\n          type=\"button\"\n          class=\"usa-date-picker__calendar__previous-year\"\n          :aria-label=\"previousYearButtonLabel\"\n          :disabled=\"!hasPastYear\"\n          @click=\"handlePreviousYear\"\n        ></button>\n      </div>\n      <div\n        class=\"usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items\"\n      >\n        <button\n          type=\"button\"\n          class=\"usa-date-picker__calendar__previous-month\"\n          :aria-label=\"previousMonthButtonLabel\"\n          :disabled=\"!hasPastMonth\"\n          @click=\"handlePreviousMonth\"\n        ></button>\n      </div>\n      <div\n        class=\"usa-date-picker__calendar__cell usa-date-picker__calendar__month-label\"\n      >\n        <button\n          type=\"button\"\n          class=\"usa-date-picker__calendar__month-selection\"\n          :aria-label=\"monthSelectionButtonLabel\"\n          @click=\"emit('update:selectorMode', 'month')\"\n          >{{ activeMonthLabel }}</button\n        >\n        <button\n          type=\"button\"\n          class=\"usa-date-picker__calendar__year-selection\"\n          :aria-label=\"yearSelectionButtonLabel\"\n          @click=\"emit('update:selectorMode', 'year')\"\n          >{{ activeYear }}</button\n        >\n      </div>\n      <div\n        class=\"usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items\"\n      >\n        <button\n          type=\"button\"\n          class=\"usa-date-picker__calendar__next-month\"\n          :aria-label=\"nextMonthButtonLabel\"\n          :disabled=\"!hasFutureMonth\"\n          @click=\"handleNextMonth\"\n        ></button>\n      </div>\n      <div\n        class=\"usa-date-picker__calendar__cell usa-date-picker__calendar__cell--center-items\"\n      >\n        <button\n          type=\"button\"\n          class=\"usa-date-picker__calendar__next-year\"\n          :aria-label=\"nextYearButtonLabel\"\n          :disabled=\"!hasFutureYear\"\n          @click=\"handleNextYear\"\n        ></button>\n      </div>\n    </div>\n\n    <table class=\"usa-date-picker__calendar__table\" role=\"presentation\">\n      <thead>\n        <tr>\n          <th\n            v-for=\"(dayLabel, index) in dayOfWeekLabels\"\n            :key=\"dayLabel\"\n            class=\"usa-date-picker__calendar__day-of-week\"\n            scope=\"presentation\"\n            :aria-label=\"dayLabel\"\n            >{{ dayOfWeekAbbreviationLabels[index] }}\n          </th>\n        </tr>\n      </thead>\n\n      <tbody>\n        <tr\n          v-for=\"(row, rowIndex) in dates\"\n          :key=\"`${rowIndex}-${row.map(({ date }) => date).join('-')}`\"\n        >\n          <td v-for=\"(item, buttonIndex) in row\" :key=\"item.id\">\n            <button\n              ref=\"dateButtonRefs\"\n              type=\"button\"\n              :disabled=\"item.disabled\"\n              :tabindex=\"tabIndex(item.date, rowIndex, buttonIndex)\"\n              class=\"usa-date-picker__calendar__date\"\n              :class=\"{\n                'usa-date-picker__calendar__date--previous-month':\n                  item.isPreviousMonth,\n                'usa-date-picker__calendar__date--current-month':\n                  item.isCurrentMonth,\n                'usa-date-picker__calendar__date--next-month': item.isNextMonth,\n                'usa-date-picker__calendar__date--today':\n                  item.date === todaysDate,\n                'usa-date-picker__calendar__date--selected':\n                  selectedDate === item.date,\n                'usa-date-picker__calendar__date--focused':\n                  highlightedRowIndex === rowIndex &&\n                  highlightedButtonIndex === buttonIndex &&\n                  item.isCurrentMonth,\n                'usa-date-picker__calendar__date--range-date':\n                  (isDateRange &&\n                    dateRangeEnd &&\n                    rangeType === 'start' &&\n                    item.date === dateRangeEnd) ||\n                  (isDateRange &&\n                    dateRangeStart &&\n                    rangeType === 'end' &&\n                    item.date === dateRangeStart),\n                'usa-date-picker__calendar__date--within-range':\n                  (isDateRange &&\n                    dateRangeStart &&\n                    dateRangeEnd &&\n                    item.isInCurrentRange) ||\n                  (isDateRange &&\n                    dateRangeStart &&\n                    !dateRangeEnd &&\n                    item.date > dateRangeStart &&\n                    item.date < highlightedDate) ||\n                  (isDateRange &&\n                    dateRangeEnd &&\n                    !dateRangeStart &&\n                    item.date < dateRangeEnd &&\n                    item.date > highlightedDate),\n                'usa-date-picker__calendar__date--range-date-start':\n                  (isDateRange &&\n                    dateRangeStart &&\n                    item.date === dateRangeStart) ||\n                  (isDateRange &&\n                    dateRangeEnd &&\n                    item.date !== dateRangeEnd &&\n                    rangeType === 'start' &&\n                    !dateRangeStart &&\n                    highlightedRowIndex === rowIndex &&\n                    highlightedButtonIndex === buttonIndex &&\n                    item.isCurrentMonth),\n                'usa-date-picker__calendar__date--range-date-end':\n                  (isDateRange && dateRangeEnd && item.date === dateRangeEnd) ||\n                  (isDateRange &&\n                    dateRangeStart &&\n                    item.date !== dateRangeStart &&\n                    rangeType === 'end' &&\n                    !dateRangeEnd &&\n                    highlightedRowIndex === rowIndex &&\n                    highlightedButtonIndex === buttonIndex &&\n                    item.isCurrentMonth),\n              }\"\n              :data-day=\"item.day\"\n              :data-month=\"item.month\"\n              :data-year=\"item.year\"\n              :data-value=\"item.date\"\n              :aria-label=\"item.label\"\n              :aria-selected=\"selectedDate === item.date\"\n              @click=\"handleClickOnDate(item.date)\"\n              @mouseover=\"handleHoverOnDate(item.date)\"\n              @keydown.prevent.up=\"handlePreviousDate(item.up)\"\n              @keydown.prevent.down=\"handleNextDate(item.down)\"\n              @keydown.prevent.left=\"handlePreviousDate(item.left)\"\n              @keydown.prevent.right=\"handleNextDate(item.right)\"\n              @keydown.prevent.home=\"handlePreviousDate(item.home)\"\n              @keydown.prevent.end=\"handleNextDate(item.end)\"\n              @keydown.prevent.page-up.exact=\"\n                handlePreviousDate(item.pageUp, 'month')\n              \"\n              @keydown.prevent.page-down.exact=\"\n                handleNextDate(item.pageDown, 'month')\n              \"\n              @keydown.prevent.shift.page-up=\"\n                handlePreviousDate(item.shiftPageUp, 'year')\n              \"\n              @keydown.prevent.shift.page-down=\"\n                handleNextDate(item.shiftPageDown, 'year')\n              \"\n              >{{ item.day }}</button\n            >\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n", "import { computed, shallowRef, watch } from 'vue'\nimport { splitArray } from '@/utils/common.js'\nimport {\n  minDate as min,\n  maxDate as max,\n  parseIsoDate,\n  startOfYear,\n  endOfYear,\n} from '@/utils/dates.js'\n\nexport const useMonthPicker = ({\n  activeYear,\n  monthLabels,\n  minDate,\n  maxDate,\n}) => {\n  const minDateObject = shallowRef(parseIsoDate(minDate.value))\n  const maxDateObject = shallowRef(parseIsoDate(maxDate.value))\n\n  watch(minDate, newMinDate => (minDateObject.value = parseIsoDate(newMinDate)))\n  watch(maxDate, newMaxDate => (maxDateObject.value = parseIsoDate(newMaxDate)))\n\n  const minMonthOfActiveYear = computed(() => {\n    const activeDateObject = parseIsoDate(`${activeYear.value}-01-01`)\n\n    const startOfActiveYear = startOfYear(activeDateObject)\n\n    const minDateOfActiveYear = max([startOfActiveYear, minDateObject.value])\n\n    return minDateOfActiveYear.getMonth()\n  })\n\n  const maxMonthOfActiveYear = computed(() => {\n    const activeDateObject = parseIsoDate(`${activeYear.value}-01-01`)\n\n    const startOfActiveYear = startOfYear(activeDateObject)\n\n    const endOfActiveYear = endOfYear(startOfActiveYear)\n\n    const maxDateOfActiveYear = min([endOfActiveYear, maxDateObject.value])\n\n    return maxDateOfActiveYear.getMonth()\n  })\n\n  const validMonthRangeOfActiveYear = computed(() => {\n    const validMonthRange = []\n\n    for (\n      let i = minMonthOfActiveYear.value;\n      i <= maxMonthOfActiveYear.value;\n      i++\n    ) {\n      validMonthRange.push(i + 1)\n    }\n\n    return validMonthRange\n  })\n\n  const isMonthInRange = month =>\n    validMonthRangeOfActiveYear.value.includes(month)\n\n  const findClosestPastMonth = (start, stop) => {\n    for (let index = start; index <= stop; index++) {\n      if (isMonthInRange(index)) {\n        return index\n      }\n    }\n    return null\n  }\n\n  const findClosestFutureMonth = (start, stop) => {\n    for (let index = start; index >= stop; index--) {\n      if (isMonthInRange(index)) {\n        return index\n      }\n    }\n    return null\n  }\n\n  const monthsOfYear = computed(() =>\n    Object.keys(monthLabels.value).map(index => parseInt(index, 10) + 1)\n  )\n\n  const groupedMonthRange = computed(() => splitArray(monthsOfYear.value, 3))\n\n  const months = computed(() =>\n    groupedMonthRange.value.map(row =>\n      row.map((monthValue, index) => {\n        return {\n          month: monthValue,\n          label: monthLabels.value[monthValue - 1],\n          id: `${monthValue}-${index}`,\n          disabled: !isMonthInRange(monthValue),\n          left: isMonthInRange(monthValue - 1) ? monthValue - 1 : null,\n          right: isMonthInRange(monthValue + 1) ? monthValue + 1 : null,\n          up: isMonthInRange(monthValue - 3)\n            ? monthValue - 3\n            : isMonthInRange(monthValue - 1)\n            ? monthValue - 1\n            : null,\n          down: isMonthInRange(monthValue + 3)\n            ? monthValue + 3\n            : isMonthInRange(monthValue + 1)\n            ? monthValue + 1\n            : null,\n          home: row.find(monthValue => isMonthInRange(monthValue)) || null,\n          end:\n            [...row].reverse().find(monthValue => isMonthInRange(monthValue)) ||\n            null,\n          pageUp: findClosestPastMonth(1, monthValue),\n          pageDown: findClosestFutureMonth(12, monthValue),\n        }\n      })\n    )\n  )\n\n  const findRowIndexByMonth = (months, monthToFind) => {\n    const rowIndex = months.value.findIndex(row =>\n      row.find(({ month }) => month === monthToFind)\n    )\n\n    return rowIndex\n  }\n\n  const findButtonIndexByMonth = (months, rowIndex, monthToFind) => {\n    const buttonIndex = months.value[rowIndex].findIndex(\n      ({ month }) => month === monthToFind\n    )\n\n    return buttonIndex\n  }\n\n  return {\n    months,\n    findRowIndexByMonth,\n    findButtonIndexByMonth,\n  }\n}\n", "<script setup>\nimport {\n  ref,\n  computed,\n  watch,\n  onMounted,\n  onBeforeUnmount,\n  toRef,\n  shallowRef,\n} from 'vue'\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport { getMonth, getYear, parseIsoDate } from '@/utils/dates.js'\nimport { useMonthPicker } from './useMonthPicker.js'\n\nconst emit = defineEmits(['update:activeMonth', 'update:selectorMode'])\n\nconst props = defineProps({\n  activeDate: {\n    type: String,\n    required: true,\n  },\n  monthLabels: {\n    type: Array,\n    required: true,\n  },\n  minDate: {\n    type: String,\n    required: true,\n  },\n  maxDate: {\n    type: String,\n    required: true,\n  },\n})\n\nconst monthDatePickerRef = ref(null)\nconst monthButtonRefs = ref([])\n\nconst { activate, deactivate } = useFocusTrap(monthDatePickerRef, {\n  immediate: true,\n  clickOutsideDeactivates: true,\n  initialFocus: '.usa-date-picker__calendar__month--focused',\n  fallbackFocus: '.usa-date-picker__calendar__date-picker',\n})\n\nconst activeDateObject = shallowRef(parseIsoDate(props.activeDate))\n\nwatch(\n  toRef(props, 'activeDate'),\n  newActiveDate => (activeDateObject.value = parseIsoDate(newActiveDate))\n)\n\nconst activeMonth = computed(() => getMonth(activeDateObject.value))\nconst activeYear = computed(() => getYear(activeDateObject.value))\n\nconst { months, findRowIndexByMonth, findButtonIndexByMonth } = useMonthPicker({\n  activeYear,\n  monthLabels: toRef(props, 'monthLabels'),\n  minDate: toRef(props, 'minDate'),\n  maxDate: toRef(props, 'maxDate'),\n})\n\nconst highlightedMonth = ref(activeMonth.value)\nconst highlightedRowIndex = ref(null)\nconst highlightedButtonIndex = ref(null)\n\nconst tabIndex = (month, rowIndex, buttonIndex) => {\n  if (\n    month === highlightedMonth.value ||\n    month === activeMonth.value ||\n    (highlightedRowIndex.value === rowIndex &&\n      highlightedButtonIndex.value === buttonIndex)\n  ) {\n    return 0\n  }\n\n  return -1\n}\n\nconst getButtonByMonth = month =>\n  monthButtonRefs.value.find(\n    button => parseInt(button.dataset.value, 10) === month\n  )\n\nconst setButtonFocusByMonth = month => {\n  const foundButton = getButtonByMonth(month)\n\n  if (foundButton) {\n    foundButton.focus()\n  }\n}\n\nconst handleClickOnMonth = month => {\n  emit('update:activeMonth', month)\n  emit('update:selectorMode', 'day')\n}\n\nconst handleHoverOnMonth = month => {\n  highlightedMonth.value = month\n  setButtonFocusByMonth(highlightedMonth.value)\n}\n\nconst handlePreviousMonth = month => {\n  if (!month) {\n    return\n  }\n\n  highlightedMonth.value = month\n  setButtonFocusByMonth(month)\n}\n\nconst handleNextMonth = month => {\n  if (!month) {\n    return\n  }\n\n  highlightedMonth.value = month\n  setButtonFocusByMonth(month)\n}\n\nwatch(\n  highlightedMonth,\n  newHighlightedMonth => {\n    const newRowIndex = findRowIndexByMonth(months, newHighlightedMonth)\n\n    const newButtonIndex = findButtonIndexByMonth(\n      months,\n      newRowIndex,\n      newHighlightedMonth\n    )\n\n    highlightedRowIndex.value = newRowIndex\n    highlightedButtonIndex.value = newButtonIndex\n  },\n  { immediate: true }\n)\n\nonMounted(() => {\n  activate()\n})\n\nonBeforeUnmount(() => {\n  deactivate()\n})\n</script>\n\n<template>\n  <div\n    ref=\"monthDatePickerRef\"\n    tabindex=\"-1\"\n    class=\"usa-date-picker__calendar__month-picker\"\n  >\n    <table class=\"usa-date-picker__calendar__table\" role=\"presentation\">\n      <tbody>\n        <tr\n          v-for=\"(row, rowIndex) in months\"\n          :key=\"`${rowIndex}-${row.map(({ month }) => month).join('-')}`\"\n        >\n          <td v-for=\"(item, buttonIndex) in row\" :key=\"item.id\">\n            <button\n              ref=\"monthButtonRefs\"\n              type=\"button\"\n              :disabled=\"item.disabled\"\n              :tabindex=\"tabIndex(item.month, rowIndex, buttonIndex)\"\n              class=\"usa-date-picker__calendar__month\"\n              :class=\"{\n                'usa-date-picker__calendar__month--selected':\n                  activeMonth === item.month,\n                'usa-date-picker__calendar__month--focused':\n                  highlightedRowIndex === rowIndex &&\n                  highlightedButtonIndex === buttonIndex,\n              }\"\n              :data-value=\"item.month\"\n              :data-label=\"item.label\"\n              :aria-selected=\"activeMonth === item.month\"\n              @click=\"handleClickOnMonth(item.month)\"\n              @mouseover=\"handleHoverOnMonth(item.month)\"\n              @keydown.prevent.up=\"handlePreviousMonth(item.up)\"\n              @keydown.prevent.down=\"handleNextMonth(item.down)\"\n              @keydown.prevent.left=\"handlePreviousMonth(item.left)\"\n              @keydown.prevent.right=\"handleNextMonth(item.right)\"\n              @keydown.prevent.home=\"handlePreviousMonth(item.home)\"\n              @keydown.prevent.end=\"handleNextMonth(item.end)\"\n              @keydown.prevent.page-up=\"handlePreviousMonth(item.pageUp)\"\n              @keydown.prevent.page-down=\"handleNextMonth(item.pageDown)\"\n              >{{ item.label }}</button\n            >\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n", "import { computed } from 'vue'\nimport { splitArray } from '@/utils/common.js'\nimport { YEAR_GROUP } from '@/utils/constants.js'\nimport { getYear, parseIsoDate } from '@/utils/dates.js'\n\nexport default ({ minDate, maxDate, activeYear }) => {\n  const minYear = computed(() => getYear(parseIsoDate(minDate.value)))\n  const maxYear = computed(() => getYear(parseIsoDate(maxDate.value)))\n\n  const isYearInRange = year => year >= minYear.value && year <= maxYear.value\n\n  const findClosestPastYear = (start, stop) => {\n    for (let index = start; index <= stop; index++) {\n      if (isYearInRange(index)) {\n        return index\n      }\n    }\n\n    return null\n  }\n\n  const findClosestFutureYear = (start, stop) => {\n    for (let index = start; index >= stop; index--) {\n      if (isYearInRange(index)) {\n        return index\n      }\n    }\n\n    return null\n  }\n\n  const yearToGroup = computed(() =>\n    Math.max(0, activeYear.value - (activeYear.value % YEAR_GROUP))\n  )\n\n  const visibleYearRange = computed(() => {\n    const years = []\n\n    let yearIndex = yearToGroup.value\n\n    while (years.length < YEAR_GROUP) {\n      years.push(yearIndex)\n      yearIndex += 1\n    }\n\n    return years\n  })\n\n  const groupedVisibleYearRange = computed(() =>\n    splitArray(visibleYearRange.value, 3)\n  )\n\n  const years = computed(() =>\n    groupedVisibleYearRange.value.map(row =>\n      row.map((year, index) => {\n        return {\n          year: year,\n          id: `${year}-${index}`,\n          disabled: !isYearInRange(year),\n          left: isYearInRange(year - 1) ? year - 1 : null,\n          right: isYearInRange(year + 1) ? year + 1 : null,\n          up: isYearInRange(year - 3) ? year - 3 : null,\n          down: isYearInRange(year + 3) ? year + 3 : null,\n          home: row.find(year => isYearInRange(year)) || null,\n          end: [...row].reverse().find(year => isYearInRange(year)) || null,\n          pageUp: findClosestPastYear(year - YEAR_GROUP, year),\n          pageDown: findClosestFutureYear(year + YEAR_GROUP, year),\n        }\n      })\n    )\n  )\n\n  const firstVisibleYear = computed(() => visibleYearRange.value[0])\n  const lastVisibleYear = computed(\n    () => visibleYearRange.value[visibleYearRange.value.length - 1]\n  )\n\n  const hasPastYear = computed(() => isYearInRange(firstVisibleYear.value - 1))\n  const hasFutureYear = computed(() => isYearInRange(lastVisibleYear.value + 1))\n\n  const firstAvailableVisibleYear = computed(() =>\n    findClosestPastYear(firstVisibleYear.value, lastVisibleYear.value)\n  )\n\n  const lastAvailableVisibleYear = computed(() =>\n    findClosestFutureYear(lastVisibleYear.value, firstVisibleYear.value)\n  )\n\n  const isYearAvailable = year => {\n    return (\n      year >= firstAvailableVisibleYear.value &&\n      year <= lastAvailableVisibleYear.value\n    )\n  }\n\n  const findRowIndexByYear = (years, yearToFind) => {\n    const rowIndex = years.value.findIndex(row =>\n      row.find(({ year }) => year === yearToFind)\n    )\n\n    return rowIndex\n  }\n\n  const findButtonIndexByYear = (years, rowIndex, yearToFind) => {\n    const buttonIndex = years.value[rowIndex].findIndex(\n      ({ year }) => year === yearToFind\n    )\n\n    return buttonIndex\n  }\n\n  return {\n    years,\n    visibleYearRange,\n    firstAvailableVisibleYear,\n    lastAvailableVisibleYear,\n    isYearAvailable,\n    hasPastYear,\n    hasFutureYear,\n    findRowIndexByYear,\n    findButtonIndexByYear,\n  }\n}\n", "<script setup>\nimport {\n  ref,\n  computed,\n  watch,\n  nextTick,\n  onMounted,\n  onBeforeUnmount,\n  shallowRef,\n  toRef,\n} from 'vue'\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport { YEAR_GROUP } from '@/utils/constants.js'\nimport { getYear, setYear, parseIsoDate } from '@/utils/dates.js'\nimport useYearPicker from './useYearPicker.js'\n\nconst emit = defineEmits([\n  'update:selectedYear',\n  'update:selectorMode',\n  'update:activeYearStart',\n  'update:activeYearEnd',\n])\n\nconst props = defineProps({\n  selectedYear: {\n    type: Number,\n    required: true,\n  },\n  activeDate: {\n    type: String,\n    required: true,\n  },\n  minDate: {\n    type: String,\n    required: true,\n  },\n  maxDate: {\n    type: String,\n    required: true,\n  },\n  previousYearsButtonLabel: {\n    type: String,\n    required: true,\n  },\n  nextYearsButtonLabel: {\n    type: String,\n    required: true,\n  },\n})\n\nconst yearDatePickerRef = ref(null)\nconst yearButtonRefs = ref([])\n\nconst { activate, deactivate } = useFocusTrap(yearDatePickerRef, {\n  immediate: true,\n  clickOutsideDeactivates: true,\n  initialFocus: '.usa-date-picker__calendar__year--focused',\n  fallbackFocus: '.usa-date-picker__calendar__date-picker',\n})\n\nconst activeDateObject = shallowRef(parseIsoDate(props.activeDate))\n\nwatch(\n  toRef(props, 'activeDate'),\n  newActiveDate => (activeDateObject.value = parseIsoDate(newActiveDate))\n)\n\nconst activeYear = computed({\n  get() {\n    return getYear(activeDateObject.value)\n  },\n  set(newYear) {\n    activeDateObject.value = setYear(activeDateObject.value, newYear)\n  },\n})\n\nconst {\n  years,\n  visibleYearRange,\n  firstAvailableVisibleYear,\n  lastAvailableVisibleYear,\n  isYearAvailable,\n  hasPastYear,\n  hasFutureYear,\n  findRowIndexByYear,\n  findButtonIndexByYear,\n} = useYearPicker({\n  minDate: toRef(props, 'minDate'),\n  maxDate: toRef(props, 'maxDate'),\n  activeYear,\n})\n\nwatch(\n  firstAvailableVisibleYear,\n  () => emit('update:activeYearStart', firstAvailableVisibleYear.value),\n  {\n    immediate: true,\n  }\n)\nwatch(\n  lastAvailableVisibleYear,\n  () => emit('update:activeYearEnd', lastAvailableVisibleYear.value),\n  {\n    immediate: true,\n  }\n)\n\nconst currentSelectedYear = computed({\n  get() {\n    return props.selectedYear\n  },\n  set(newSelectedYear) {\n    emit('update:selectedYear', newSelectedYear)\n  },\n})\n\nconst highlightedYear = ref(activeYear.value)\nconst highlightedRowIndex = ref(null)\nconst highlightedButtonIndex = ref(null)\n\nconst tabIndex = (year, rowIndex, buttonIndex) => {\n  if (\n    year === highlightedYear.value ||\n    year === currentSelectedYear.value ||\n    (highlightedRowIndex.value === rowIndex &&\n      highlightedButtonIndex.value === buttonIndex)\n  ) {\n    return 0\n  }\n\n  return -1\n}\n\nconst getButtonByYear = year =>\n  yearButtonRefs.value.find(\n    button => parseInt(button.dataset.value, 10) === year\n  )\n\nconst setButtonFocusByYear = year => {\n  const foundButton = getButtonByYear(year)\n\n  if (foundButton) {\n    foundButton.focus()\n  }\n}\n\nconst toPreviousYears = () => {\n  activeYear.value = activeYear.value - YEAR_GROUP\n}\n\nconst toNextYears = () => {\n  activeYear.value = activeYear.value + YEAR_GROUP\n}\n\nconst handleClickOnYear = year => {\n  currentSelectedYear.value = year\n  emit('update:selectorMode', 'day')\n}\n\nconst handleHoverOnYear = year => {\n  highlightedYear.value = year\n  setButtonFocusByYear(highlightedYear.value)\n}\n\nconst handlePreviousYear = year => {\n  if (!year) {\n    return\n  }\n\n  if (!visibleYearRange.value.includes(year)) {\n    toPreviousYears()\n  }\n\n  nextTick(() => {\n    highlightedYear.value = year\n    setButtonFocusByYear(year)\n  })\n}\n\nconst handleNextYear = year => {\n  if (!year) {\n    return\n  }\n\n  if (!visibleYearRange.value.includes(year)) {\n    toNextYears()\n  }\n\n  nextTick(() => {\n    highlightedYear.value = year\n    setButtonFocusByYear(year)\n  })\n}\n\nwatch(\n  highlightedYear,\n  newHighlightedYear => {\n    if (\n      visibleYearRange.value.includes(newHighlightedYear) &&\n      isYearAvailable(newHighlightedYear)\n    ) {\n      const newRowIndex = findRowIndexByYear(years, newHighlightedYear)\n\n      const newButtonIndex = findButtonIndexByYear(\n        years,\n        newRowIndex,\n        newHighlightedYear\n      )\n\n      highlightedRowIndex.value = newRowIndex\n      highlightedButtonIndex.value = newButtonIndex\n    }\n  },\n  { immediate: true }\n)\n\nwatch(years, (newVisibleYears, oldVisibleYear) => {\n  if (\n    newVisibleYears[highlightedRowIndex.value][highlightedButtonIndex.value]\n      .disabled\n  ) {\n    const wantedYear =\n      newVisibleYears[0][0].year < oldVisibleYear[0][0].year\n        ? firstAvailableVisibleYear.value\n        : lastAvailableVisibleYear.value\n\n    const newRowIndex = findRowIndexByYear(years, wantedYear)\n\n    if (newRowIndex === -1) {\n      return\n    }\n\n    const newButtonIndex = findButtonIndexByYear(years, newRowIndex, wantedYear)\n\n    highlightedYear.value = newVisibleYears[newRowIndex][newButtonIndex].year\n  }\n})\n\nonMounted(() => {\n  activate()\n})\n\nonBeforeUnmount(() => {\n  emit('update:activeYearStart', '')\n  emit('update:activeYearEnd', '')\n\n  deactivate()\n})\n</script>\n\n<template>\n  <div\n    ref=\"yearDatePickerRef\"\n    tabindex=\"-1\"\n    class=\"usa-date-picker__calendar__year-picker\"\n  >\n    <table role=\"presentation\" class=\"usa-date-picker__calendar__table\">\n      <tbody>\n        <tr>\n          <td>\n            <button\n              type=\"button\"\n              class=\"usa-date-picker__calendar__previous-year-chunk\"\n              :aria-label=\"previousYearsButtonLabel\"\n              :disabled=\"!hasPastYear\"\n              @click=\"toPreviousYears\"\n              >&nbsp;</button\n            >\n          </td>\n\n          <td colspan=\"3\">\n            <table class=\"usa-date-picker__calendar__table\" role=\"presentation\">\n              <tbody>\n                <tr\n                  v-for=\"(row, rowIndex) in years\"\n                  :key=\"`${rowIndex}-${row.map(({ year }) => year).join('-')}`\"\n                >\n                  <td v-for=\"(item, buttonIndex) in row\" :key=\"item.id\">\n                    <button\n                      ref=\"yearButtonRefs\"\n                      type=\"button\"\n                      :disabled=\"item.disabled\"\n                      :tabindex=\"tabIndex(item.year, rowIndex, buttonIndex)\"\n                      class=\"usa-date-picker__calendar__year\"\n                      :class=\"{\n                        'usa-date-picker__calendar__year--selected':\n                          currentSelectedYear === item.year,\n                        'usa-date-picker__calendar__year--focused':\n                          highlightedRowIndex === rowIndex &&\n                          highlightedButtonIndex === buttonIndex,\n                      }\"\n                      :data-value=\"item.year\"\n                      :aria-selected=\"currentSelectedYear === item.year\"\n                      @click=\"handleClickOnYear(item.year)\"\n                      @mouseover=\"handleHoverOnYear(item.year)\"\n                      @keydown.prevent.up=\"handlePreviousYear(item.up)\"\n                      @keydown.prevent.down=\"handleNextYear(item.down)\"\n                      @keydown.prevent.left=\"handlePreviousYear(item.left)\"\n                      @keydown.prevent.right=\"handleNextYear(item.right)\"\n                      @keydown.prevent.home=\"handlePreviousYear(item.home)\"\n                      @keydown.prevent.end=\"handleNextYear(item.end)\"\n                      @keydown.prevent.page-up=\"handlePreviousYear(item.pageUp)\"\n                      @keydown.prevent.page-down=\"handleNextYear(item.pageDown)\"\n                      >{{ item.year }}</button\n                    >\n                  </td>\n                </tr>\n              </tbody>\n            </table>\n          </td>\n\n          <td>\n            <button\n              type=\"button\"\n              class=\"usa-date-picker__calendar__next-year-chunk\"\n              :aria-label=\"nextYearsButtonLabel\"\n              :disabled=\"!hasFutureYear\"\n              @click=\"toNextYears\"\n              >&nbsp;</button\n            >\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n", "<script setup>\nimport { ref, computed, watch, shallowRef, onMounted } from 'vue'\nimport {\n  getYear,\n  formatIsoDate,\n  isDateAfter,\n  isDateInRange,\n  parseIsoDate,\n  setYear,\n  setMonth,\n} from '@/utils/dates.js'\nimport UsaDatePickerCalendarDay from '@/components/UsaDatePickerCalendarDay'\nimport UsaDatePickerCalendarMonth from '@/components/UsaDatePickerCalendarMonth'\nimport UsaDatePickerCalendarYear from '@/components/UsaDatePickerCalendarYear'\n\nconst emit = defineEmits([\n  'update:open',\n  'update:selectedDate',\n  'update:activeDate',\n  'update:selectorMode',\n  'update:highlightedDate',\n  'update:activeYearStart',\n  'update:activeYearEnd',\n  'update:isPristine',\n])\n\nconst props = defineProps({\n  open: {\n    type: Boolean,\n    default: false,\n  },\n  selectedDate: {\n    type: String,\n    default: '',\n  },\n  activeDate: {\n    type: String,\n    required: true,\n  },\n  highlightedDate: {\n    type: String,\n    default: '',\n  },\n  minDate: {\n    type: String,\n    required: true,\n  },\n  maxDate: {\n    type: String,\n    required: true,\n  },\n  selectorMode: {\n    type: String,\n    required: true,\n  },\n  monthLabels: {\n    type: Array,\n    required: true,\n  },\n  dayOfWeekLabels: {\n    type: Array,\n    required: true,\n  },\n  dayOfWeekAbbreviationLabels: {\n    type: Array,\n    required: true,\n  },\n  previousYearButtonLabel: {\n    type: String,\n    required: true,\n  },\n  nextYearButtonLabel: {\n    type: String,\n    required: true,\n  },\n  previousMonthButtonLabel: {\n    type: String,\n    required: true,\n  },\n  nextMonthButtonLabel: {\n    type: String,\n    required: true,\n  },\n  monthSelectionButtonLabel: {\n    type: String,\n    required: true,\n  },\n  yearSelectionButtonLabel: {\n    type: String,\n    required: true,\n  },\n  previousYearsButtonLabel: {\n    type: String,\n    required: true,\n  },\n  nextYearsButtonLabel: {\n    type: String,\n    required: true,\n  },\n})\n\nconst calendarPickerRef = ref(null)\n\nconst open = computed({\n  get() {\n    return props.open\n  },\n  set(isOpen) {\n    emit('update:open', isOpen)\n  },\n})\n\nconst selectorMode = computed({\n  get() {\n    return props.selectorMode\n  },\n  set(newMode) {\n    emit('update:selectorMode', newMode)\n  },\n})\n\nconst activeDate = computed({\n  get() {\n    return props.activeDate\n  },\n  set(newActiveDate) {\n    emit('update:activeDate', newActiveDate)\n  },\n})\n\nconst activeDateObject = shallowRef(parseIsoDate(activeDate.value))\n\nwatch(activeDate, newActiveDate => {\n  activeDateObject.value = parseIsoDate(newActiveDate)\n})\n\nconst activeYear = computed({\n  get() {\n    return getYear(activeDateObject.value)\n  },\n  set(newYear) {\n    const newDate = setYear(activeDateObject.value, newYear)\n\n    const minimumDate = parseIsoDate(props.minDate)\n    const maximumDate = parseIsoDate(props.maxDate)\n\n    if (isDateInRange(newDate, minimumDate, maximumDate)) {\n      activeDate.value = formatIsoDate(newDate)\n    } else {\n      const isAfter = isDateAfter(activeDateObject.value, newDate)\n\n      activeDate.value = isAfter\n        ? formatIsoDate(minimumDate)\n        : formatIsoDate(maximumDate)\n    }\n  },\n})\n\nconst highlightedDate = computed({\n  get() {\n    return props.highlightedDate\n  },\n  set(newHighlightedDate) {\n    emit('update:highlightedDate', newHighlightedDate)\n  },\n})\n\nconst selectMonth = newMonth => {\n  activeDate.value = formatIsoDate(\n    setMonth(parseIsoDate(highlightedDate.value), newMonth)\n  )\n}\n\nconst selectedDate = computed({\n  get() {\n    return props.selectedDate\n  },\n  set(newDate) {\n    emit('update:selectedDate', newDate)\n  },\n})\n\nwatch(selectedDate, newSelectedDate => {\n  if (!newSelectedDate) {\n    return\n  }\n  const newDate = parseIsoDate(newSelectedDate)\n  const minimumDate = parseIsoDate(props.minDate)\n  const maximumDate = parseIsoDate(props.maxDate)\n\n  if (isDateInRange(newDate, minimumDate, maximumDate)) {\n    activeDate.value = formatIsoDate(newDate)\n  }\n})\n\nonMounted(() => {\n  emit('update:activeDate', activeDate.value)\n})\n</script>\n\n<template>\n  <div\n    ref=\"calendarPickerRef\"\n    class=\"usa-date-picker__calendar\"\n    role=\"dialog\"\n    aria-modal=\"true\"\n    :data-value=\"highlightedDate\"\n    :hidden=\"!open\"\n  >\n    <template v-if=\"open\">\n      <UsaDatePickerCalendarDay\n        v-if=\"selectorMode === 'day'\"\n        v-model:selected-date=\"selectedDate\"\n        v-model:active-date=\"activeDate\"\n        :min-date=\"minDate\"\n        :max-date=\"maxDate\"\n        :month-labels=\"monthLabels\"\n        :day-of-week-labels=\"dayOfWeekLabels\"\n        :day-of-week-abbreviation-labels=\"dayOfWeekAbbreviationLabels\"\n        :previous-year-button-label=\"previousYearButtonLabel\"\n        :next-year-button-label=\"nextYearButtonLabel\"\n        :previous-month-button-label=\"previousMonthButtonLabel\"\n        :next-month-button-label=\"nextMonthButtonLabel\"\n        :month-selection-button-label=\"monthSelectionButtonLabel\"\n        :year-selection-button-label=\"yearSelectionButtonLabel\"\n        :previous-years-button-label=\"previousYearsButtonLabel\"\n        :next-years-button-label=\"nextYearsButtonLabel\"\n        @update:open=\"isOpen => (open = isOpen)\"\n        @update:selector-mode=\"newMode => (selectorMode = newMode)\"\n        @update:highlighted-date=\"newDate => (highlightedDate = newDate)\"\n        @update:is-pristine=\"\n          currentlyPristine => $emit('update:isPristine', currentlyPristine)\n        \"\n      ></UsaDatePickerCalendarDay>\n      <UsaDatePickerCalendarMonth\n        v-if=\"selectorMode === 'month'\"\n        :active-date=\"activeDate\"\n        :month-labels=\"monthLabels\"\n        :min-date=\"minDate\"\n        :max-date=\"maxDate\"\n        @update:selector-mode=\"newMode => (selectorMode = newMode)\"\n        @update:active-month=\"selectMonth\"\n      ></UsaDatePickerCalendarMonth>\n      <UsaDatePickerCalendarYear\n        v-if=\"selectorMode === 'year'\"\n        v-model:selected-year=\"activeYear\"\n        :active-date=\"activeDate\"\n        :min-date=\"minDate\"\n        :max-date=\"maxDate\"\n        :previous-years-button-label=\"previousYearsButtonLabel\"\n        :next-years-button-label=\"nextYearsButtonLabel\"\n        @update:selector-mode=\"newMode => (selectorMode = newMode)\"\n        @update:active-year-start=\"\n          newStartYear => $emit('update:activeYearStart', newStartYear)\n        \"\n        @update:active-year-end=\"\n          newEndYear => $emit('update:activeYearEnd', newEndYear)\n        \"\n      ></UsaDatePickerCalendarYear>\n    </template>\n  </div>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport {\n  ref,\n  computed,\n  useSlots,\n  shallowRef,\n  watch,\n  provide,\n  inject,\n  toRef,\n  onMounted,\n} from 'vue'\nimport { onKeyStroke, onClickOutside } from '@vueuse/core'\nimport { nextId } from '@/utils/unique-id.js'\n\nimport {\n  MIN_DATE,\n  MAX_DATE,\n  DAY_OF_WEEK_LABELS,\n  DAY_OF_WEEK_ABBREVIATION_LABELS,\n  MONTH_LABELS,\n} from '@/utils/constants.js'\n\nimport {\n  parseIsoDate,\n  parseUsaDate,\n  formatIsoDate,\n  formatUsaDate,\n  getMonthIndex,\n  getYear,\n  isValidDate,\n  isDateInRange,\n  isDateAfter,\n  today,\n  isValidIsoDate,\n  isValidUsaDate,\n} from '@/utils/dates.js'\n\nimport UsaFormGroup from '@/components/UsaFormGroup'\nimport UsaLabel from '@/components/UsaLabel'\nimport UsaDatePickerCalendar from '@/components/UsaDatePickerCalendar'\n\nconst slots = useSlots()\n\nconst isDateRange = inject('isDateRange', false)\nconst dateRangeStart = inject('dateRangeStart', '')\nconst dateRangeEnd = inject('dateRangeEnd', '')\nconst updateDateRangeStart = inject('updateDateRangeStart', null)\nconst updateDateRangeEnd = inject('updateDateRangeEnd', null)\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  minDate: {\n    type: String,\n    default: MIN_DATE,\n  },\n  maxDate: {\n    type: String,\n    default: MAX_DATE,\n  },\n  modelValue: {\n    type: String,\n    default: '',\n  },\n  rangeType: {\n    type: String,\n    default: '',\n    validator(rangeType) {\n      const isValidRangeType =\n        rangeType === '' || rangeType === 'start' || rangeType === 'end'\n\n      if (!isValidRangeType) {\n        console.warn(\n          `'${rangeType}' is an invalid range type. Range must be empty, 'start', or 'end'.`\n        )\n      }\n\n      return isValidRangeType\n    },\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  dayOfWeekLabels: {\n    type: Array,\n    default: () => DAY_OF_WEEK_LABELS,\n    validator(dayLabels) {\n      const totalLabels = dayLabels.length\n      const isValidDayLabelsLength = dayLabels.length === 7\n\n      if (!isValidDayLabelsLength) {\n        console.warn(\n          `Missing labels, there must be a label for each day of the week. 7 total are needed but only ${totalLabels} were given.`\n        )\n      }\n\n      return isValidDayLabelsLength\n    },\n  },\n  dayOfWeekAbbreviationLabels: {\n    type: Array,\n    default: () => DAY_OF_WEEK_ABBREVIATION_LABELS,\n    validator(dayLabels) {\n      const totalLabels = dayLabels.length\n      const isValidDayLabelsLength = dayLabels.length === 7\n\n      if (!isValidDayLabelsLength) {\n        console.warn(\n          `Missing labels, there must be a label for each day of the week. 7 total are needed but only ${totalLabels} were given.`\n        )\n      }\n\n      return isValidDayLabelsLength\n    },\n  },\n  monthLabels: {\n    type: Array,\n    default: () => MONTH_LABELS,\n    validator(monthLabels) {\n      const totalLabels = monthLabels.length\n      const isValidMonthLength = monthLabels.length === 12\n\n      if (!isValidMonthLength) {\n        console.warn(\n          `Missing labels, there must be a label for each month of the year. 12 total are needed but only ${totalLabels} were given.`\n        )\n      }\n\n      return isValidMonthLength\n    },\n  },\n  toggleButtonAriaLabel: {\n    type: String,\n    default: 'Toggle calendar',\n  },\n  previousYearButtonLabel: {\n    type: String,\n    default: 'Navigate back one year',\n  },\n  nextYearButtonLabel: {\n    type: String,\n    default: 'Navigate forward one year',\n  },\n  previousMonthButtonLabel: {\n    type: String,\n    default: 'Navigate back one month',\n  },\n  nextMonthButtonLabel: {\n    type: String,\n    default: 'Navigate forward one month',\n  },\n  yearSelectionButtonLabel: {\n    type: String,\n    default: '%s. Click to select year',\n  },\n  monthSelectionButtonLabel: {\n    type: String,\n    default: '%s. Click to select month',\n  },\n  previousYearsButtonLabel: {\n    type: String,\n    default: 'Navigate back 12 years',\n  },\n  nextYearsButtonLabel: {\n    type: String,\n    default: 'Navigate forward 12 years',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        formGroup: [],\n        component: [],\n        label: [],\n        input: [],\n      }\n    },\n  },\n})\n\nconst minDate = computed(() => {\n  if (isDateRange.value && props.rangeType === 'end' && dateRangeStart.value) {\n    return dateRangeStart.value\n  }\n\n  return props.minDate\n})\n\nconst maxDate = computed(() => {\n  if (isDateRange.value && props.rangeType === 'start' && dateRangeEnd.value) {\n    return dateRangeEnd.value\n  }\n\n  return props.maxDate\n})\n\nconst selectedDate = computed({\n  get() {\n    return props.modelValue\n  },\n  set(newDate) {\n    emit('update:modelValue', newDate)\n\n    if (!isDateRange.value) {\n      return\n    }\n\n    if (props.rangeType === 'start' && updateDateRangeStart) {\n      updateDateRangeStart(newDate)\n    } else if (props.rangeType === 'end' && updateDateRangeEnd) {\n      updateDateRangeEnd(newDate)\n    }\n  },\n})\n\nconst initialDate = () => {\n  if (\n    selectedDate.value &&\n    isDateInRange(\n      parseIsoDate(selectedDate.value),\n      parseIsoDate(minDate.value),\n      parseIsoDate(maxDate.value)\n    )\n  ) {\n    return selectedDate.value\n  }\n\n  if (\n    isDateRange.value &&\n    props.rangeType === 'end' &&\n    dateRangeStart.value &&\n    !dateRangeEnd.value\n  ) {\n    return dateRangeStart.value\n  }\n\n  if (\n    isDateRange.value &&\n    props.rangeType === 'start' &&\n    dateRangeEnd.value &&\n    !dateRangeStart.value\n  ) {\n    return dateRangeEnd.value\n  }\n\n  if (\n    isDateInRange(\n      today(),\n      parseIsoDate(minDate.value),\n      parseIsoDate(maxDate.value)\n    )\n  ) {\n    return formatIsoDate(today())\n  }\n\n  return minDate.value\n}\n\nconst datePickerWrapperRef = ref(null)\n\nconst textInputValue = ref(\n  selectedDate.value ? formatUsaDate(parseIsoDate(selectedDate.value)) : ''\n)\n\nconst open = ref(false)\nconst isPristine = ref(true)\nconst selectorMode = ref('day')\nconst yearRangeStart = ref('')\nconst yearRangeStop = ref('')\nconst highlightedDate = ref('')\nconst activeDate = ref(initialDate())\nconst activeDateObject = shallowRef(parseIsoDate(activeDate.value))\n\nwatch(activeDate, newActiveDate => {\n  activeDateObject.value = parseIsoDate(newActiveDate)\n})\n\nconst activeMonthLabel = computed(() =>\n  activeDate.value\n    ? props.monthLabels[getMonthIndex(activeDateObject.value)]\n    : ''\n)\n\nconst activeYear = computed(() =>\n  activeDate.value ? getYear(activeDateObject.value) : ''\n)\n\nconst closeCalendar = () => {\n  open.value = false\n  selectorMode.value = 'day'\n}\n\nconst openCalendar = () => {\n  activeDate.value = initialDate()\n  open.value = true\n}\n\nconst toggleCalendar = () => {\n  if (open.value) {\n    closeCalendar()\n  } else {\n    openCalendar()\n  }\n}\n\nconst computedId = computed(() => props.id || nextId('usa-date-picker'))\nconst computedLabelId = computed(() => `${computedId.value}-label`)\nconst computedErrorMessageId = computed(\n  () => `${computedId.value}-error-message`\n)\nconst computedHintId = computed(() => `${computedId.value}-hint`)\n\nconst ariaDescribedby = computed(() => {\n  const ids = []\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.length ? ids.join(' ') : null\n})\n\nconst classes = computed(() => [\n  { 'usa-date-picker--active': open.value },\n  {\n    'usa-date-range-picker__range-start':\n      isDateRange.value && props.rangeType === 'start',\n  },\n  {\n    'usa-date-range-picker__range-end':\n      isDateRange.value && props.rangeType === 'end',\n  },\n  ...(props.customClasses?.component || []),\n])\n\nonKeyStroke('Escape', () => {\n  if (open.value) {\n    closeCalendar()\n  }\n})\n\nonClickOutside(datePickerWrapperRef, () => {\n  if (open.value) {\n    closeCalendar()\n  }\n})\n\nwatch(textInputValue, newInputValue => {\n  if (newInputValue === '') {\n    selectedDate.value = ''\n    return\n  }\n\n  const dateObject = parseUsaDate(newInputValue)\n  const minimumDate = parseIsoDate(minDate.value)\n  const maximumDate = parseIsoDate(maxDate.value)\n  const inputValueIsoDate = formatIsoDate(dateObject)\n\n  if (\n    isValidIsoDate(inputValueIsoDate) &&\n    isValidUsaDate(newInputValue) &&\n    isValidDate(dateObject)\n  ) {\n    if (isDateInRange(dateObject, minimumDate, maximumDate)) {\n      selectedDate.value = inputValueIsoDate\n      activeDate.value = selectedDate.value\n      highlightedDate.value = activeDate.value\n      return\n    }\n\n    const isAfter = isDateAfter(activeDateObject.value, dateObject)\n\n    if (isAfter) {\n      activeDate.value = formatIsoDate(minimumDate)\n      highlightedDate.value = activeDate.value\n    } else {\n      activeDate.value = formatIsoDate(maximumDate)\n      highlightedDate.value = activeDate.value\n    }\n  }\n})\n\nwatch(selectedDate, newSelectedDate => {\n  if (textInputValue.value === formatUsaDate(parseIsoDate(newSelectedDate))) {\n    return\n  }\n\n  textInputValue.value = newSelectedDate\n    ? formatUsaDate(parseIsoDate(newSelectedDate))\n    : ''\n})\n\nprovide(\n  'inputHighlightedDate',\n  computed(() => highlightedDate.value)\n)\n\nprovide('rangeType', toRef(props, 'rangeType'))\n\nonMounted(() => {\n  if (\n    isDateRange.value &&\n    props.rangeType === 'start' &&\n    updateDateRangeStart\n  ) {\n    updateDateRangeStart(selectedDate.value)\n  } else if (\n    isDateRange.value &&\n    props.rangeType === 'end' &&\n    updateDateRangeEnd\n  ) {\n    updateDateRangeEnd(selectedDate.value)\n  }\n})\n</script>\n\n<template>\n  <UsaFormGroup\n    :group=\"!!$slots.hint || (error && !!$slots['error-message'])\"\n    :error=\"error\"\n    :class=\"props.customClasses?.formGroup\"\n  >\n    <UsaLabel\n      v-if=\"label || $slots.label\"\n      :id=\"computedLabelId\"\n      :for=\"computedId\"\n      :required=\"required\"\n      :error=\"error\"\n      :class=\"customClasses?.label\"\n      ><slot name=\"label\">{{ label }}</slot></UsaLabel\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n    <div class=\"usa-date-picker usa-date-picker--initialized\" :class=\"classes\">\n      <div ref=\"datePickerWrapperRef\" class=\"usa-date-picker__wrapper\">\n        <input\n          v-bind=\"$attrs\"\n          :id=\"computedId\"\n          v-model=\"textInputValue\"\n          :required=\"required\"\n          :disabled=\"disabled\"\n          :readonly=\"readonly\"\n          :aria-labelledby=\"label || $slots.label ? computedLabelId : null\"\n          :aria-describedby=\"ariaDescribedby\"\n          :class=\"props.customClasses?.input\"\n          class=\"usa-input usa-date-picker__external-input\"\n          type=\"text\"\n        />\n        <button\n          type=\"button\"\n          class=\"usa-date-picker__button\"\n          aria-haspopup=\"true\"\n          :aria-label=\"toggleButtonAriaLabel\"\n          :disabled=\"disabled\"\n          @click=\"toggleCalendar\"\n        ></button>\n\n        <UsaDatePickerCalendar\n          v-model:selected-date=\"selectedDate\"\n          v-model:selector-mode=\"selectorMode\"\n          v-model:open=\"open\"\n          v-model:active-date=\"activeDate\"\n          v-model:highlighted-date=\"highlightedDate\"\n          :style=\"`top: ${datePickerWrapperRef?.offsetHeight}px`\"\n          :min-date=\"minDate\"\n          :max-date=\"maxDate\"\n          :month-labels=\"monthLabels\"\n          :day-of-week-labels=\"dayOfWeekLabels\"\n          :day-of-week-abbreviation-labels=\"dayOfWeekAbbreviationLabels\"\n          :previous-year-button-label=\"previousYearButtonLabel\"\n          :next-year-button-label=\"nextYearButtonLabel\"\n          :previous-month-button-label=\"previousMonthButtonLabel\"\n          :next-month-button-label=\"nextMonthButtonLabel\"\n          :month-selection-button-label=\"monthSelectionButtonLabel\"\n          :year-selection-button-label=\"yearSelectionButtonLabel\"\n          :previous-years-button-label=\"previousYearsButtonLabel\"\n          :next-years-button-label=\"nextYearsButtonLabel\"\n          @update:is-pristine=\"\n            currentlyPristine => (isPristine = currentlyPristine)\n          \"\n          @update:active-year-start=\"\n            newStartYear => (yearRangeStart = newStartYear)\n          \"\n          @update:active-year-end=\"newEndYear => (yearRangeStop = newEndYear)\"\n        ></UsaDatePickerCalendar>\n\n        <div\n          class=\"usa-date-picker__status usa-sr-only\"\n          role=\"status\"\n          aria-live=\"polite\"\n        >\n          <slot\n            name=\"status\"\n            :open=\"open\"\n            :is-pristine=\"isPristine\"\n            :selector-mode=\"selectorMode\"\n            :selected-date=\"selectedDate\"\n            :highlighted-date=\"highlightedDate\"\n            :active-month-label=\"activeMonthLabel\"\n            :active-year=\"activeYear\"\n            :year-range-start=\"yearRangeStart\"\n            :year-range-stop=\"yearRangeStop\"\n          >\n            <template v-if=\"open\">\n              <template v-if=\"selectorMode === 'day'\">\n                <template\n                  v-if=\"selectedDate && selectedDate === highlightedDate\"\n                  >Selected date.</template\n                >\n                <template v-if=\"isPristine\">\n                  You can navigate by day using left and right arrows. Weeks by\n                  using up and down arrows. Months by using page up and page\n                  down keys. Years by using shift plus page up and shift plus\n                  page down. Home and end keys navigate to the beginning and end\n                  of a week.\n                </template>\n                <template v-else>\n                  {{ activeMonthLabel }} {{ activeYear }}\n                </template>\n              </template>\n              <template v-else-if=\"selectorMode === 'month'\"\n                >Select a month.</template\n              >\n              <template v-else-if=\"selectorMode === 'year'\"\n                >Showing years {{ yearRangeStart }} to {{ yearRangeStop }}.\n                Select a year.</template\n              >\n            </template>\n          </slot>\n        </div>\n      </div>\n    </div>\n  </UsaFormGroup>\n</template>\n", "<script setup>\nimport { ref, provide } from 'vue'\n\nconst rangeStart = ref('')\nconst rangeEnd = ref('')\n\nconst updateDateRangeStart = newRangeStart => {\n  rangeStart.value = newRangeStart\n}\nconst updateDateRangeEnd = newRangeEnd => {\n  rangeEnd.value = newRangeEnd\n}\n\nprovide('isDateRange', ref(true))\nprovide('dateRangeStart', rangeStart)\nprovide('dateRangeEnd', rangeEnd)\nprovide('updateDateRangeStart', updateDateRangeStart)\nprovide('updateDateRangeEnd', updateDateRangeEnd)\n</script>\n\n<template>\n  <div class=\"usa-date-range-picker\">\n    <slot></slot>\n  </div>\n</template>\n", "import { ref, computed, readonly } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport { escapeRegExp } from '@/utils/common.js'\n\nexport default (\n  _id,\n  _loadedFiles,\n  _acceptedFileFormats,\n  _multiple,\n  _disabled,\n  emit\n) => {\n  const id = ref(_id)\n  const allowMultiple = ref(_multiple)\n  const isDisabled = ref(_disabled)\n  const loadedFiles = ref(_loadedFiles)\n  const acceptedFileFormats = ref(_acceptedFileFormats)\n\n  const spacerGif =\n    'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\n\n  const computedId = computed(() => id.value || nextId('usa-file-input'))\n  const computedErrorMessageId = computed(\n    () => `${computedId.value}-error-message`\n  )\n  const computedHintId = computed(() => `${computedId.value}-hint`)\n\n  const validFileFormats = computed(() => {\n    const formats = acceptedFileFormats.value\n      .split(',')\n      .map(fileType => fileType.trim().toLowerCase())\n\n    const validFileFormats = {\n      types: [],\n      extensions: [],\n    }\n\n    formats.forEach(format => {\n      if (format.includes('/') && !validFileFormats.types.includes(format)) {\n        if (format.endsWith('/*')) {\n          validFileFormats.types.push(format.substring(0, format.length - 1))\n        } else {\n          validFileFormats.types.push(format)\n        }\n      } else if (\n        format.includes('.') &&\n        !validFileFormats.extensions.includes(format)\n      ) {\n        validFileFormats.extensions.push(format)\n      }\n    })\n\n    return validFileFormats\n  })\n\n  const getFileExtension = filename => {\n    const extensionPattern = /(?:.+)\\.(.+)$/\n    const match = filename.match(extensionPattern)\n\n    return `.${match?.[1]?.toLowerCase()}`\n  }\n\n  const getFileIconClass = extension => {\n    switch (extension) {\n      case '.pdf':\n        return 'usa-file-input__preview-image--pdf'\n\n      case '.doc':\n      case '.docx':\n      case '.pages':\n        return 'usa-file-input__preview-image--word'\n\n      case '.xls':\n      case '.xlsx':\n      case '.numbers':\n        return 'usa-file-input__preview-image--excel'\n\n      case '.mov':\n      case '.mp4':\n        return 'usa-file-input__preview-image--video'\n\n      default:\n        return 'usa-file-input__preview-image--generic'\n    }\n  }\n\n  const isImage = fileType => {\n    const pattern = new RegExp(/^image\\//gi)\n    return pattern.test(fileType)\n  }\n\n  const hasFiles = computed(() => loadedFiles.value?.length > 0)\n\n  const hasInvalidFiles = computed(() => {\n    if (!acceptedFileFormats.value || !hasFiles.value) {\n      return false\n    }\n\n    const validTypes = validFileFormats.value.types\n    const validExtensions = validFileFormats.value.extensions\n\n    const someValidFiles = loadedFiles.value.every(file => {\n      const someValidTypes = validTypes.some(type => {\n        const typePattern = new RegExp(escapeRegExp(type), 'gi')\n\n        return typePattern.test(file.type)\n      })\n\n      const someValidExtensions = validExtensions.some(extension => {\n        const extensionPattern = new RegExp(escapeRegExp(extension), 'gi')\n\n        return extensionPattern.test(file.extension)\n      })\n\n      return someValidTypes || someValidExtensions\n    })\n\n    return !someValidFiles\n  })\n\n  const loadedFileNames = computed(() =>\n    loadedFiles.value.map(file => file.name).join(', ')\n  )\n\n  const generatePreviews = (event, index) => {\n    const file = loadedFiles.value[index]\n\n    if (isImage(file?.type) && event?.target?.result) {\n      file.iconClasses = null\n      file.src = event.target.result\n    } else {\n      file.iconClasses = [getFileIconClass(file.extension)]\n    }\n  }\n\n  async function loadFiles(fileList) {\n    if (!fileList?.length || isDisabled.value) {\n      loadedFiles.value = []\n\n      return\n    }\n\n    let files = []\n\n    // If multiple files aren't allow, only process the first.\n    if (allowMultiple.value) {\n      for (let i = 0; i < fileList.length; i++) {\n        files.push(fileList.item(i))\n      }\n    } else {\n      files.push(fileList.item(0))\n    }\n\n    emit('filesLoaded', files)\n\n    loadedFiles.value = files.reduce((acc, file, index) => {\n      const fileExtension = getFileExtension(file.name)\n\n      const metadata = {\n        name: file.name,\n        type: file.type,\n        extension: fileExtension,\n        src: spacerGif,\n        iconClasses: [getFileIconClass(fileExtension), 'is-loading'],\n      }\n\n      const reader = new FileReader()\n\n      reader.addEventListener(\n        'loadend',\n        event => generatePreviews(event, index),\n        false\n      )\n\n      reader.readAsDataURL(file)\n\n      acc.push(metadata)\n\n      return acc\n    }, [])\n  }\n\n  return {\n    computedErrorMessageId,\n    computedHintId,\n    computedId,\n    hasFiles,\n    hasInvalidFiles,\n    isDisabled,\n    loadFiles,\n    loadedFileNames,\n    loadedFiles: readonly(loadedFiles),\n  }\n}\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, ref, toRef, useSlots, watch } from 'vue'\nimport useFileInput from '@/composables/useFileInput.js'\nimport UsaFormGroup from '@/components/UsaFormGroup'\nimport UsaLabel from '@/components/UsaLabel'\n\nconst slots = useSlots()\nconst emit = defineEmits(['filesLoaded'])\n\nconst props = defineProps({\n  accept: {\n    type: String,\n    default: '',\n  },\n  multiple: {\n    type: Boolean,\n    default: false,\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        formGroup: [],\n        component: [],\n        label: [],\n        input: [],\n      }\n    },\n  },\n})\n\nconst fileInputRef = ref(null)\nconst isOverDropzone = ref(false)\n\nconst {\n  computedErrorMessageId,\n  computedHintId,\n  computedId,\n  hasFiles,\n  hasInvalidFiles,\n  isDisabled,\n  loadFiles,\n  loadedFileNames,\n  loadedFiles,\n} = useFileInput(\n  toRef(props, 'id'),\n  ref([]),\n  toRef(props, 'accept'),\n  toRef(props, 'multiple'),\n  toRef(props, 'disabled'),\n  emit\n)\n\nwatch(hasInvalidFiles, invalid => {\n  if (invalid) {\n    fileInputRef.value.value = ''\n  }\n})\n\nconst ariaDescribedby = computed(() => {\n  const ids = []\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.length ? ids.join(' ') : null\n})\n\nconst classes = computed(() => [\n  {\n    'usa-file-input--disabled': isDisabled.value,\n    'has-invalid-file': hasInvalidFiles.value,\n  },\n  ...(props.customClasses?.component || []),\n])\n\nconst dropZoneClasses = computed(() => [\n  { 'usa-file-input--drag': isOverDropzone.value },\n])\n\n// TODO: Support custom text for other languages.\nconst ariaLabel = computed(() => {\n  if (!loadedFiles.value?.length) {\n    return props.multiple ? 'No files selected' : 'No file selected'\n  }\n\n  if (loadedFiles.value.length === 1) {\n    return `You have selected the file: ${loadedFiles.value[0].name}`\n  }\n\n  return `You have selected ${loadedFiles.value.length} files: ${loadedFileNames.value}`\n})\n</script>\n\n<template>\n  <UsaFormGroup\n    :group=\"!!$slots.hint || (error && !!$slots['error-message'])\"\n    :error=\"error\"\n    :class=\"props.customClasses?.formGroup\"\n  >\n    <UsaLabel\n      v-if=\"label || $slots.label\"\n      :for=\"computedId\"\n      :required=\"required\"\n      :error=\"error\"\n      :class=\"customClasses?.label\"\n      ><slot name=\"label\">{{ label }}</slot></UsaLabel\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n\n    <div\n      class=\"usa-file-input\"\n      :aria-disabled=\"isDisabled || null\"\n      :class=\"classes\"\n    >\n      <div class=\"usa-file-input__target\" :class=\"dropZoneClasses\">\n        <div\n          v-show=\"hasInvalidFiles || !hasFiles\"\n          class=\"usa-file-input__instructions\"\n          aria-hidden=\"true\"\n          ><slot name=\"instructions\" :multiple=\"multiple\"\n            ><span class=\"usa-file-input__drag-text\"\n              >Drag file<template v-if=\"multiple\">s</template> here or </span\n            ><span class=\"usa-file-input__choose\"\n              >choose from folder</span\n            ></slot\n          ></div\n        >\n        <template v-if=\"!hasInvalidFiles && hasFiles\">\n          <div class=\"usa-file-input__preview-heading\">\n            <slot name=\"preview-heading\" :loaded-files=\"loadedFiles\">\n              <template v-if=\"loadedFiles.length === 1\">Selected file</template>\n              <template v-else\n                >{{ loadedFiles.length }} files selected</template\n              >\n              <span class=\"usa-file-input__choose\">Change file</span>\n            </slot>\n          </div>\n          <div\n            v-for=\"(file, index) in loadedFiles\"\n            :key=\"file.name + index\"\n            class=\"usa-file-input__preview\"\n            aria-hidden=\"true\"\n          >\n            <img\n              :src=\"file.src\"\n              alt=\"\"\n              class=\"usa-file-input__preview-image\"\n              :class=\"file?.iconClasses\"\n            />\n            {{ file.name }}\n          </div>\n        </template>\n\n        <div class=\"usa-file-input__box\"></div>\n        <div\n          v-if=\"hasInvalidFiles\"\n          class=\"usa-file-input__accepted-files-message\"\n          ><slot name=\"invalid-files-message\"\n            >This is not a valid file type.</slot\n          ></div\n        >\n        <input\n          v-bind=\"$attrs\"\n          :id=\"computedId\"\n          ref=\"fileInputRef\"\n          type=\"file\"\n          :required=\"required\"\n          :disabled=\"isDisabled\"\n          :accept=\"accept || null\"\n          :multiple=\"multiple || null\"\n          class=\"usa-file-input__input\"\n          :class=\"customClasses?.input\"\n          :aria-label=\"ariaLabel\"\n          :aria-describedby=\"ariaDescribedby\"\n          aria-live=\"polite\"\n          @change=\"loadFiles($event.target.files)\"\n          @dragenter=\"isOverDropzone = true\"\n          @dragover=\"isOverDropzone = true\"\n          @dragleave=\"isOverDropzone = false\"\n          @drop=\"isOverDropzone = false\"\n        />\n      </div>\n    </div>\n  </UsaFormGroup>\n</template>\n", "<script setup>\nimport { computed, inject, provide } from 'vue'\nimport { GRID_NAMESPACE } from '@/utils/constants.js'\n\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\n\nconst props = defineProps({\n  variant: {\n    type: String,\n    default: 'medium',\n    validator(variant) {\n      const isValidVariant = ['big', 'medium', 'slim'].includes(variant)\n\n      if (!isValidVariant) {\n        console.warn(`'${variant}' is not a valid footer variant`)\n      }\n\n      return isValidVariant\n    },\n  },\n  jumpLinkText: {\n    type: String,\n    default: 'Return to top',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        container: [],\n      }\n    },\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-footer--big': props.variant === 'big',\n    'usa-footer--medium': props.variant === 'medium',\n    'usa-footer--slim': props.variant === 'slim',\n  },\n])\n\nconst containerClasses = computed(() =>\n  props.customClasses?.container?.length\n    ? props.customClasses.container\n    : [`${gridNamespace}container`]\n)\n\nprovide(\n  'footerVariant',\n  computed(() => props.variant)\n)\n</script>\n\n<template>\n  <footer class=\"usa-footer\" :class=\"classes\">\n    <div class=\"usa-footer__return-to-top\" :class=\"containerClasses\">\n      <slot name=\"jump-link\"\n        ><a href=\"#\">{{ jumpLinkText }}</a></slot\n      >\n    </div>\n    <slot></slot>\n  </footer>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, inject } from 'vue'\nimport { PREFIX_SEPARATOR, GRID_NAMESPACE } from '@/utils/constants.js'\n\nconst prefixSeparator = inject('vueUswds.prefixSeparator', PREFIX_SEPARATOR)\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\nconst footerVariant = inject('footerVariant', 'medium')\n\nconst props = defineProps({\n  heading: {\n    type: String,\n    default: '',\n  },\n  email: {\n    type: String,\n    default: '',\n  },\n  phone: {\n    type: String,\n    default: '',\n  },\n  phoneUrl: {\n    type: String,\n    default: '',\n  },\n})\n\nconst emailHref = computed(() => {\n  if (props.email) {\n    return `mailto:${props.email.trim().toLowerCase()}`\n  }\n\n  return ''\n})\n\nconst phoneHref = computed(() => {\n  if (props.phoneUrl) {\n    return `tel:${props.phoneUrl.trim()}`\n  }\n\n  return ''\n})\n</script>\n\n<template>\n  <p\n    v-if=\"heading && footerVariant !== 'slim'\"\n    class=\"usa-footer__contact-heading\"\n    >{{ heading }}</p\n  >\n  <address class=\"usa-footer__address\" v-bind=\"$attrs\">\n    <slot>\n      <div\n        v-if=\"footerVariant === 'slim'\"\n        :class=\"`${gridNamespace}row ${gridNamespace}gap`\"\n      >\n        <div\n          v-if=\"phoneHref\"\n          :class=\"`${gridNamespace}col-auto mobile-lg${prefixSeparator}${gridNamespace}col-12 desktop${prefixSeparator}${gridNamespace}col-auto`\"\n        >\n          <div class=\"usa-footer__contact-info\">\n            <a :href=\"phoneHref\">{{ phone }}</a>\n          </div>\n        </div>\n        <div\n          v-if=\"emailHref\"\n          :class=\"`${gridNamespace}col-auto mobile-lg${prefixSeparator}${gridNamespace}col-12 desktop${prefixSeparator}${gridNamespace}col-auto`\"\n        >\n          <div class=\"usa-footer__contact-info\">\n            <a :href=\"emailHref\">{{ email }}</a>\n          </div>\n        </div>\n      </div>\n      <div\n        v-else\n        :class=\"`usa-footer__contact-info ${gridNamespace}row ${gridNamespace}gap`\"\n      >\n        <div v-if=\"phoneHref\" :class=\"`${gridNamespace}col-auto`\">\n          <a :href=\"phoneHref\">{{ phone }}</a>\n        </div>\n        <div v-if=\"emailHref\" :class=\"`${gridNamespace}col-auto`\">\n          <a :href=\"emailHref\">{{ email }}</a>\n        </div>\n      </div>\n    </slot>\n  </address>\n</template>\n", "<script setup>\nimport { computed, inject, toRef, onBeforeUnmount } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport BaseLink from '@/components/BaseLink'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst isCollapsible = inject('footerMenuIsCollapsible')\nconst menuSections = inject('menuSections')\nconst registerMenuSection = inject('registerMenuSection')\nconst unregisterMenuSection = inject('unregisterMenuSection')\nconst toggleMenuSection = inject('toggleMenuSection')\n\nconst props = defineProps({\n  item: {\n    type: Object,\n    default: () => {},\n  },\n  headingTag: {\n    type: String,\n    default: 'h4',\n  },\n})\n\nconst menuSectionId = computed(\n  () => props.item?.id || nextId('usa-footer-collapsible-menu-section')\n)\n\nregisterMenuSection(menuSectionId.value, false)\n\nonBeforeUnmount(() => {\n  unregisterMenuSection(menuSectionId.value)\n})\n\nconst isOpen = toRef(menuSections, menuSectionId.value)\n</script>\n\n<template>\n  <section\n    :key=\"item?.id || item.text\"\n    class=\"usa-footer__primary-content usa-footer__primary-content--collapsible\"\n  >\n    <button\n      v-if=\"isCollapsible\"\n      type=\"button\"\n      class=\"usa-footer__primary-link usa-footer__primary-link--button\"\n      :aria-expanded=\"isOpen\"\n      :aria-controls=\"menuSectionId\"\n      @click=\"toggleMenuSection(menuSectionId)\"\n      >{{ item.text }}</button\n    >\n    <BaseHeading v-else :tag=\"headingTag\" class=\"usa-footer__primary-link\">{{\n      item.text\n    }}</BaseHeading>\n    <ul\n      v-if=\"item?.children?.length\"\n      v-show=\"isOpen || !isCollapsible\"\n      :id=\"menuSectionId\"\n      class=\"usa-list usa-list--unstyled\"\n    >\n      <li\n        v-for=\"subItem in item.children\"\n        :key=\"subItem?.id || subItem.text\"\n        class=\"usa-footer__secondary-link\"\n      >\n        <BaseLink\n          :to=\"subItem.to\"\n          :href=\"subItem.href\"\n          :router-component-name=\"subItem.routerComponentName\"\n          >{{ subItem.text }}</BaseLink\n        >\n      </li>\n    </ul>\n  </section>\n</template>\n", "<script setup>\nimport { computed, inject, reactive, watch, provide } from 'vue'\nimport { useMediaQuery } from '@vueuse/core'\nimport {\n  PREFIX_SEPARATOR,\n  GRID_NAMESPACE,\n  FOOTER_NAV_COLLAPSIBLE_BREAKPOINT,\n} from '@/utils/constants.js'\nimport useAccordion from '@/composables/useAccordion.js'\nimport UsaFooterCollapsibleMenuSection from '@/components/UsaFooterCollapsibleMenuSection'\n\nconst prefixSeparator = inject('vueUswds.prefixSeparator', PREFIX_SEPARATOR)\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\nconst footerNavBigBreakpoint = inject(\n  'vueUswds.footerNavBigBreakpoint',\n  FOOTER_NAV_COLLAPSIBLE_BREAKPOINT\n)\n\nconst props = defineProps({\n  items: {\n    type: Array,\n    default: () => [],\n  },\n  headingTag: {\n    type: String,\n    default: 'h4',\n  },\n  customClasses: {\n    type: Object,\n    default: () => ({\n      gridRow: [],\n      gridCol: [],\n    }),\n  },\n})\n\nconst isCollapsible = useMediaQuery(`(max-width: ${footerNavBigBreakpoint})`)\nconst menuSections = reactive({})\n\nconst {\n  registerAccordionItem,\n  unregisterAccordionItem,\n  closeItem,\n  toggleItem,\n  closeAllItems,\n} = useAccordion(menuSections)\n\nwatch(isCollapsible, closeAllItems)\n\nconst gridRowClasses = computed(() => {\n  if (props.customClasses?.gridRow?.length) {\n    return props.customClasses.gridRow\n  }\n\n  return [`${gridNamespace}row`, `${gridNamespace}gap-4`]\n})\n\nconst gridColClasses = computed(() => {\n  if (props.customClasses?.gridCol?.length) {\n    return props.customClasses.gridCol\n  }\n\n  return [\n    `mobile-lg${prefixSeparator}${gridNamespace}col-6`,\n    `desktop${prefixSeparator}${gridNamespace}col-3`,\n  ]\n})\n\nprovide('registerMenuSection', registerAccordionItem)\nprovide('unregisterMenuSection', unregisterAccordionItem)\nprovide('toggleMenuSection', toggleItem)\nprovide('closeMenuSection', closeItem)\nprovide('closeAllMenuSections', closeAllItems)\nprovide('menuSections', menuSections)\nprovide('footerMenuIsCollapsible', isCollapsible)\n</script>\n\n<template>\n  <div :class=\"gridRowClasses\">\n    <div :class=\"gridColClasses\">\n      <UsaFooterCollapsibleMenuSection\n        v-for=\"item in items\"\n        :key=\"item?.id || item.text\"\n        :item=\"item\"\n        :heading-tag=\"headingTag\"\n      ></UsaFooterCollapsibleMenuSection>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { inject, computed } from 'vue'\nimport { PREFIX_SEPARATOR, GRID_NAMESPACE } from '@/utils/constants.js'\n\nconst prefixSeparator = inject('vueUswds.prefixSeparator', PREFIX_SEPARATOR)\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\n\nconst props = defineProps({\n  src: {\n    type: String,\n    default: '',\n  },\n  alt: {\n    type: String,\n    default: '',\n  },\n  heading: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        logoGridCol: [],\n        headingGridCol: [],\n      }\n    },\n  },\n})\n\nconst logoGridClasses = computed(() =>\n  props.customClasses?.logoGridCol?.length\n    ? props.customClasses.logoGridCol\n    : [`mobile-lg${prefixSeparator}${gridNamespace}col-auto`]\n)\nconst headingGridClasses = computed(() =>\n  props.customClasses?.headingGridCol?.length\n    ? props.customClasses.headingGridCol\n    : [`mobile-lg${prefixSeparator}${gridNamespace}col-auto`]\n)\n</script>\n\n<template>\n  <div class=\"usa-footer__logo\">\n    <div :class=\"logoGridClasses\">\n      <slot name=\"logo\">\n        <img v-if=\"src\" class=\"usa-footer__logo-img\" :src=\"src\" :alt=\"alt\" />\n      </slot>\n    </div>\n    <div :class=\"headingGridClasses\">\n      <p class=\"usa-footer__logo-heading\">\n        <slot name=\"heading\">{{ heading }}</slot>\n      </p>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { PREFIX_SEPARATOR, GRID_NAMESPACE } from '@/utils/constants.js'\nimport BaseLink from '@/components/BaseLink'\n\nconst prefixSeparator = inject('vueUswds.prefixSeparator', PREFIX_SEPARATOR)\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\n\nconst props = defineProps({\n  items: {\n    type: Array,\n    default: () => [],\n  },\n  customClasses: {\n    type: Object,\n    default: () => ({\n      gridRow: [],\n      gridCol: [],\n    }),\n  },\n})\n\nconst gridRowClasses = computed(() => {\n  if (props.customClasses?.gridRow?.length) {\n    return props.customClasses.gridRow\n  }\n\n  return [`${gridNamespace}row`, `${gridNamespace}gap`]\n})\n\nconst griColClasses = computed(() => {\n  if (props.customClasses?.gridCol?.length) {\n    return props.customClasses.gridCol\n  }\n\n  return [\n    `mobile-lg${prefixSeparator}${gridNamespace}col-6`,\n    `desktop${prefixSeparator}${gridNamespace}col-auto`,\n  ]\n})\n</script>\n\n<template>\n  <ul :class=\"gridRowClasses\">\n    <li\n      v-for=\"item in items\"\n      :key=\"item?.id || item.text\"\n      class=\"usa-footer__primary-content\"\n      :class=\"griColClasses\"\n    >\n      <BaseLink\n        :to=\"item.to\"\n        :href=\"item.href\"\n        class=\"usa-footer__primary-link\"\n        :router-component-name=\"item.routerComponentName\"\n        >{{ item.text }}</BaseLink\n      >\n    </li>\n  </ul>\n</template>\n", "<script setup>\nimport { inject } from 'vue'\nimport UsaFooterMenu from '@/components/UsaFooterMenu'\nimport UsaFooterCollapsibleMenu from '@/components/UsaFooterCollapsibleMenu'\n\nconst footerVariant = inject('footerVariant', 'medium')\n\ndefineProps({\n  ariaLabel: {\n    type: String,\n    default: 'Footer navigation',\n  },\n  items: {\n    type: Array,\n    default: () => [],\n  },\n  collapsibleHeadingTag: {\n    type: String,\n    default: 'h4',\n  },\n  customClasses: {\n    type: Object,\n    default: () => ({\n      gridRow: [],\n      gridCol: [],\n    }),\n  },\n})\n</script>\n\n<template>\n  <nav class=\"usa-footer__nav\" :aria-label=\"ariaLabel\">\n    <slot :items=\"items\">\n      <template v-if=\"items.length\">\n        <UsaFooterCollapsibleMenu\n          v-if=\"footerVariant === 'big'\"\n          :items=\"items\"\n          :heading-tag=\"collapsibleHeadingTag\"\n          :custom-classes=\"customClasses\"\n        ></UsaFooterCollapsibleMenu>\n        <UsaFooterMenu\n          v-else-if=\"footerVariant === 'medium' || footerVariant === 'slim'\"\n          :items=\"items\"\n          :custom-classes=\"customClasses\"\n        ></UsaFooterMenu>\n      </template>\n    </slot>\n  </nav>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { GRID_NAMESPACE } from '@/utils/constants.js'\n\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\n\nconst props = defineProps({\n  customClasses: {\n    type: Object,\n    default: () => ({\n      container: [],\n    }),\n  },\n})\n\nconst containerClasses = computed(() =>\n  props.customClasses?.container?.length\n    ? props.customClasses.container\n    : [`${gridNamespace}container`]\n)\n</script>\n\n<template>\n  <div class=\"usa-footer__secondary-section\">\n    <div :class=\"containerClasses\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { GRID_NAMESPACE } from '@/utils/constants.js'\nimport BaseLink from '@/components/BaseLink'\n\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\n\nconst props = defineProps({\n  items: {\n    type: Array,\n    default: () => [],\n  },\n  customClasses: {\n    type: Object,\n    default: () => ({\n      gridCol: [],\n      link: [],\n      icon: [],\n    }),\n  },\n})\n\nconst gridColClasses = computed(() =>\n  props.customClasses?.gridCol?.length\n    ? props.customClasses.gridCol\n    : [`${gridNamespace}col-auto`]\n)\n</script>\n\n<template>\n  <div class=\"usa-footer__social-links\">\n    <div\n      v-for=\"item in items\"\n      :key=\"item?.id || item.name\"\n      :class=\"gridColClasses\"\n    >\n      <BaseLink\n        :to=\"item.to\"\n        :href=\"item.href\"\n        class=\"usa-social-link\"\n        :class=\"customClasses?.link\"\n        :router-component-name=\"item.routerComponentName\"\n      >\n        <slot :name=\"item?.id || item.name.toLowerCase()\" :item=\"item\">\n          <img\n            class=\"usa-social-link__icon\"\n            :class=\"customClasses?.icon\"\n            :src=\"item.icon\"\n            :alt=\"item.name\"\n          />\n        </slot>\n      </BaseLink>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { GRID_NAMESPACE } from '@/utils/constants.js'\n\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\n\nconst props = defineProps({\n  variant: {\n    type: String,\n    default: 'dark',\n    validator(variant) {\n      const isValidVariant = ['light', 'dark'].includes(variant)\n\n      if (!isValidVariant) {\n        console.warn(`'${variant}' is not a valid graphic list variant`)\n      }\n\n      return isValidVariant\n    },\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        container: [],\n      }\n    },\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-section--dark': props.variant === 'dark',\n    'usa-section--light': props.variant === 'light',\n  },\n])\n\nconst containerClasses = computed(() =>\n  props.customClasses?.container?.length\n    ? props.customClasses.container\n    : [`${gridNamespace}container`]\n)\n</script>\n\n<template>\n  <section class=\"usa-graphic-list usa-section\" :class=\"classes\">\n    <div :class=\"containerClasses\">\n      <slot :variant=\"variant\"></slot>\n    </div>\n  </section>\n</template>\n", "<script setup>\nimport { computed, provide } from 'vue'\n\nconst props = defineProps({\n  variant: {\n    type: String,\n    default: 'basic',\n    validator(variant) {\n      const isValidVariant = ['basic', 'extended'].includes(variant)\n\n      if (!isValidVariant) {\n        console.warn(`'${variant}' is not a valid header variant`)\n      }\n\n      return isValidVariant\n    },\n  },\n  megamenu: {\n    type: Boolean,\n    default: false,\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        navContainer: [],\n      }\n    },\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-header--basic': props.variant === 'basic',\n    'usa-header--extended': props.variant === 'extended',\n    'usa-header--megamenu': props.megamenu,\n  },\n])\n\nprovide(\n  'isExtendedHeader',\n  computed(() => props.variant === 'extended')\n)\nprovide(\n  'isMegamenu',\n  computed(() => props.megamenu)\n)\n</script>\n\n<template>\n  <header class=\"usa-header\" :class=\"classes\">\n    <div\n      v-if=\"variant === 'basic'\"\n      class=\"usa-nav-container\"\n      :class=\"customClasses?.navContainer\"\n    >\n      <slot></slot>\n    </div>\n\n    <template v-else>\n      <slot></slot>\n    </template>\n  </header>\n</template>\n", "<script setup>\nimport { inject, computed } from 'vue'\nimport { GRID_NAMESPACE } from '@/utils/constants.js'\n\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\n\nconst props = defineProps({\n  backgroundImage: {\n    type: String,\n    default: '',\n  },\n  ariaLabel: {\n    type: String,\n    required: true,\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        gridContainer: [],\n      }\n    },\n  },\n})\n\nconst gridContainerClasses = computed(() => {\n  return [\n    `${gridNamespace}container`,\n    ...(props.customClasses?.gridContainer || []),\n  ]\n})\n\nconst backgroundImageStyle = computed(() => {\n  return {\n    backgroundImage: props.backgroundImage\n      ? `url(${props.backgroundImage})`\n      : null,\n  }\n})\n</script>\n\n<template>\n  <section\n    class=\"usa-hero\"\n    :aria-label=\"ariaLabel\"\n    :style=\"backgroundImageStyle\"\n  >\n    <div :class=\"gridContainerClasses\"><slot></slot></div>\n  </section>\n</template>\n", "<script setup>\nimport { useSlots } from 'vue'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst slots = useSlots()\n\nif (slots?.headingAlt) {\n  console.warn(\n    `The 'headingAlt' slot is deprecated, use 'heading-alt' instead.`\n  )\n}\n\ndefineProps({\n  headingAlt: {\n    type: String,\n    default: '',\n  },\n  heading: {\n    type: String,\n    default: '',\n  },\n  headingTag: {\n    type: String,\n    default: 'h1',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        heading: [],\n        headingAlt: [],\n      }\n    },\n  },\n})\n</script>\n\n<template>\n  <div class=\"usa-hero__callout\">\n    <BaseHeading\n      v-if=\"\n        heading ||\n        headingAlt ||\n        $slots.heading ||\n        $slots.headingAlt ||\n        $slots['heading-alt']\n      \"\n      :tag=\"headingTag\"\n      class=\"usa-hero__heading\"\n      :class=\"customClasses?.heading\"\n    >\n      <span\n        v-if=\"headingAlt || $slots.headingAlt || $slots['heading-alt']\"\n        class=\"usa-hero__heading--alt\"\n        :class=\"customClasses?.headingAlt\"\n      >\n        <slot v-if=\"$slots['heading-alt']\" name=\"heading-alt\"></slot>\n        <!--\n        \t@slot headingAlt\n      \t\t@deprecated Use the `heading-alt` slot instead.\n      \t-->\n        <slot v-else-if=\"$slots.headingAlt\" name=\"headingAlt\"></slot>\n        <template v-else>{{ headingAlt }}</template>\n      </span>\n      <slot name=\"heading\">{{ heading }}</slot>\n    </BaseHeading>\n    <slot></slot>\n  </div>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { SVG_SPRITE_PATH } from '@/utils/constants.js'\n\nconst svgSpritePath = inject('vueUswds.svgSpritePath', SVG_SPRITE_PATH)\n\nconst props = defineProps({\n  name: {\n    type: String,\n    required: true,\n  },\n  size: {\n    type: [String, Number],\n    default: '',\n    validator(size) {\n      const isValidSize = ['', '3', '4', '5', '6', '7', '8', '9'].includes(\n        `${size}`\n      )\n\n      if (!isValidSize) {\n        console.warn(`'${size}' is not a valid icon size`)\n      }\n\n      return isValidSize\n    },\n  },\n  ariaHidden: {\n    type: Boolean,\n    default: true,\n  },\n  role: {\n    type: String,\n    default: 'img',\n  },\n  focusable: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-icon--size-3': `${props.size}` === '3',\n    'usa-icon--size-4': `${props.size}` === '4',\n    'usa-icon--size-5': `${props.size}` === '5',\n    'usa-icon--size-6': `${props.size}` === '6',\n    'usa-icon--size-7': `${props.size}` === '7',\n    'usa-icon--size-8': `${props.size}` === '8',\n    'usa-icon--size-9': `${props.size}` === '9',\n  },\n])\n\nconst iconHref = computed(() => `${svgSpritePath}#${props.name}`)\n</script>\n\n<template>\n  <svg\n    class=\"usa-icon\"\n    :class=\"classes\"\n    :aria-hidden=\"ariaHidden\"\n    :role=\"role\"\n    :focusable=\"focusable\"\n  >\n    <slot name=\"title\"></slot>\n    <use v-bind=\"{ 'xlink:href': iconHref }\"></use>\n  </svg>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { PREFIX_SEPARATOR } from '@/utils/constants.js'\n\nconst prefixSeparator = inject('vueUswds.prefixSeparator', PREFIX_SEPARATOR)\n\nconst props = defineProps({\n  color: {\n    type: String,\n    default: '',\n  },\n  size: {\n    type: [String, Object],\n    default: '',\n    validator(size) {\n      let isValidSize = false\n      const validSizes = ['', '2xs', 'xs', 'sm', 'md', 'lg', 'xl', '2xl']\n\n      if (typeof size === 'string') {\n        isValidSize = validSizes.includes(size)\n      }\n\n      if (typeof size === 'object') {\n        isValidSize = Object.values(size).some(breakpointSize =>\n          validSizes.includes(breakpointSize)\n        )\n      }\n\n      if (!isValidSize) {\n        console.warn(`'${size}' is not a valid icon list size`)\n      }\n\n      return isValidSize\n    },\n  },\n})\n\nconst sizeClasses = computed(() => {\n  if (!!props.size && typeof props.size === 'string') {\n    return [`usa-icon-list--size-${props.size}`]\n  }\n\n  if (typeof props.size === 'object' && Object.keys(props.size).length) {\n    return Object.keys(props.size).reduce((acc, breakpoint) => {\n      acc.push(\n        `${breakpoint}${prefixSeparator}usa-icon-list--size-${props.size[breakpoint]}`\n      )\n\n      return acc\n    }, [])\n  }\n\n  return []\n})\n\nconst classes = computed(() => [\n  { [`usa-icon-list--${props.color}`]: props.color },\n  ...sizeClasses.value,\n])\n</script>\n\n<template>\n  <ul class=\"usa-icon-list\" :class=\"classes\"\n    ><slot></slot\n  ></ul>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport BaseLink from '@/components/BaseLink'\n\nconst props = defineProps({\n  alt: {\n    type: Boolean,\n    default: false,\n  },\n  external: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-link--alt': props.alt,\n    'usa-link--external': props.external,\n  },\n])\n</script>\n\n<template>\n  <BaseLink class=\"usa-link\" :class=\"classes\"><slot></slot></BaseLink>\n</template>\n", "import { defineComponent, ref, watch, onScopeDispose, h } from 'vue-demi';\nimport { createFocusTrap } from 'focus-trap';\nimport { unrefElement } from '@vueuse/core';\n\nconst UseFocusTrap = defineComponent({\n  name: \"UseFocusTrap\",\n  props: [\"as\", \"options\"],\n  setup(props, { slots }) {\n    let trap;\n    const target = ref();\n    const activate = () => trap && trap.activate();\n    const deactivate = () => trap && trap.deactivate();\n    watch(() => unrefElement(target), (el) => {\n      if (!el)\n        return;\n      trap = createFocusTrap(el, props.options || {});\n      activate();\n    }, { flush: \"post\" });\n    onScopeDispose(() => deactivate());\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default());\n    };\n  }\n});\n\nexport { UseFocusTrap };\n", "<script setup>\nimport { inject } from 'vue'\nimport { SVG_SPRITE_PATH } from '@/utils/constants.js'\n\nconst svgSpritePath = inject('vueUswds.svgSpritePath', SVG_SPRITE_PATH)\n\ndefineProps({\n  ariaLabel: {\n    type: String,\n    required: true,\n  },\n})\n</script>\n\n<template>\n  <button\n    type=\"button\"\n    class=\"usa-button usa-modal__close\"\n    :aria-label=\"ariaLabel\"\n  >\n    <slot :svg-sprite-path=\"svgSpritePath\">\n      <svg\n        v-if=\"svgSpritePath\"\n        class=\"usa-icon\"\n        aria-hidden=\"true\"\n        focusable=\"false\"\n        role=\"img\"\n      >\n        <use v-bind=\"{ 'xlink:href': `${svgSpritePath}#close` }\"></use>\n      </svg>\n    </slot>\n  </button>\n</template>\n", "<script setup>\nimport { computed, watch, ref, useSlots, onBeforeUnmount } from 'vue'\nimport { onKeyStroke, onClickOutside } from '@vueuse/core'\nimport { UseFocusTrap } from '@vueuse/integrations/useFocusTrap/component'\nimport { nextId } from '@/utils/unique-id.js'\nimport BaseHeading from '@/components/BaseHeading'\nimport UsaModalCloseButton from '@/components/UsaModalCloseButton'\n\nconst slots = useSlots()\n\nif (slots?.closeButton) {\n  console.warn(\n    `The 'closeButton' slot is deprecated, use 'close-button' instead.`\n  )\n}\n\nconst emit = defineEmits(['update:visible'])\n\nconst props = defineProps({\n  size: {\n    type: String,\n    default: '',\n    validator(size) {\n      const isValidSize = ['', 'lg'].includes(size)\n\n      if (!isValidSize) {\n        console.warn(`'${size}' is not a valid modal size`)\n      }\n\n      return isValidSize\n    },\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  visible: {\n    type: Boolean,\n    default: false,\n  },\n  forceAction: {\n    type: Boolean,\n    default: false,\n  },\n  closeButtonLabel: {\n    type: String,\n    default: 'Close this window',\n  },\n  heading: {\n    type: String,\n    default: '',\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        focusTrap: [],\n        modal: [],\n        overlay: [],\n        content: [],\n        main: [],\n        heading: [],\n        description: [],\n        footer: [],\n      }\n    },\n  },\n})\n\nconst modal = ref(null)\n\nconst isVisible = computed({\n  get: () => props.visible,\n  set: currentlyVisibility => emit('update:visible', currentlyVisibility),\n})\nconst classes = computed(() => {\n  return [{ 'is-visible': isVisible.value }]\n})\nconst modalClasses = computed(() => {\n  return [{ 'usa-modal--lg': props.size === 'lg' }, props.customClasses?.modal]\n})\nconst computedId = computed(() => props.id || nextId('usa-modal'))\nconst headingId = `${computedId.value}-heading`\nconst descriptionId = `${computedId.value}-description`\n\nconst modalBodyClass = 'usa-js-modal--active'\nconst noClickBodyClass = 'usa-js-no-click'\nconst focusTrapClass = 'js-focus-trap-wrapper'\n\nwatch(\n  () => isVisible,\n  currentlyVisible => {\n    if (currentlyVisible.value) {\n      document.body.classList.add(modalBodyClass)\n\n      document\n        .querySelectorAll(`body > :not(.${focusTrapClass})`)\n        .forEach(element => element.setAttribute('aria-hidden', true))\n\n      if (props.forceAction) {\n        document.body.classList.add(noClickBodyClass)\n      }\n    } else {\n      document.body.classList.remove(modalBodyClass)\n\n      document\n        .querySelectorAll(`body > :not(${focusTrapClass})`)\n        .forEach(element => element.removeAttribute('aria-hidden', true))\n\n      if (props.forceAction) {\n        document.body.classList.remove(noClickBodyClass)\n      }\n    }\n  },\n  {\n    immediate: true,\n    deep: true,\n  }\n)\n\nonBeforeUnmount(() => {\n  document.body.classList.remove(modalBodyClass)\n\n  document\n    .querySelectorAll(`body > :not(.${focusTrapClass})`)\n    .forEach(element => element.removeAttribute('aria-hidden', true))\n\n  if (props.forceAction) {\n    document.body.classList.remove(noClickBodyClass)\n  }\n})\n\nonKeyStroke('Escape', () => {\n  if (isVisible.value && !props.forceAction) {\n    isVisible.value = false\n  }\n})\n\nonClickOutside(modal, () => {\n  if (isVisible.value && !props.forceAction) {\n    isVisible.value = false\n  }\n})\n</script>\n\n<template>\n  <teleport to=\"body\">\n    <UseFocusTrap\n      v-if=\"isVisible\"\n      :class=\"[`${focusTrapClass}`, customClasses?.focusTrap]\"\n    >\n      <div\n        v-bind=\"$attrs\"\n        :id=\"`${computedId}-modal`\"\n        class=\"usa-modal-wrapper\"\n        :class=\"classes\"\n        role=\"dialog\"\n        :aria-labelledby=\"$slots.heading || heading ? headingId : null\"\n        :aria-describedby=\"$slots.default ? descriptionId : null\"\n      >\n        <div class=\"usa-modal-overlay\" :class=\"customClasses?.overlay\">\n          <div\n            ref=\"modal\"\n            class=\"usa-modal\"\n            :class=\"modalClasses\"\n            tabindex=\"-1\"\n          >\n            <div class=\"usa-modal__content\" :class=\"customClasses?.content\">\n              <div class=\"usa-modal__main\" :class=\"customClasses?.main\">\n                <BaseHeading\n                  v-if=\"$slots.heading || heading\"\n                  :id=\"headingId\"\n                  :tag=\"headingTag\"\n                  class=\"usa-modal__heading\"\n                  :class=\"customClasses?.heading\"\n                >\n                  <slot name=\"heading\">{{ heading }}</slot>\n                </BaseHeading>\n                <div\n                  v-if=\"$slots.default\"\n                  :id=\"descriptionId\"\n                  :class=\"customClasses?.description\"\n                  ><slot></slot\n                ></div>\n                <div\n                  v-if=\"$slots.footer\"\n                  class=\"usa-modal__footer\"\n                  :class=\"customClasses?.footer\"\n                >\n                  <slot name=\"footer\"></slot>\n                </div>\n              </div>\n              <slot v-if=\"$slots['close-button']\" name=\"close-button\"></slot>\n              <!--\n              \t@slot closeButton\n            \t\t@deprecated Use the `close-button` slot instead.\n            \t-->\n              <slot v-else-if=\"$slots.closeButton\" name=\"closeButton\"></slot>\n              <template v-else>\n                <UsaModalCloseButton\n                  v-if=\"!forceAction\"\n                  :aria-label=\"closeButtonLabel\"\n                  @click=\"isVisible = false\"\n                ></UsaModalCloseButton>\n              </template>\n            </div>\n          </div>\n        </div>\n      </div>\n    </UseFocusTrap>\n  </teleport>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  visible: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst classes = computed(() => [{ 'is-visible': props.visible }])\n</script>\n\n<template>\n  <div class=\"usa-overlay\" :class=\"classes\"></div>\n</template>\n", "<script setup>\nimport { computed, ref, watch, onBeforeUnmount, nextTick, inject, h } from 'vue'\nimport { IMAGE_PATH, MOBILE_MENU_BREAKPOINT } from '@/utils/constants.js'\nimport { onKeyStroke, onClickOutside, useMediaQuery } from '@vueuse/core'\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport UsaOverlay from '@/components/UsaOverlay'\n\nconst imagePath = inject('vueUswds.imagePath', IMAGE_PATH)\nconst mobileMenuBreakpoint = inject(\n  'vueUswds.mobileMenuBreakpoint',\n  MOBILE_MENU_BREAKPOINT\n)\nconst isExtendedHeader = inject('isExtendedHeader', ref(false))\nconst isMobileMenuOpen = inject('isMobileMenuOpen', ref(false))\nconst mobileMenuId = inject('mobileMenuId')\nconst closeMobileMenu = inject('closeMobileMenu')\n\ndefineProps({\n  ariaLabel: {\n    type: String,\n    default: 'Primary navigation',\n  },\n  closeButtonLabel: {\n    type: String,\n    default: 'Close',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        button: [],\n      }\n    },\n  },\n})\n\nconst nav = ref(null)\nconst { activate, deactivate } = useFocusTrap(nav)\nconst largeScreen = useMediaQuery(`(min-width: ${mobileMenuBreakpoint})`)\n\nwatch(isMobileMenuOpen, async isMenuOpen => {\n  if (isMenuOpen) {\n    await nextTick\n    activate()\n  } else {\n    await nextTick\n    deactivate()\n  }\n})\n\nwatch(largeScreen, isLargeScreen => {\n  if (isLargeScreen) {\n    closeMobileMenu()\n  }\n})\n\nonBeforeUnmount(() => {\n  if (isMobileMenuOpen.value) {\n    closeMobileMenu()\n  }\n})\n\nonKeyStroke('Escape', () => {\n  if (isMobileMenuOpen.value) {\n    closeMobileMenu()\n  }\n})\n\nonClickOutside(nav, () => {\n  if (isMobileMenuOpen.value) {\n    closeMobileMenu()\n  }\n})\n\nconst classes = computed(() => [\n  {\n    'is-visible': isMobileMenuOpen.value,\n  },\n])\n\nconst UsaNavInnerComponent = {\n  name: 'UsaNavInner',\n  props: {\n    wrap: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup({ wrap }, { slots }) {\n    return () =>\n      wrap\n        ? h('div', { class: 'usa-nav__inner' }, slots.default())\n        : slots.default()\n  },\n}\n</script>\n\n<template>\n  <Teleport to=\"body\" :disabled=\"!isMobileMenuOpen\">\n    <UsaOverlay :visible=\"isMobileMenuOpen\"></UsaOverlay>\n    <nav\n      :id=\"mobileMenuId\"\n      ref=\"nav\"\n      :aria-label=\"ariaLabel\"\n      class=\"usa-nav\"\n      :class=\"classes\"\n    >\n      <UsaNavInnerComponent :wrap=\"isExtendedHeader\">\n        <button\n          type=\"button\"\n          class=\"usa-nav__close\"\n          :class=\"customClasses?.button\"\n          @click=\"closeMobileMenu\"\n        >\n          <slot name=\"close-button\" :close-button-label=\"closeButtonLabel\"\n            ><img\n              :src=\"`${imagePath}/usa-icons/close.svg`\"\n              role=\"img\"\n              :alt=\"closeButtonLabel\"\n          /></slot>\n        </button>\n        <template v-if=\"largeScreen\">\n          <slot name=\"primary\"></slot>\n          <slot name=\"secondary\"></slot>\n        </template>\n        <template v-else>\n          <slot name=\"secondary\"></slot>\n          <slot name=\"primary\"></slot>\n        </template>\n      </UsaNavInnerComponent>\n    </nav>\n  </Teleport>\n</template>\n", "<script setup>\nimport { computed, inject, provide, onBeforeUnmount } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\n\nconst registerDropdown = inject('registerDropdown')\nconst unregisterDropdown = inject('unregisterDropdown')\n\nconst props = defineProps({\n  id: {\n    type: String,\n    default: '',\n  },\n  open: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst dropdownId = computed(() => props.id || nextId('usa-nav-dropdown'))\n\nregisterDropdown(dropdownId.value, props.open)\n\nprovide('dropdownId', dropdownId)\n\nonBeforeUnmount(() => {\n  unregisterDropdown(dropdownId.value)\n})\n</script>\n\n<template>\n  <li class=\"usa-nav__primary-item\">\n    <slot></slot>\n  </li>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { inject, toRef } from 'vue'\nimport { ROUTER_COMPONENT_NAME } from '@/utils/constants.js'\n\nconst routerComponentName = inject(\n  'vueUswds.routerComponentName',\n  ROUTER_COMPONENT_NAME\n)\nconst dropdownId = inject('dropdownId')\nconst toggleDropdown = inject('toggleDropdown')\nconst dropdownItems = inject('dropdownItems')\n\nconst isOpen = toRef(dropdownItems, dropdownId.value)\n</script>\n\n<template>\n  <component\n    :is=\"routerComponentName\"\n    v-if=\"routerComponentName\"\n    v-slot=\"{ isActive, isExactActive }\"\n    custom\n  >\n    <button\n      v-bind=\"$attrs\"\n      type=\"button\"\n      class=\"usa-accordion__button usa-nav__link\"\n      :class=\"[{ 'usa-current': isActive || isExactActive }]\"\n      :aria-expanded=\"isOpen\"\n      :aria-controls=\"dropdownId\"\n      @click=\"toggleDropdown(dropdownId)\"\n    >\n      <span><slot></slot></span>\n    </button>\n  </component>\n  <button\n    v-else\n    v-bind=\"$attrs\"\n    type=\"button\"\n    class=\"usa-accordion__button usa-nav__link\"\n    :aria-expanded=\"isOpen\"\n    :aria-controls=\"dropdownId\"\n    @click=\"toggleDropdown(dropdownId)\"\n  >\n    <span><slot></slot></span>\n  </button>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { inject } from 'vue'\nimport BaseLink from '@/components/BaseLink'\n\nconst closeAllDropdowns = inject('closeAllDropdowns')\nconst closeMobileMenu = inject('closeMobileMenu')\n\ndefineProps({\n  href: {\n    type: String,\n    default: '',\n  },\n  to: {\n    type: [String, Object],\n    default: '',\n  },\n  routerComponentName: {\n    type: String,\n    default: '',\n  },\n})\n</script>\n\n<template>\n  <li class=\"usa-nav__primary-item\">\n    <BaseLink\n      v-bind=\"$attrs\"\n      class=\"usa-nav__link\"\n      :href=\"href\"\n      :to=\"to\"\n      :router-component-name=\"routerComponentName\"\n      @click=\"closeAllDropdowns(), closeMobileMenu()\"\n    >\n      <span><slot></slot></span>\n    </BaseLink>\n  </li>\n</template>\n", "<script setup>\nimport { computed, ref, inject, toRef } from 'vue'\nimport { GRID_NAMESPACE } from '@/utils/constants.js'\n\nconst gridNamespace = inject('vueUswds.gridNamespace', GRID_NAMESPACE)\nconst isMegamenu = inject('isMegamenu', ref(false))\nconst dropdownId = inject('dropdownId')\nconst dropdownItems = inject('dropdownItems')\n\nconst props = defineProps({\n  cols: {\n    type: Number,\n    default: 1,\n    validator(columnCount) {\n      const isValidColumnCount = columnCount >= 1\n\n      if (!isValidColumnCount) {\n        console.warn('Column count must be greater than or equal to 1')\n      }\n\n      return isValidColumnCount\n    },\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        gridRow: [],\n        gridCol: [],\n      }\n    },\n  },\n})\n\nconst classes = computed(() => [{ 'usa-megamenu': isMegamenu.value }])\n\nconst gridClasses = computed(() => [\n  `${gridNamespace}row`,\n  `${gridNamespace}gap-4`,\n  ...(props.customClasses?.gridRow || []),\n])\n\nconst isOpen = toRef(dropdownItems, dropdownId.value)\n</script>\n\n<template>\n  <div\n    v-if=\"isMegamenu\"\n    :id=\"dropdownId\"\n    class=\"usa-nav__submenu\"\n    :class=\"classes\"\n    :hidden=\"!isOpen\"\n  >\n    <div :class=\"gridClasses\">\n      <template v-if=\"cols > 1\">\n        <div\n          v-for=\"col in cols\"\n          :key=\"col\"\n          class=\"usa-col\"\n          :class=\"customClasses?.gridCol\"\n        >\n          <ul class=\"usa-nav__submenu-list\">\n            <slot :name=\"`col-${col}`\"></slot>\n          </ul>\n        </div>\n      </template>\n      <div v-else class=\"usa-col\" :class=\"customClasses?.gridCol\">\n        <ul class=\"usa-nav__submenu-list\">\n          <slot></slot>\n        </ul>\n      </div>\n    </div>\n  </div>\n  <ul\n    v-else\n    :id=\"dropdownId\"\n    class=\"usa-nav__submenu\"\n    :class=\"classes\"\n    :hidden=\"!isOpen\"\n  >\n    <slot></slot>\n  </ul>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { inject } from 'vue'\nimport BaseLink from '@/components/BaseLink'\n\nconst dropdownId = inject('dropdownId')\nconst closeDropdown = inject('closeDropdown')\nconst closeMobileMenu = inject('closeMobileMenu')\n\ndefineProps({\n  href: {\n    type: String,\n    default: '',\n  },\n  to: {\n    type: [String, Object],\n    default: '',\n  },\n  routerComponentName: {\n    type: String,\n    default: '',\n  },\n})\n</script>\n\n<template>\n  <li class=\"usa-nav__submenu-item\">\n    <BaseLink\n      v-bind=\"$attrs\"\n      :href=\"href\"\n      :to=\"to\"\n      :router-component-name=\"routerComponentName\"\n      @click=\"closeDropdown(dropdownId), closeMobileMenu()\"\n      ><slot></slot\n    ></BaseLink>\n  </li>\n</template>\n", "<script setup>\nimport { ref, computed, reactive, watch, provide, inject } from 'vue'\nimport { MOBILE_MENU_BREAKPOINT } from '@/utils/constants.js'\nimport { onKeyStroke, useMediaQuery, onClickOutside } from '@vueuse/core'\nimport useAccordion from '@/composables/useAccordion.js'\nimport UsaNavPrimaryItem from '@/components/UsaNavPrimaryItem'\nimport UsaNavDropdown from '@/components/UsaNavDropdown'\nimport UsaNavDropdownButton from '@/components/UsaNavDropdownButton'\nimport UsaNavSubmenu from '@/components/UsaNavSubmenu'\nimport UsaNavSubmenuItem from '@/components/UsaNavSubmenuItem'\n\nconst mobileMenuBreakpoint = inject(\n  'vueUswds.mobileMenuBreakpoint',\n  MOBILE_MENU_BREAKPOINT\n)\nconst isMegamenu = inject('isMegamenu', ref(false))\n\nconst emit = defineEmits(['update:items'])\n\ndefineProps({\n  items: {\n    type: Array,\n    default: () => [],\n  },\n})\n\nconst nav = ref(null)\nconst largeScreen = useMediaQuery(`(min-width: ${mobileMenuBreakpoint})`)\nconst isMultiSelectable = computed(() => !largeScreen.value)\nconst dropdownItems = reactive({})\n\nconst {\n  registerAccordionItem,\n  unregisterAccordionItem,\n  closeItem,\n  toggleItem,\n  closeAllItems,\n} = useAccordion(dropdownItems, isMultiSelectable)\n\nwatch(dropdownItems, () => {\n  emit('update:items', dropdownItems)\n})\n\nwatch(largeScreen, closeAllItems)\n\nprovide('registerDropdown', registerAccordionItem)\nprovide('unregisterDropdown', unregisterAccordionItem)\nprovide('toggleDropdown', toggleItem)\nprovide('closeDropdown', closeItem)\nprovide('closeAllDropdowns', closeAllItems)\nprovide('dropdownItems', dropdownItems)\n\nonKeyStroke('Escape', closeAllItems)\n\nonClickOutside(nav, closeAllItems)\n</script>\n\n<template>\n  <ul ref=\"nav\" class=\"usa-nav__primary usa-accordion\">\n    <slot :items=\"items\">\n      <template v-for=\"item in items\">\n        <UsaNavDropdown\n          v-if=\"item?.children?.length\"\n          :key=\"item?.id || item.text\"\n        >\n          <UsaNavDropdownButton v-bind=\"item?.attrs\">{{\n            item.text\n          }}</UsaNavDropdownButton>\n          <UsaNavSubmenu\n            v-if=\"item?.cols > 1 && isMegamenu\"\n            :key=\"item.children.map(item => item?.id || item.text)\"\n            :cols=\"item.cols\"\n          >\n            <template v-for=\"n in item.cols\" :key=\"n\" #[`col-${n}`]>\n              <template v-for=\"submenuItem in item.children\">\n                <UsaNavSubmenuItem\n                  v-if=\"submenuItem?.col === n\"\n                  v-bind=\"submenuItem?.attrs\"\n                  :key=\"submenuItem?.id || submenuItem.text\"\n                  :href=\"submenuItem?.href\"\n                  :to=\"submenuItem?.to\"\n                  :router-component-name=\"submenuItem?.routerComponentName\"\n                  >{{ submenuItem.text }}</UsaNavSubmenuItem\n                >\n              </template>\n            </template>\n          </UsaNavSubmenu>\n          <template v-else>\n            <UsaNavSubmenu\n              :key=\"item.children.map(item => item?.id || item.text)\"\n            >\n              <UsaNavSubmenuItem\n                v-for=\"submenuItem in item.children\"\n                v-bind=\"submenuItem?.attrs\"\n                :key=\"submenuItem?.id || submenuItem.text\"\n                :href=\"submenuItem?.href\"\n                :to=\"submenuItem?.to\"\n                :router-component-name=\"submenuItem?.routerComponentName\"\n                >{{ submenuItem.text }}</UsaNavSubmenuItem\n              >\n            </UsaNavSubmenu>\n          </template>\n        </UsaNavDropdown>\n        <template v-else>\n          <UsaNavPrimaryItem\n            :key=\"item?.id || item.text\"\n            v-bind=\"item?.attrs\"\n            :href=\"item?.href\"\n            :to=\"item?.to\"\n            :router-component-name=\"item?.routerComponentName\"\n            >{{ item.text }}</UsaNavPrimaryItem\n          >\n        </template>\n      </template>\n    </slot>\n  </ul>\n</template>\n", "<script setup>\nimport { inject } from 'vue'\nimport BaseLink from '@/components/BaseLink'\n\nconst isExtendedHeader = inject('isExtendedHeader', false)\n\ndefineProps({\n  items: {\n    type: Array,\n    default: () => [],\n  },\n})\n</script>\n\n<template>\n  <div v-if=\"isExtendedHeader\" class=\"usa-nav__secondary\">\n    <ul class=\"usa-nav__secondary-links\">\n      <slot :items=\"items\">\n        <li\n          v-for=\"item in items\"\n          :key=\"item?.id || item.text\"\n          class=\"usa-nav__secondary-item\"\n        >\n          <BaseLink\n            :to=\"item.to\"\n            :href=\"item.href\"\n            :router-component-name=\"item.routerComponentName\"\n            >{{ item.text }}</BaseLink\n          >\n        </li>\n      </slot>\n    </ul>\n    <slot name=\"search\"></slot>\n  </div>\n  <slot v-else name=\"search\"></slot>\n</template>\n", "import { ref, readonly } from 'vue'\n\nconst isMobileMenuOpen = ref(false)\nconst menuId = ref('__vuswds-id-global-mobile-header-menu')\n\nexport default emit => {\n  const mobileMenuOpenClass = 'usa-js-mobile-nav--active'\n\n  const closeMobileMenu = () => {\n    isMobileMenuOpen.value = false\n\n    if (emit) {\n      emit('mobileMenuOpen', false)\n    }\n\n    document.body.classList.remove(mobileMenuOpenClass)\n    document\n      .querySelectorAll('body > :not(.usa-nav)')\n      .forEach(element => element.removeAttribute('aria-hidden', true))\n  }\n\n  const openMobileMenu = () => {\n    isMobileMenuOpen.value = true\n\n    if (emit) {\n      emit('mobileMenuOpen', true)\n    }\n\n    document.body.classList.add(mobileMenuOpenClass)\n    document\n      .querySelectorAll('body > :not(.usa-nav)')\n      .forEach(element => element.setAttribute('aria-hidden', true))\n  }\n\n  const toggleMobileMenu = () => {\n    if (isMobileMenuOpen.value) {\n      closeMobileMenu()\n    } else {\n      openMobileMenu()\n    }\n  }\n\n  return {\n    isMobileMenuOpen: readonly(isMobileMenuOpen),\n    mobileMenuId: readonly(menuId),\n    closeMobileMenu: closeMobileMenu,\n    openMobileMenu: openMobileMenu,\n    toggleMobileMenu: toggleMobileMenu,\n  }\n}\n", "<script setup>\nimport { provide } from 'vue'\nimport useMobileMenu from '@/composables/useMobileMenu.js'\n\nconst emit = defineEmits(['mobileMenuOpen'])\n\ndefineProps({\n  menuButtonLabel: {\n    type: String,\n    default: 'Menu',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        button: [],\n      }\n    },\n  },\n})\n\nconst {\n  isMobileMenuOpen,\n  mobileMenuId,\n  closeMobileMenu,\n  openMobileMenu,\n  toggleMobileMenu,\n} = useMobileMenu(emit)\n\nprovide('isMobileMenuOpen', isMobileMenuOpen)\nprovide('mobileMenuId', mobileMenuId)\nprovide('closeMobileMenu', closeMobileMenu)\nprovide('openMobileMenu', openMobileMenu)\nprovide('toggleMobileMenu', toggleMobileMenu)\n</script>\n\n<template>\n  <div class=\"usa-navbar\">\n    <slot></slot>\n    <button\n      type=\"button\"\n      class=\"usa-menu-btn\"\n      :class=\"customClasses?.button\"\n      :aria-controls=\"mobileMenuId\"\n      @click=\"toggleMobileMenu\"\n      ><slot name=\"menu-button\" :menu-button-label=\"menuButtonLabel\">{{\n        menuButtonLabel\n      }}</slot></button\n    >\n  </div>\n</template>\n", "import { ref, computed, readonly } from 'vue'\n\nexport default (_currentPage, totalPages, _unbounded, emit) => {\n  const currentPage = ref(_currentPage)\n  const unbounded = ref(_unbounded)\n\n  const pageRange = computed(() => {\n    const range = []\n\n    for (let i = 1; i <= totalPages.value; i++) {\n      range.push(i)\n    }\n\n    return range\n  })\n\n  const visiblePageRange = computed(() => {\n    // If there are less that seven pages we can just show all of them.\n    if (totalPages.value <= 7) {\n      return pageRange.value\n    }\n\n    // If the current page is <= 5, show all the starting pages.\n    if (currentPage.value - 3 <= 1) {\n      const range = pageRange.value.slice(0, 7)\n\n      // Always set the last slot to show the last page.\n      range[range.length - 1] = totalPages.value\n\n      return range\n    }\n\n    // If the current page is <= (totalPages - 3), show all the ending pages.\n    if (currentPage.value + 3 >= totalPages.value) {\n      const range = pageRange.value.slice(\n        totalPages.value - 7,\n        totalPages.value\n      )\n\n      // Always set the first slot to show the first page.\n      range[0] = 1\n\n      return range\n    }\n\n    // If we aren't at the start or end, show the pages surrounding\n    // the current page.\n    const range = pageRange.value.slice(\n      currentPage.value - 4,\n      currentPage.value + 3\n    )\n\n    // If in bounded mode, always set the last slot to show the last page.\n    if (!unbounded.value) {\n      range[range.length - 1] = totalPages.value\n    }\n\n    // Always set the first slot to show the first page.\n    range[0] = 1\n\n    return range\n  })\n\n  const isFirstPage = computed(() => {\n    return currentPage.value === 1\n  })\n\n  const isLastPage = computed(() => {\n    return currentPage.value === totalPages.value\n  })\n\n  const isOverflowSlot = index => {\n    if (totalPages.value <= 7) {\n      return false\n    }\n\n    if (\n      (index === 1 && currentPage.value > 4) ||\n      (!unbounded.value &&\n        index === 5 &&\n        totalPages.value - currentPage.value > 3) ||\n      (unbounded.value && index === 6 && currentPage.value !== totalPages.value)\n    ) {\n      return true\n    }\n  }\n\n  const updateCurrentPage = number => {\n    emit('update:currentPage', number)\n  }\n\n  const toFirstPage = () => {\n    updateCurrentPage(1)\n  }\n\n  const toPreviousPage = () => {\n    updateCurrentPage(currentPage.value - 1)\n  }\n\n  const toNextPage = () => {\n    updateCurrentPage(currentPage.value + 1)\n  }\n\n  const toLastPage = () => {\n    updateCurrentPage(totalPages.value)\n  }\n\n  return {\n    currentPage: readonly(currentPage),\n    unbounded: readonly(unbounded),\n    totalPages,\n    isFirstPage,\n    isLastPage,\n    isOverflowSlot,\n    toFirstPage,\n    toLastPage,\n    toNextPage,\n    toPreviousPage,\n    updateCurrentPage,\n    visiblePageRange,\n  }\n}\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { SVG_SPRITE_PATH } from '@/utils/constants.js'\nimport BaseLink from '@/components/BaseLink'\n\nconst svgSpritePath = inject('vueUswds.svgSpritePath', SVG_SPRITE_PATH)\n\nconst props = defineProps({\n  direction: {\n    type: String,\n    default: 'previous',\n    validator(direction) {\n      return ['previous', 'next'].includes(direction)\n    },\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  ariaLabel: {\n    type: String,\n    required: true,\n  },\n  href: {\n    type: String,\n    default: undefined,\n  },\n  to: {\n    type: [String, Object],\n    default: undefined,\n  },\n  routerComponentName: {\n    type: String,\n    default: undefined,\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        link: [],\n        text: [],\n      }\n    },\n  },\n})\n\nconst componentTag = computed(() =>\n  props.routerComponentName || props.to || props.href ? BaseLink : 'button'\n)\n\nconst classes = computed(() => [\n  {\n    'usa-pagination__previous-page': props.direction === 'previous',\n    'usa-pagination__next-page': props.direction === 'next',\n    'usa-button--unstyled': componentTag.value === 'button',\n  },\n  props.customClasses.link,\n])\n</script>\n\n<template>\n  <li class=\"usa-pagination__item usa-pagination__arrow\">\n    <component\n      :is=\"componentTag\"\n      :href=\"href\"\n      :to=\"to\"\n      :router-component-name=\"routerComponentName\"\n      :aria-label=\"ariaLabel\"\n      :class=\"classes\"\n      class=\"usa-pagination__link\"\n    >\n      <slot\n        v-if=\"direction === 'previous'\"\n        name=\"before\"\n        :svg-sprite-path=\"svgSpritePath\"\n      >\n        <svg\n          v-if=\"svgSpritePath\"\n          class=\"usa-icon\"\n          aria-hidden=\"true\"\n          role=\"img\"\n        >\n          <use\n            v-bind=\"{ 'xlink:href': `${svgSpritePath}#navigate_before` }\"\n          ></use>\n        </svg>\n      </slot>\n      <span class=\"usa-pagination__link-text\" :class=\"customClasses?.text\"\n        ><slot>{{ label }}</slot></span\n      >\n      <slot\n        v-if=\"direction === 'next'\"\n        name=\"after\"\n        :svg-sprite-path=\"svgSpritePath\"\n      >\n        <svg\n          v-if=\"svgSpritePath\"\n          class=\"usa-icon\"\n          aria-hidden=\"true\"\n          role=\"img\"\n        >\n          <use\n            v-bind=\"{ 'xlink:href': `${svgSpritePath}#navigate_next` }\"\n          ></use>\n        </svg>\n      </slot>\n    </component>\n  </li>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport BaseLink from '@/components/BaseLink'\n\nconst props = defineProps({\n  pageNumber: {\n    type: Number,\n    required: true,\n    validator(pageNumber) {\n      return pageNumber > 0\n    },\n  },\n  isCurrentPage: {\n    type: Boolean,\n    default: false,\n  },\n  ariaLabel: {\n    type: String,\n    required: true,\n  },\n  href: {\n    type: String,\n    default: undefined,\n  },\n  to: {\n    type: [String, Object],\n    default: undefined,\n  },\n  routerComponentName: {\n    type: String,\n    default: undefined,\n  },\n})\n\nconst componentTag = computed(() =>\n  props.routerComponentName || props.to || props.href ? BaseLink : 'button'\n)\n\nconst ariaCurrent = computed(() => (props.isCurrentPage ? 'page' : null))\n\nconst classes = computed(() => [\n  {\n    'usa-current': props.isCurrentPage,\n    'usa-button--unstyled': componentTag.value === 'button',\n  },\n])\n</script>\n\n<template>\n  <li class=\"usa-pagination__item usa-pagination__page-no\">\n    <component\n      :is=\"componentTag\"\n      :href=\"href\"\n      :to=\"to\"\n      :router-component-name=\"routerComponentName\"\n      :aria-label=\"ariaLabel\"\n      :aria-current=\"ariaCurrent\"\n      :class=\"classes\"\n      class=\"usa-pagination__button\"\n      ><slot>{{ pageNumber }}</slot></component\n    >\n  </li>\n</template>\n", "<script setup>\nimport { computed, toRef, useSlots } from 'vue'\nimport usePagination from '@/composables/usePagination.js'\nimport UsaPaginationArrow from '@/components/UsaPaginationArrow'\nimport UsaPaginationItem from '@/components/UsaPaginationItem'\n\nconst slots = useSlots()\n\nif (slots?.previousIcon) {\n  console.warn(\n    `The 'previousIcon' slot is deprecated, use 'previous-icon' instead.`\n  )\n}\n\nif (slots?.previousLabel) {\n  console.warn(\n    `The 'previousLabel' slot is deprecated, use 'previous-label' instead.`\n  )\n}\n\nif (slots?.nextIcon) {\n  console.warn(`The 'nextIcon' slot is deprecated, use 'next-icon' instead.`)\n}\n\nif (slots?.nextLabel) {\n  console.warn(`The 'nextLabel' slot is deprecated, use 'next-label' instead.`)\n}\n\nconst emit = defineEmits(['update:currentPage'])\n\nconst props = defineProps({\n  items: {\n    type: Array,\n    default: () => [],\n  },\n  unbounded: {\n    type: Boolean,\n    default: false,\n  },\n  currentPage: {\n    type: Number,\n    default: 1,\n    validator(currentPage) {\n      return currentPage > 0\n    },\n  },\n  ariaLabel: {\n    type: String,\n    default: 'Pagination',\n  },\n  previousLinkText: {\n    type: String,\n    default: 'Previous',\n  },\n  nextLinkText: {\n    type: String,\n    default: 'Next',\n  },\n  firstPageAriaLabel: {\n    type: String,\n    default: 'First page, page %s',\n  },\n  previousPageAriaLabel: {\n    type: String,\n    default: 'Previous page',\n  },\n  numberPageAriaLabel: {\n    type: String,\n    default: 'Page %s',\n  },\n  nextPageAriaLabel: {\n    type: String,\n    default: 'Next page',\n  },\n  lastPageAriaLabel: {\n    type: String,\n    default: 'Last page, page %s',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        list: [],\n      }\n    },\n  },\n})\n\nconst totalItems = computed(() => {\n  return props.items.length\n})\n\nconst {\n  currentPage,\n  totalPages,\n  isFirstPage,\n  isLastPage,\n  isOverflowSlot,\n  visiblePageRange,\n  toPreviousPage,\n  toNextPage,\n  updateCurrentPage,\n} = usePagination(\n  toRef(props, 'currentPage'),\n  totalItems,\n  toRef(props, 'unbounded'),\n  emit\n)\n\nfunction getAriaLabel(pageNumber) {\n  if (pageNumber === 1) {\n    if (props.firstPageAriaLabel.includes('#')) {\n      console.warn(`The '#' placeholder is deprecated, use '%s' instead.`)\n      return props.firstPageAriaLabel.replaceAll('#', pageNumber)\n    }\n    return props.firstPageAriaLabel.replaceAll('%s', pageNumber)\n  }\n\n  if (pageNumber === totalPages.value) {\n    if (props.lastPageAriaLabel.includes('#')) {\n      console.warn(`The '#' placeholder is deprecated, use '%s' instead.`)\n      return props.lastPageAriaLabel.replaceAll('#', pageNumber)\n    }\n    return props.lastPageAriaLabel.replaceAll('%s', pageNumber)\n  }\n\n  if (props.numberPageAriaLabel.includes('#')) {\n    console.warn(`The '#' placeholder is deprecated, use '%s' instead.`)\n    return props.numberPageAriaLabel.replaceAll('#', pageNumber)\n  }\n  return props.numberPageAriaLabel.replaceAll('%s', pageNumber)\n}\n</script>\n\n<template>\n  <nav :aria-label=\"ariaLabel\" class=\"usa-pagination\">\n    <ul class=\"usa-pagination__list\" :class=\"customClasses?.list\">\n      <slot\n        name=\"previous\"\n        :is-first-page=\"isFirstPage\"\n        :to-previous-page=\"toPreviousPage\"\n      >\n        <UsaPaginationArrow\n          v-show=\"!isFirstPage\"\n          direction=\"previous\"\n          :class=\"{ 'usa-pagination__item--hidden': isFirstPage }\"\n          :aria-label=\"previousPageAriaLabel\"\n          :href=\"items?.[currentPage - 2]?.href || null\"\n          :to=\"items?.[currentPage - 2]?.to || null\"\n          :router-component-name=\"\n            items?.[currentPage - 2]?.routerComponentName || null\n          \"\n          @click=\"toPreviousPage()\"\n        >\n          <template #before=\"{ svgSpritePath }\">\n            <slot v-if=\"$slots['previous-icon']\" name=\"previous-icon\"></slot>\n            <!--\n            \t@slot previousIcon\n          \t\t@deprecated Use the `previous-icon` slot instead.\n          \t-->\n            <slot v-else-if=\"$slots.previousIcon\" name=\"previousIcon\"></slot>\n            <template v-else>\n              <svg\n                v-if=\"svgSpritePath\"\n                class=\"usa-icon\"\n                aria-hidden=\"true\"\n                role=\"img\"\n              >\n                <use\n                  v-bind=\"{ 'xlink:href': `${svgSpritePath}#navigate_before}` }\"\n                ></use>\n              </svg>\n            </template>\n          </template>\n          <template #default>\n            <slot v-if=\"$slots['previous-label']\" name=\"previous-label\"></slot>\n            <!--\n            \t@slot previousLabel\n          \t\t@deprecated Use the `previous-label` slot instead.\n          \t-->\n            <slot v-else-if=\"$slots.previousLabel\" name=\"previousLabel\"></slot>\n            <template v-else>{{ previousLinkText }}</template>\n          </template>\n        </UsaPaginationArrow>\n      </slot>\n\n      <template\n        v-for=\"(pageNumber, index) in visiblePageRange\"\n        :key=\"pageNumber\"\n      >\n        <li\n          v-if=\"isOverflowSlot(index)\"\n          class=\"usa-pagination__item usa-pagination__overflow\"\n          role=\"presentation\"\n        >\n          <span>&hellip;</span>\n        </li>\n\n        <UsaPaginationItem\n          v-else\n          :page-number=\"pageNumber\"\n          :is-current-page=\"pageNumber === currentPage\"\n          :aria-label=\"getAriaLabel(pageNumber)\"\n          :href=\"items?.[index]?.href || null\"\n          :to=\"items?.[index]?.to || null\"\n          :router-component-name=\"items?.[index]?.routerComponentName || null\"\n          @click=\"updateCurrentPage(pageNumber)\"\n          >{{ pageNumber }}</UsaPaginationItem\n        >\n      </template>\n\n      <slot name=\"next\" :is-last-page=\"isLastPage\" :to-next-page=\"toNextPage\">\n        <UsaPaginationArrow\n          v-show=\"!isLastPage\"\n          direction=\"next\"\n          :class=\"{ 'usa-pagination__item--hidden': isLastPage }\"\n          :aria-label=\"nextPageAriaLabel\"\n          :href=\"items?.[currentPage]?.href || null\"\n          :to=\"items?.[currentPage]?.to || null\"\n          :router-component-name=\"\n            items?.[currentPage]?.routerComponentName || null\n          \"\n          @click=\"toNextPage()\"\n        >\n          <template #after=\"{ svgSpritePath }\">\n            <slot v-if=\"$slots['next-icon']\" name=\"next-icon\"></slot>\n            <!--\n            \t@slot nextIcon\n          \t\t@deprecated Use the `next-icon` slot instead.\n          \t-->\n            <slot v-else-if=\"$slots.nextIcon\" name=\"nextIcon\"></slot>\n            <template v-else>\n              <svg\n                v-if=\"svgSpritePath\"\n                class=\"usa-icon\"\n                aria-hidden=\"true\"\n                role=\"img\"\n              >\n                <use\n                  v-bind=\"{ 'xlink:href': `${svgSpritePath}#navigate_next}` }\"\n                ></use>\n              </svg>\n            </template>\n          </template>\n          <template #default>\n            <slot v-if=\"$slots['next-label']\" name=\"next-label\"></slot>\n            <!--\n            \t@slot nextLabel\n          \t\t@deprecated Use the `next-label` slot instead.\n          \t-->\n            <slot v-else-if=\"$slots.nextLabel\" name=\"nextLabel\"></slot>\n            <template v-else>{{ nextLinkText }}</template>\n          </template>\n        </UsaPaginationArrow>\n      </slot>\n    </ul>\n  </nav>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, ref, provide } from 'vue'\n\nconst props = defineProps({\n  showText: {\n    type: String,\n    default: 'Show password',\n  },\n  hideText: {\n    type: String,\n    default: 'Hide password',\n  },\n})\n\nconst isVisible = ref(false)\nconst inputIds = ref({})\n\nconst currentInputType = computed(() => {\n  return isVisible.value ? 'text' : 'password'\n})\n\nconst currentLabel = computed(() => {\n  return isVisible.value ? props.hideText : props.showText\n})\n\nconst ariaControls = computed(() => {\n  if (Object.keys(inputIds.value).length) {\n    return Object.keys(inputIds.value).join(' ')\n  }\n\n  return ''\n})\n\nconst registerInput = id => {\n  if (!inputIds.value[id]) {\n    inputIds.value[id] = true\n  }\n}\n\nconst unregisterInput = id => {\n  if (inputIds.value[id]) {\n    delete inputIds.value[id]\n  }\n}\n\nprovide('registerInput', registerInput)\nprovide('unregisterInput', unregisterInput)\n</script>\n\n<template>\n  <slot :type=\"currentInputType\"></slot>\n  <button\n    v-bind=\"$attrs\"\n    type=\"button\"\n    class=\"usa-show-password usa-button usa-button--unstyled\"\n    :aria-controls=\"ariaControls\"\n    :aria-pressed=\"isVisible\"\n    @click=\"isVisible = !isVisible\"\n    >{{ currentLabel }}</button\n  >\n</template>\n", "<script setup>\nimport { provide, computed } from 'vue'\n\nconst props = defineProps({\n  headingTag: {\n    type: String,\n    default: '',\n  },\n})\n\nprovide(\n  'listHeadingTag',\n  computed(() => props.headingTag)\n)\n</script>\n\n<template>\n  <ol class=\"usa-process-list\">\n    <slot></slot>\n  </ol>\n</template>\n", "<script setup>\nimport { inject, computed } from 'vue'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst listHeadingTag = inject('listHeadingTag')\n\nconst props = defineProps({\n  heading: {\n    type: String,\n    default: '',\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        heading: [],\n      }\n    },\n  },\n})\n\nconst computedHeadingTag = computed(\n  () => listHeadingTag.value || props.headingTag\n)\n</script>\n\n<template>\n  <li class=\"usa-process-list__item\">\n    <BaseHeading\n      v-if=\"heading || $slots.heading\"\n      class=\"usa-process-list__heading\"\n      :class=\"customClasses?.heading\"\n      :tag=\"computedHeadingTag\"\n      ><slot name=\"heading\">{{ heading }}</slot></BaseHeading\n    >\n    <slot></slot>\n  </li>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  tile: {\n    type: Boolean,\n    default: false,\n  },\n  modelValue: {\n    type: undefined,\n    default: '',\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  description: {\n    type: String,\n    default: '',\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        component: [],\n        label: [],\n        description: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-radio'))\n\nconst radioValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-radio__input--tile': props.tile,\n  },\n])\n</script>\n\n<template>\n  <div class=\"usa-radio\" :class=\"customClasses?.component\">\n    <input\n      v-bind=\"$attrs\"\n      :id=\"computedId\"\n      v-model=\"radioValue\"\n      class=\"usa-radio__input\"\n      type=\"radio\"\n      :class=\"classes\"\n    />\n    <label\n      :htmlFor=\"computedId\"\n      class=\"usa-radio__label\"\n      :class=\"customClasses?.label\"\n      ><slot>{{ label }}</slot>\n      <span\n        v-if=\"description || $slots.description\"\n        class=\"usa-radio__label-description\"\n        :class=\"customClasses?.description\"\n        ><slot name=\"description\">{{ description }}</slot></span\n      >\n    </label>\n  </div>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, useSlots } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport UsaFormGroup from '@/components/UsaFormGroup'\nimport UsaLabel from '@/components/UsaLabel'\n\nconst slots = useSlots()\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  min: {\n    type: Number,\n    default: 0,\n  },\n  max: {\n    type: Number,\n    default: 100,\n  },\n  modelValue: {\n    type: [String, Number],\n    default: '',\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        component: [],\n        label: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-range'))\nconst computedErrorMessageId = computed(\n  () => `${computedId.value}-error-message`\n)\nconst computedHintId = computed(() => `${computedId.value}-hint`)\n\nconst rangeValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  },\n})\n\nconst classes = computed(() => [{ 'usa-input--error': props.error }])\n\nconst ariaDescribedby = computed(() => {\n  const ids = []\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.length ? ids.join(' ') : null\n})\n</script>\n\n<template>\n  <UsaFormGroup\n    :group=\"!!$slots.hint || (error && !!$slots['error-message'])\"\n    :error=\"error\"\n    :class=\"props.customClasses?.component\"\n  >\n    <UsaLabel\n      v-if=\"label || $slots.label\"\n      :for=\"computedId\"\n      :required=\"required\"\n      :error=\"error\"\n      :class=\"customClasses?.label\"\n      ><slot name=\"label\">{{ label }}</slot></UsaLabel\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n\n    <input\n      v-bind=\"$attrs\"\n      :id=\"computedId\"\n      v-model=\"rangeValue\"\n      class=\"usa-range\"\n      :class=\"classes\"\n      type=\"range\"\n      role=\"slider\"\n      :min=\"min\"\n      :max=\"max\"\n      :aria-valuemin=\"min\"\n      :aria-valuemax=\"max\"\n      :aria-valuenow=\"rangeValue\"\n      :required=\"required\"\n      :aria-describedby=\"ariaDescribedby\"\n    />\n  </UsaFormGroup>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport { IMAGE_PATH } from '@/utils/constants.js'\nimport { nextId } from '@/utils/unique-id.js'\nimport UsaButton from '@/components/UsaButton'\nimport UsaTextInput from '@/components/UsaTextInput'\n\nconst imagePath = inject('vueUswds.imagePath', IMAGE_PATH)\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  variant: {\n    type: String,\n    default: 'medium',\n    validator(variant) {\n      const isValidVariantSize = ['small', 'medium', 'big'].includes(variant)\n\n      if (!isValidVariantSize) {\n        console.warn(`'${variant}' is not a valid search variant`)\n      }\n\n      return isValidVariantSize\n    },\n  },\n  modelValue: {\n    type: String,\n    default: '',\n  },\n  label: {\n    type: String,\n    default: 'Search',\n  },\n  buttonLabel: {\n    type: String,\n    default: 'Search',\n  },\n  inputAttrs: {\n    type: Object,\n    default: () => {},\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        label: ['usa-sr-only'],\n        input: [],\n        button: [],\n        icon: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-search'))\n\nconst classes = computed(() => [\n  {\n    'usa-search--small': props.variant === 'small',\n    'usa-search--medium': props.variant === 'medium',\n    'usa-search--big': props.variant === 'big',\n  },\n])\n\nconst searchValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  },\n})\n</script>\n\n<template>\n  <form class=\"usa-search\" role=\"search\" :class=\"classes\">\n    <UsaTextInput\n      v-bind=\"inputAttrs\"\n      :id=\"computedId\"\n      v-model=\"searchValue\"\n      name=\"search\"\n      type=\"search\"\n      :label=\"label\"\n      :class=\"customClasses?.input\"\n      :custom-classes=\"customClasses\"\n    ></UsaTextInput>\n    <UsaButton type=\"submit\" :class=\"customClasses?.button\">\n      <span\n        v-if=\"variant === 'medium' || variant === 'big'\"\n        class=\"usa-search__submit-text\"\n        >{{ buttonLabel }}</span\n      >\n      <slot name=\"icon\">\n        <img\n          :src=\"`${imagePath}/usa-icons-bg/search--white.svg`\"\n          class=\"usa-search__submit-icon\"\n          :class=\"customClasses?.icon\"\n          :alt=\"buttonLabel\"\n        />\n      </slot>\n    </UsaButton>\n  </form>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport UsaAlert from '@/components/UsaAlert'\n\nconst props = defineProps({\n  variant: {\n    type: String,\n    default: 'emergency',\n    validator(variant) {\n      const isValidVariant = ['info', 'emergency'].includes(variant)\n\n      if (!isValidVariant) {\n        console.warn(`'${variant}' is not a valid site alert variant`)\n      }\n\n      return isValidVariant\n    },\n  },\n  slim: {\n    type: Boolean,\n    default: false,\n  },\n  noIcon: {\n    type: Boolean,\n    default: false,\n  },\n  role: {\n    type: String,\n    default: '',\n  },\n  heading: {\n    type: String,\n    default: '',\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        root: [],\n        body: [],\n        heading: [],\n      }\n    },\n  },\n  ariaLabel: {\n    type: String,\n    default: 'Site alert',\n  },\n})\n\nconst classes = computed(() => [\n  {\n    'usa-site-alert--slim': props.slim,\n    'usa-site-alert--no-icon': props.noIcon,\n    'usa-site-alert--info': props.variant === 'info',\n    'usa-site-alert--emergency': props.variant === 'emergency',\n  },\n])\n</script>\n\n<template>\n  <section class=\"usa-site-alert\" :class=\"classes\" :aria-label=\"ariaLabel\">\n    <UsaAlert\n      :class=\"customClasses?.root\"\n      :slim=\"slim\"\n      :role=\"role\"\n      :heading=\"heading\"\n      :heading-tag=\"headingTag\"\n      :custom-classes=\"customClasses\"\n    >\n      <template v-if=\"$slots.heading\" #heading\n        ><slot name=\"heading\">{{ heading }}</slot></template\n      >\n      <template v-if=\"$slots.message\" #message>\n        <slot name=\"message\"></slot>\n      </template>\n      <template v-else #default><slot></slot></template>\n    </UsaAlert>\n  </section>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  status: {\n    type: String,\n    default: '',\n    validator(status) {\n      return ['current', 'completed', ''].includes(status)\n    },\n  },\n  label: {\n    type: String,\n    required: true,\n  },\n})\n\nconst statusLabel = computed(() => {\n  if (props.status === 'current') {\n    return null\n  }\n\n  return props.status === 'completed' ? props.status : 'not completed'\n})\n\nconst classes = computed(() => [\n  {\n    'usa-step-indicator__segment--complete': props.status === 'completed',\n    'usa-step-indicator__segment--current': props.status === 'current',\n  },\n])\n</script>\n\n<template>\n  <li\n    class=\"usa-step-indicator__segment\"\n    :class=\"classes\"\n    :aria-current=\"status === 'current' || null\"\n  >\n    <span class=\"usa-step-indicator__segment-label\"\n      >{{ label }}\n      <span v-if=\"statusLabel\" class=\"usa-sr-only\">{{\n        statusLabel\n      }}</span></span\n    >\n  </li>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst props = defineProps({\n  currentStepNumber: {\n    type: Number,\n    required: true,\n    validator(currentStepNumber) {\n      return currentStepNumber > 0\n    },\n  },\n  currentStepLabel: {\n    type: String,\n    required: true,\n  },\n  totalSteps: {\n    type: Number,\n    required: true,\n    validator(currentStepNumber) {\n      return currentStepNumber > 0\n    },\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        heading: [],\n        counter: [],\n        label: [],\n      }\n    },\n  },\n})\n\nconst calculatedStepNumber = computed(() =>\n  props.currentStepNumber > 0\n    ? Math.min(props.currentStepNumber, props.totalSteps)\n    : 1\n)\n</script>\n\n<template>\n  <div class=\"usa-step-indicator__header\">\n    <BaseHeading\n      class=\"usa-step-indicator__heading\"\n      :class=\"customClasses?.heading\"\n      :tag=\"headingTag\"\n    >\n      <span\n        class=\"usa-step-indicator__heading-counter\"\n        :class=\"customClasses?.counter\"\n      >\n        <span class=\"usa-sr-only\">Step</span>\n        <span class=\"usa-step-indicator__current-step\">{{\n          calculatedStepNumber\n        }}</span>\n        <span class=\"usa-step-indicator__total-steps\">\n          of {{ totalSteps }}\n        </span>\n      </span>\n      <span\n        class=\"usa-step-indicator__heading-text\"\n        :class=\"customClasses?.label\"\n        ><slot>{{ currentStepLabel }}</slot></span\n      >\n    </BaseHeading>\n  </div>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport UsaStepIndicatorSegment from '@/components/UsaStepIndicatorSegment'\nimport UsaStepIndicatorHeader from '@/components/UsaStepIndicatorHeader'\n\nconst props = defineProps({\n  steps: {\n    type: Array,\n    default: () => [],\n  },\n  currentStepNumber: {\n    type: Number,\n    default: 1,\n    validator(currentStepNumber) {\n      return currentStepNumber > 0\n    },\n  },\n  counters: {\n    type: Boolean,\n    default: false,\n  },\n  smallCounters: {\n    type: Boolean,\n    default: false,\n  },\n  center: {\n    type: Boolean,\n    default: false,\n  },\n  noLabels: {\n    type: Boolean,\n    default: false,\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        list: [],\n        segment: [],\n        header: [],\n      }\n    },\n  },\n})\n\nconst totalSteps = computed(() => props.steps.length)\n\nconst currentStepLabel = computed(() => {\n  if (props.currentStepNumber > totalSteps.value) {\n    return props.steps[totalSteps.value - 1]\n  }\n\n  if (props.steps[props.currentStepNumber - 1]) {\n    return props.steps[props.currentStepNumber - 1]\n  }\n\n  return ''\n})\n\nconst classes = computed(() => [\n  {\n    'usa-step-indicator--counters': props.counters,\n    'usa-step-indicator--counters-sm': props.smallCounters,\n    'usa-step-indicator--center': props.center,\n    'usa-step-indicator--no-labels': props.noLabels,\n  },\n])\n\nfunction stepStatus(label) {\n  const stepNumber = props.steps.indexOf(label) + 1\n\n  if (stepNumber < props.currentStepNumber) {\n    return 'completed'\n  }\n\n  if (stepNumber === props.currentStepNumber) {\n    return 'current'\n  }\n\n  return ''\n}\n</script>\n\n<template>\n  <div class=\"usa-step-indicator\" :class=\"classes\" aria-label=\"progress\">\n    <ol\n      class=\"usa-step-indicator__segments\"\n      :class=\"customClasses?.list\"\n      :aria-hidden=\"noLabels || null\"\n    >\n      <slot>\n        <UsaStepIndicatorSegment\n          v-for=\"label in steps\"\n          :key=\"label\"\n          :class=\"customClasses?.segment\"\n          :status=\"stepStatus(label)\"\n          :label=\"label\"\n        />\n      </slot>\n    </ol>\n    <slot name=\"header\">\n      <UsaStepIndicatorHeader\n        :class=\"customClasses?.header\"\n        :heading-tag=\"headingTag\"\n        :current-step-number=\"currentStepNumber\"\n        :current-step-label=\"currentStepLabel\"\n        :total-steps=\"totalSteps\"\n      ></UsaStepIndicatorHeader>\n    </slot>\n  </div>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport BaseHeading from '@/components/BaseHeading'\n\nconst props = defineProps({\n  id: {\n    type: String,\n    default: '',\n  },\n  heading: {\n    type: String,\n    default: 'Key information',\n    validator(heading) {\n      return heading !== ''\n    },\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        body: [],\n        heading: [],\n        text: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-summary-box'))\n</script>\n\n<template>\n  <div class=\"usa-summary-box\" role=\"region\" :aria-labelledby=\"computedId\">\n    <div class=\"usa-summary-box__body\" :class=\"[customClasses?.body]\">\n      <BaseHeading\n        :id=\"computedId\"\n        class=\"usa-summary-box__heading\"\n        :class=\"customClasses?.heading\"\n        :tag=\"headingTag\"\n        ><slot name=\"heading\">{{ heading }}</slot></BaseHeading\n      >\n      <div class=\"usa-summary-box__text\" :class=\"customClasses?.text\">\n        <slot></slot>\n      </div>\n    </div>\n  </div>\n</template>\n", "// >>> INTERFACES <<<\r\n// >>> HELPERS <<<\r\nvar castComparer = function (comparer) { return function (a, b, order) { return comparer(a, b, order) * order; }; };\r\nvar throwInvalidConfigErrorIfTrue = function (condition, context) {\r\n    if (condition)\r\n        throw Error(\"Invalid sort config: \" + context);\r\n};\r\nvar unpackObjectSorter = function (sortByObj) {\r\n    var _a = sortByObj || {}, asc = _a.asc, desc = _a.desc;\r\n    var order = asc ? 1 : -1;\r\n    var sortBy = (asc || desc);\r\n    // Validate object config\r\n    throwInvalidConfigErrorIfTrue(!sortBy, 'Expected `asc` or `desc` property');\r\n    throwInvalidConfigErrorIfTrue(asc && desc, 'Ambiguous object with `asc` and `desc` config properties');\r\n    var comparer = sortByObj.comparer && castComparer(sortByObj.comparer);\r\n    return { order: order, sortBy: sortBy, comparer: comparer };\r\n};\r\n// >>> SORTERS <<<\r\nvar multiPropertySorterProvider = function (defaultComparer) {\r\n    return function multiPropertySorter(sortBy, sortByArr, depth, order, comparer, a, b) {\r\n        var valA;\r\n        var valB;\r\n        if (typeof sortBy === 'string') {\r\n            valA = a[sortBy];\r\n            valB = b[sortBy];\r\n        }\r\n        else if (typeof sortBy === 'function') {\r\n            valA = sortBy(a);\r\n            valB = sortBy(b);\r\n        }\r\n        else {\r\n            var objectSorterConfig = unpackObjectSorter(sortBy);\r\n            return multiPropertySorter(objectSorterConfig.sortBy, sortByArr, depth, objectSorterConfig.order, objectSorterConfig.comparer || defaultComparer, a, b);\r\n        }\r\n        var equality = comparer(valA, valB, order);\r\n        if ((equality === 0 || (valA == null && valB == null)) &&\r\n            sortByArr.length > depth) {\r\n            return multiPropertySorter(sortByArr[depth], sortByArr, depth + 1, order, comparer, a, b);\r\n        }\r\n        return equality;\r\n    };\r\n};\r\nfunction getSortStrategy(sortBy, comparer, order) {\r\n    // Flat array sorter\r\n    if (sortBy === undefined || sortBy === true) {\r\n        return function (a, b) { return comparer(a, b, order); };\r\n    }\r\n    // Sort list of objects by single object key\r\n    if (typeof sortBy === 'string') {\r\n        throwInvalidConfigErrorIfTrue(sortBy.includes('.'), 'String syntax not allowed for nested properties.');\r\n        return function (a, b) { return comparer(a[sortBy], b[sortBy], order); };\r\n    }\r\n    // Sort list of objects by single function sorter\r\n    if (typeof sortBy === 'function') {\r\n        return function (a, b) { return comparer(sortBy(a), sortBy(b), order); };\r\n    }\r\n    // Sort by multiple properties\r\n    if (Array.isArray(sortBy)) {\r\n        var multiPropSorter_1 = multiPropertySorterProvider(comparer);\r\n        return function (a, b) { return multiPropSorter_1(sortBy[0], sortBy, 1, order, comparer, a, b); };\r\n    }\r\n    // Unpack object config to get actual sorter strategy\r\n    var objectSorterConfig = unpackObjectSorter(sortBy);\r\n    return getSortStrategy(objectSorterConfig.sortBy, objectSorterConfig.comparer || comparer, objectSorterConfig.order);\r\n}\r\nvar sortArray = function (order, ctx, sortBy, comparer) {\r\n    var _a;\r\n    if (!Array.isArray(ctx)) {\r\n        return ctx;\r\n    }\r\n    // Unwrap sortBy if array with only 1 value to get faster sort strategy\r\n    if (Array.isArray(sortBy) && sortBy.length < 2) {\r\n        _a = sortBy, sortBy = _a[0];\r\n    }\r\n    return ctx.sort(getSortStrategy(sortBy, comparer, order));\r\n};\r\nfunction createNewSortInstance(opts) {\r\n    var comparer = castComparer(opts.comparer);\r\n    return function (_ctx) {\r\n        var ctx = Array.isArray(_ctx) && !opts.inPlaceSorting\r\n            ? _ctx.slice()\r\n            : _ctx;\r\n        return {\r\n            asc: function (sortBy) {\r\n                return sortArray(1, ctx, sortBy, comparer);\r\n            },\r\n            desc: function (sortBy) {\r\n                return sortArray(-1, ctx, sortBy, comparer);\r\n            },\r\n            by: function (sortBy) {\r\n                return sortArray(1, ctx, sortBy, comparer);\r\n            },\r\n        };\r\n    };\r\n}\r\nvar defaultComparer = function (a, b, order) {\r\n    if (a == null)\r\n        return order;\r\n    if (b == null)\r\n        return -order;\r\n    if (a < b)\r\n        return -1;\r\n    if (a > b)\r\n        return 1;\r\n    return 0;\r\n};\r\nvar sort = createNewSortInstance({\r\n    comparer: defaultComparer,\r\n});\r\nvar inPlaceSort = createNewSortInstance({\r\n    comparer: defaultComparer,\r\n    inPlaceSorting: true,\r\n});\n\nexport { createNewSortInstance, inPlaceSort, sort };\n", "import { createNewSortInstance } from 'fast-sort'\n\nexport const naturalSort = createNewSortInstance({\n  comparer: new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base',\n  }).compare,\n})\n", "import { ref, computed, readonly } from 'vue'\nimport { naturalSort } from '@/utils/sorting.js'\nimport { objectHasKey, kebabCase } from '@/utils/common.js'\n\nexport default (\n  _headers = [],\n  _rows = [],\n  _defaultSortHeader = '',\n  _defaultSortDirection = ''\n) => {\n  const currentSortedHeader = ref(_defaultSortHeader)\n  const currentSortDirection = ref(_defaultSortDirection)\n\n  const headers = computed(() => {\n    return _headers.value.map(header => {\n      if (typeof header === 'string') {\n        return {\n          id: kebabCase(header),\n          label: header,\n          sortable: false,\n          headerRow: false,\n        }\n      }\n\n      const headerCell = { ...header }\n\n      if (!header?.id) {\n        headerCell.id = kebabCase(header.label)\n      }\n\n      if (!objectHasKey(header, 'sortable')) {\n        headerCell.sortable = false\n      } else {\n        headerCell.sortable = header.sortable\n      }\n\n      if (!objectHasKey(header, 'headerRow')) {\n        headerCell.headerRow = false\n      } else {\n        headerCell.headerRow = header.headerRow\n      }\n\n      return headerCell\n    })\n  })\n\n  const currentSortedHeaderLabel = computed(() => {\n    if (!currentSortedHeader.value) {\n      return null\n    }\n\n    const [sortedHeader] = headers.value.filter(\n      header => header.id === currentSortedHeader.value\n    )\n\n    return sortedHeader.label\n  })\n\n  const hasSortableHeaders = computed(() => {\n    return headers.value.some(header => header.sortable)\n  })\n\n  const normalizedRows = computed(() => {\n    const rows = _rows.value.map(row => {\n      return Object.entries(row).reduce((acc, [columnName, columnValue]) => {\n        if (typeof columnValue !== 'object') {\n          acc[columnName] = {\n            displayValue: columnValue,\n            sortValue: columnValue,\n          }\n\n          return acc\n        }\n\n        // Merge existing row object into new.\n        acc[columnName] = { ...row[columnName] }\n\n        if (!objectHasKey(columnValue, 'sortValue')) {\n          acc[columnName].sortValue = columnValue.displayValue\n        }\n\n        return acc\n      }, {})\n    })\n\n    return rows\n  })\n\n  const rows = computed(() => {\n    if (currentSortDirection.value === 'ascending') {\n      return naturalSort(normalizedRows.value).asc(\n        row => row[currentSortedHeader.value].sortValue\n      )\n    } else if (currentSortDirection.value === 'descending') {\n      return naturalSort(normalizedRows.value).desc(\n        row => row[currentSortedHeader.value].sortValue\n      )\n    }\n\n    return normalizedRows.value\n  })\n\n  const toggleSortDirection = () => {\n    if (\n      !currentSortDirection.value ||\n      currentSortDirection.value === 'unsorted'\n    ) {\n      currentSortDirection.value = 'ascending'\n    } else {\n      currentSortDirection.value =\n        currentSortDirection.value === 'ascending' ? 'descending' : 'ascending'\n    }\n  }\n\n  const updateCurrentSortedHeader = headerId =>\n    (currentSortedHeader.value = headerId)\n\n  return {\n    headers,\n    rows: rows,\n    hasSortableHeaders: readonly(hasSortableHeaders),\n    currentSortedHeader: readonly(currentSortedHeader),\n    currentSortedHeaderLabel: readonly(currentSortedHeaderLabel),\n    currentSortDirection: readonly(currentSortDirection),\n    toggleSortDirection,\n    updateCurrentSortedHeader,\n  }\n}\n", "<script setup>\nimport { computed } from 'vue'\n\nconst emit = defineEmits(['update:tableSort'])\n\nconst props = defineProps({\n  headerId: {\n    type: [String, Number],\n    required: true,\n  },\n  headerLabel: {\n    type: String,\n    required: true,\n  },\n  currentSortDirection: {\n    type: String,\n    default: '',\n  },\n})\n\nconst reverseSortDirection = computed(() => {\n  const reverseDirections = {\n    ascending: 'descending',\n    descending: 'ascending',\n  }\n\n  return reverseDirections[props.currentSortDirection] || 'ascending'\n})\n\nconst title = computed(\n  () =>\n    `Click to sort by ${props.headerLabel} in ${reverseSortDirection.value} order.`\n)\n</script>\n\n<template>\n  <button\n    type=\"button\"\n    tabindex=\"0\"\n    class=\"usa-table__header__button\"\n    :title=\"title\"\n    @click=\"emit('update:tableSort', headerId)\"\n  >\n    <slot>\n      <svg\n        class=\"usa-icon\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 24 24\"\n      >\n        <g class=\"descending\" fill=\"transparent\">\n          <path\n            d=\"M17 17L15.59 15.59L12.9999 18.17V2H10.9999V18.17L8.41 15.58L7 17L11.9999 22L17 17Z\"\n          ></path>\n        </g>\n        <g class=\"ascending\" fill=\"transparent\">\n          <path\n            transform=\"rotate(180, 12, 12)\"\n            d=\"M17 17L15.59 15.59L12.9999 18.17V2H10.9999V18.17L8.41 15.58L7 17L11.9999 22L17 17Z\"\n          ></path>\n        </g>\n        <g class=\"unsorted\" fill=\"transparent\">\n          <polygon\n            points=\"15.17 15 13 17.17 13 6.83 15.17 9 16.58 7.59 12 3 7.41 7.59 8.83 9 11 6.83 11 17.17 8.83 15 7.42 16.41 12 21 16.59 16.41 15.17 15\"\n          ></polygon>\n        </g>\n      </svg>\n    </slot>\n  </button>\n</template>\n", "<script setup>\nimport { computed, inject } from 'vue'\nimport UsaTableSortButton from '@/components/UsaTableSortButton'\n\nconst updateCurrentSortedHeader = inject('updateCurrentSortedHeader')\nconst toggleSortDirection = inject('toggleSortDirection')\n\nconst props = defineProps({\n  id: {\n    type: [String, Number],\n    required: true,\n  },\n  label: {\n    type: String,\n    required: true,\n  },\n  sortable: {\n    type: Boolean,\n    default: false,\n  },\n  currentSortedHeader: {\n    type: String,\n    default: '',\n  },\n  currentSortDirection: {\n    type: String,\n    default: '',\n  },\n})\n\nconst ariaLabel = computed(() =>\n  !props.sortable\n    ? null\n    : `${props.label}, sortable column, currently ${\n        props.currentSortDirection\n          ? `sorted ${props.currentSortDirection}`\n          : 'unsorted'\n      }`\n)\n\nconst ariaSort = computed(() => {\n  if (props.currentSortedHeader !== props.id) {\n    return null\n  }\n\n  if (\n    props.currentSortDirection === 'ascending' ||\n    props.currentSortDirection === 'descending'\n  ) {\n    return props.currentSortDirection\n  }\n\n  return null\n})\n\nconst toggleTableSort = headerId => {\n  updateCurrentSortedHeader(headerId)\n  toggleSortDirection()\n}\n</script>\n\n<template>\n  <th\n    scope=\"col\"\n    :data-sortable=\"sortable ? true : null\"\n    :role=\"sortable ? 'columnheader' : null\"\n    :aria-label=\"ariaLabel\"\n    :aria-sort=\"ariaSort\"\n  >\n    <slot>{{ label }}</slot>\n    <UsaTableSortButton\n      v-if=\"sortable\"\n      :current-sort-direction=\"currentSortDirection\"\n      :header-id=\"id\"\n      :header-label=\"label\"\n      @update:table-sort=\"toggleTableSort\"\n    ></UsaTableSortButton>\n  </th>\n</template>\n", "<script>\nexport default {\n  name: 'UsaTable',\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, ref, h, toRef, useSlots, provide } from 'vue'\nimport useTableSort from '@/composables/useTableSort'\nimport UsaTableHeaderCell from '@/components/UsaTableHeaderCell'\n\nconst slots = useSlots()\nconst captionRef = ref(null)\n\nconst props = defineProps({\n  caption: {\n    type: String,\n    default: '',\n  },\n  borderless: {\n    type: Boolean,\n    default: false,\n  },\n  striped: {\n    type: Boolean,\n    default: false,\n  },\n  compact: {\n    type: Boolean,\n    default: false,\n  },\n  scrollable: {\n    type: Boolean,\n    default: false,\n  },\n  stacked: {\n    type: Boolean,\n    default: false,\n  },\n  stackedHeader: {\n    type: Boolean,\n    default: false,\n  },\n  headers: {\n    type: Array,\n    default: () => [],\n  },\n  rows: {\n    type: Array,\n    default: () => [],\n  },\n  defaultSortDirection: {\n    type: String,\n    default: '',\n  },\n  defaultSortHeader: {\n    type: String,\n    default: '',\n  },\n})\n\nconst {\n  headers,\n  rows,\n  hasSortableHeaders,\n  currentSortedHeader,\n  currentSortedHeaderLabel,\n  currentSortDirection,\n  toggleSortDirection,\n  updateCurrentSortedHeader,\n} = useTableSort(\n  toRef(props, 'headers'),\n  toRef(props, 'rows'),\n  props.defaultSortHeader,\n  props.defaultSortDirection\n)\n\nconst classes = computed(() => [\n  {\n    'usa-table--borderless': props.borderless,\n    'usa-table--striped': props.striped,\n    'usa-table--compact': props.compact,\n    'usa-table--stacked': props.stacked,\n    'usa-table--stacked-header': props.stackedHeader,\n  },\n])\n\nconst tableIsSortable = computed(\n  () => hasSortableHeaders.value && !slots?.default && !slots?.headers\n)\n\nconst tableCaption = computed(() => {\n  if (props.caption) {\n    return props.caption\n  }\n\n  if (captionRef.value) {\n    return captionRef.value.textContent\n  }\n\n  return null\n})\n\nconst UsaTableContainerComponent = {\n  name: 'UsaTableContainer',\n  props: {\n    isScrollable: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup({ isScrollable }, { slots }) {\n    return () =>\n      isScrollable\n        ? h(\n            'div',\n            { class: 'usa-table-container--scrollable', tabindex: 0 },\n            slots.default()\n          )\n        : slots.default()\n  },\n}\n\nprovide('toggleSortDirection', toggleSortDirection)\nprovide('updateCurrentSortedHeader', updateCurrentSortedHeader)\n</script>\n\n<template>\n  <UsaTableContainerComponent :is-scrollable=\"scrollable\">\n    <table v-bind=\"$attrs\" class=\"usa-table\" :class=\"classes\">\n      <caption v-if=\"caption || $slots.caption\" ref=\"captionRef\"\n        ><slot name=\"caption\">{{ caption }}</slot></caption\n      >\n      <thead>\n        <slot v-if=\"$slots.headers\" name=\"headers\"></slot>\n        <slot v-else-if=\"headers.length\" name=\"headers\" :headers=\"headers\">\n          <tr>\n            <UsaTableHeaderCell\n              v-for=\"header in headers\"\n              :id=\"header.id\"\n              :key=\"header.id\"\n              :label=\"header.label\"\n              :sortable=\"tableIsSortable && header.sortable\"\n              :current-sorted-header=\"currentSortedHeader\"\n              :current-sort-direction=\"\n                currentSortedHeader === header.id ? currentSortDirection : ''\n              \"\n              ><slot :name=\"`header-${header.id}`\" :header=\"header\"\n                >{{ header.label }}\n              </slot></UsaTableHeaderCell\n            >\n          </tr>\n        </slot>\n      </thead>\n      <tbody>\n        <slot v-if=\"$slots.default\"></slot>\n        <slot v-else-if=\"rows.length\" :rows=\"rows\">\n          <tr v-for=\"(row, index) in rows\" :key=\"index\">\n            <component\n              :is=\"header.headerRow ? 'th' : 'td'\"\n              v-for=\"header in headers\"\n              :key=\"`${header.id}-${index}`\"\n              :scope=\"header.headerRow ? 'row' : null\"\n              :role=\"header.headerRow ? 'rowheader' : null\"\n              :data-label=\"header.label\"\n              :data-sort-active=\"\n                currentSortedHeader === header.id ? true : null\n              \"\n              :data-sort-value=\"row[header.id].sortValue\"\n            >\n              <slot\n                :name=\"`cell-${header.id}`\"\n                :header=\"header\"\n                :row=\"row\"\n                :cell=\"row[header.id]\"\n                >{{ row[header.id].displayValue }}\n              </slot></component\n            >\n          </tr>\n        </slot>\n      </tbody>\n    </table>\n    <div\n      v-if=\"tableIsSortable\"\n      class=\"usa-sr-only usa-table__announcement-region\"\n      aria-live=\"polite\"\n      ><slot\n        name=\"table-announcement\"\n        :current-sorted-header=\"currentSortedHeader\"\n        :current-sort-direction=\"currentSortDirection\"\n        :current-sorted-header-label=\"currentSortedHeaderLabel\"\n        :table-caption=\"tableCaption\"\n        ><template v-if=\"currentSortedHeader\"\n          >The table\n          <template v-if=\"tableCaption\">named \"{{ tableCaption }}\"</template> is\n          now sorted by \"{{ currentSortedHeaderLabel }}\" in\n          {{ currentSortDirection }} order.</template\n        ></slot\n      ></div\n    >\n  </UsaTableContainerComponent>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps({\n  size: {\n    type: String,\n    default: '',\n    validator(size) {\n      const isValidSize = size === '' || size === 'big'\n\n      if (!isValidSize) {\n        console.warn(`'${size}' is not a valid tag size`)\n      }\n\n      return isValidSize\n    },\n  },\n  tag: {\n    type: String,\n    default: 'span',\n  },\n})\n\nconst classes = computed(() => [{ 'usa-tag--big': props.size === 'big' }])\n</script>\n\n<template>\n  <component :is=\"tag\" class=\"usa-tag\" :class=\"classes\"\n    ><slot></slot\n  ></component>\n</template>\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, inject, useSlots, onMounted } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport UsaFormGroup from '@/components/UsaFormGroup'\nimport UsaLabel from '@/components/UsaLabel'\n\nconst slots = useSlots()\n\nconst updateCharacterCount = inject('updateCharacterCount', null)\nconst characterCountMaxlength = inject('characterCountMaxlength', null)\nconst characterCountMessageId = inject('characterCountMessageId', null)\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  width: {\n    type: String,\n    default: '',\n    validator(width) {\n      const isValidWidth = [\n        '',\n        '2xs',\n        'xs',\n        'sm',\n        'small',\n        'md',\n        'medium',\n        'lg',\n        'xl',\n        '2xl',\n      ].includes(width)\n\n      if (!isValidWidth) {\n        console.warn(`'${width}' is not a valid textarea width`)\n      }\n\n      return isValidWidth\n    },\n  },\n  modelValue: {\n    type: [String, Number],\n    default: '',\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        component: [],\n        label: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-textarea'))\nconst computedErrorMessageId = computed(\n  () => `${computedId.value}-error-message`\n)\nconst computedHintId = computed(() => `${computedId.value}-hint`)\n\nconst textareaValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n\n    if (updateCharacterCount) {\n      updateCharacterCount(value)\n    }\n  },\n})\n\n// Trigger any character counts for default textarea values.\nonMounted(() => {\n  if (updateCharacterCount) {\n    updateCharacterCount(props.modelValue)\n  }\n})\n\nconst classes = computed(() => [\n  {\n    'usa-input--error': props.error,\n    'usa-input--2xs': props.width === '2xs',\n    'usa-input--xs': props.width === 'xs',\n    'usa-input--sm': props.width === 'sm',\n    'usa-input--small': props.width === 'small',\n    'usa-input--md': props.width === 'md',\n    'usa-input--medium': props.width === 'medium',\n    'usa-input--lg': props.width === 'lg',\n    'usa-input--xl': props.width === 'xl',\n    'usa-input--2xl': props.width === '2xl',\n    'usa-character-count__field': updateCharacterCount,\n  },\n])\n\nconst ariaDescribedby = computed(() => {\n  const ids = []\n\n  if (characterCountMessageId) {\n    ids.push(characterCountMessageId.value)\n  }\n\n  if (slots.hint) {\n    ids.push(computedHintId.value)\n  }\n\n  if (props.error && slots['error-message']) {\n    ids.push(computedErrorMessageId.value)\n  }\n\n  return ids.length ? ids.join(' ') : null\n})\n</script>\n\n<template>\n  <UsaFormGroup\n    :group=\"!!$slots.hint || (error && !!$slots['error-message'])\"\n    :error=\"error\"\n    :class=\"props.customClasses?.component\"\n  >\n    <UsaLabel\n      v-if=\"label || $slots.label\"\n      :for=\"computedId\"\n      :required=\"required\"\n      :error=\"error\"\n      :class=\"customClasses?.label\"\n      ><slot name=\"label\">{{ label }}</slot></UsaLabel\n    >\n\n    <span v-if=\"$slots.hint\" :id=\"computedHintId\" class=\"usa-hint\"\n      ><slot name=\"hint\"></slot\n    ></span>\n\n    <span\n      v-if=\"error && $slots['error-message']\"\n      :id=\"computedErrorMessageId\"\n      class=\"usa-error-message\"\n      ><slot name=\"error-message\"></slot\n    ></span>\n\n    <textarea\n      v-bind=\"$attrs\"\n      :id=\"computedId\"\n      v-model=\"textareaValue\"\n      class=\"usa-textarea\"\n      :class=\"classes\"\n      :required=\"required\"\n      :maxlength=\"characterCountMaxlength || $attrs.maxlength\"\n      :aria-describedby=\"ariaDescribedby\"\n    />\n  </UsaFormGroup>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nimport { nextId } from '@/utils/unique-id.js'\nimport { validateTimeString } from '@/utils/dates.js'\nimport UsaComboBox from '@/components/UsaComboBox'\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst props = defineProps({\n  minTime: {\n    type: String,\n    default: '00:00',\n    validator(minTime) {\n      let isValidTime = validateTimeString(minTime)\n\n      if (!isValidTime) {\n        console.warn(\n          `'${minTime}' is not a valid minimum time. It must be a string in the HH:MM 24 hour format.`\n        )\n      }\n\n      return isValidTime\n    },\n  },\n  maxTime: {\n    type: String,\n    default: '23:59',\n    validator(maxTime) {\n      let isValidTime = validateTimeString(maxTime)\n\n      if (!isValidTime) {\n        console.warn(\n          `'${maxTime}' is not a valid maximum time. It must be a string in the HH:MM 24 hour format.`\n        )\n      }\n\n      return isValidTime\n    },\n  },\n  step: {\n    type: [String, Number],\n    default: 30,\n    validator(step) {\n      const isValidStep = parseInt(step, 10) > 0\n\n      if (!isValidStep) {\n        console.warn(`'${step}' is not a valid time step increment.`)\n      }\n\n      return isValidStep\n    },\n  },\n  modelValue: {\n    type: String,\n    default: '',\n  },\n  label: {\n    type: String,\n    default: '',\n  },\n  required: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  error: {\n    type: Boolean,\n    default: false,\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  clearButtonAriaLabel: {\n    type: String,\n    default: 'Clear the select contents',\n  },\n  toggleButtonAriaLabel: {\n    type: String,\n    default: 'Toggle the dropdown list',\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        formGroup: [],\n        component: [],\n        label: [],\n        input: [],\n        list: [],\n      }\n    },\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-time-picker'))\n\nconst selectedOption = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  },\n})\n\nconst timeStringToMinutes = timeString => {\n  const [hours, minutes] = timeString\n    .split(':')\n    .map(segment => parseInt(segment, 10))\n\n  return hours * 60 + minutes\n}\n\nconst timeRangeOptions = computed(() => {\n  const timeRange = []\n  const minTime = timeStringToMinutes(props.minTime)\n  const maxTime = timeStringToMinutes(props.maxTime)\n  const step = parseInt(props.step, 10)\n\n  if (minTime === maxTime) {\n    return timeRange\n  }\n\n  for (let time = minTime; time <= maxTime; time += step) {\n    const minute = time % 60\n    const hour24 = Math.floor(time / 60)\n    const hour12 = hour24 % 12 || 12\n    const ampm = hour24 < 12 ? 'am' : 'pm'\n\n    const formattedMinute = `${minute}`.padStart(2, '0')\n    const formattedHour24 = `${hour24}`.padStart(2, '0')\n\n    timeRange.push({\n      value: `${formattedHour24}:${formattedMinute}`,\n      label: `${hour12}:${formattedMinute}${ampm}`,\n    })\n  }\n\n  return timeRange\n})\n\nconst classes = computed(() => {\n  const customClasses = props.customClasses\n\n  if (!customClasses?.component?.length) {\n    customClasses.component = ['usa-time-picker']\n  } else if (!customClasses.component.includes('usa-time-picker')) {\n    customClasses.component.push('usa-time-picker')\n  }\n\n  return customClasses\n})\n</script>\n\n<template>\n  <UsaComboBox\n    :id=\"computedId\"\n    v-model=\"selectedOption\"\n    :options=\"timeRangeOptions\"\n    :label=\"label\"\n    :required=\"required\"\n    :disabled=\"disabled\"\n    :readonly=\"readonly\"\n    :error=\"error\"\n    :clear-button-aria-label=\"clearButtonAriaLabel\"\n    :toggle-button-aria-label=\"toggleButtonAriaLabel\"\n    :custom-classes=\"classes\"\n  >\n    <template v-if=\"$slots.label\" #label><slot name=\"label\"></slot></template>\n    <template v-if=\"$slots.hint\" #hint><slot name=\"hint\"></slot></template>\n    <template v-if=\"$slots['error-message']\" #error-message\n      ><slot name=\"error-message\"></slot\n    ></template>\n    <template v-if=\"$slots['no-results']\" #no-results\n      ><slot name=\"no-results\"></slot\n    ></template>\n    <template v-if=\"$slots.status\" #status=\"{ filteredOptions }\"\n      ><slot name=\"status\" :filtered-options=\"filteredOptions\"></slot\n    ></template>\n    <template v-if=\"$slots['assistive-hint']\" #assistive-hint\n      ><slot name=\"assistive-hint\"></slot\n    ></template>\n  </UsaComboBox>\n</template>\n", "function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n    if (validMiddleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement` middleware', 'detected. This will lead to an infinite loop. Ensure only one of', 'either has been passed to the `middleware` array.'].join(' '));\n    }\n    if (!reference || !floating) {\n      console.error(['Floating UI: The reference and/or floating element was not defined', 'when `computePosition()` was called. Ensure that both elements have', 'been created and can be measured.'].join(' '));\n    }\n  }\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  if (process.env.NODE_ENV !== \"production\") ;\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n        let resetPlacement = 'bottom';\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n              if (placement) {\n                resetPlacement = placement;\n              }\n              break;\n            }\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(middlewareArguments) {\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = options;\n      const {\n        rects\n      } = middlewareArguments;\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(middlewareArguments) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      await apply({\n        ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        }\n\n        // There are 2 or more connected rects\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(\n  // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n  // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const offsetWidth = element.offsetWidth;\n  const offsetHeight = element.offsetHeight;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node\n  node.assignedSlot ||\n  // DOM Element detected\n  node.parentNode || (\n  // ShadowRoot detected\n  isShadowRoot(node) ? node.host : null) ||\n  // Fallback\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    // This doesn't appear to need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n  }\n\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\n// Returns the inner client rect, subtracting scrollbars if present\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  if (clippingAncestor === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingAncestor)) {\n    return getInnerBoundingClientRect(clippingAncestor, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, getOverflowAncestors, platform };\n", "<script>\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<script setup>\nimport { computed, ref, onMounted, onBeforeUnmount, watch, nextTick } from 'vue'\nimport {\n  computePosition,\n  autoUpdate,\n  offset,\n  flip,\n  inline,\n} from '@floating-ui/dom'\nimport { nextId } from '@/utils/unique-id.js'\n\nconst props = defineProps({\n  label: {\n    type: String,\n    default: '',\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  wrapperTag: {\n    type: String,\n    default: 'span',\n  },\n  tag: {\n    type: String,\n    default: 'span',\n  },\n  position: {\n    type: String,\n    default: 'top',\n    validator(position) {\n      const isValidPosition = ['top', 'bottom', 'left', 'right'].includes(\n        position\n      )\n\n      if (!isValidPosition) {\n        console.warn(`'${position}' is not a valid tooltip position`)\n      }\n\n      return isValidPosition\n    },\n  },\n  customClasses: {\n    type: Object,\n    default: () => {\n      return {\n        component: [],\n        label: [],\n      }\n    },\n  },\n})\n\nconst referenceElement = ref(null)\nconst floatingElement = ref(null)\nconst isSet = ref(false)\nconst isVisible = ref(isSet.value)\nconst currentPosition = ref(props.position)\nconst currentCoordinates = ref({ left: 0, top: 0, opacity: 0 })\nconst computedId = computed(() => props.id || nextId('usa-tooltip'))\n\nconst labelClasses = computed(() => [\n  {\n    'usa-tooltip__body--top': currentPosition.value === 'top',\n    'usa-tooltip__body--bottom': currentPosition.value === 'bottom',\n    'usa-tooltip__body--left': currentPosition.value === 'left',\n    'usa-tooltip__body--right': currentPosition.value === 'right',\n    'is-set': isSet.value,\n    'is-visible': isVisible.value,\n  },\n  ...(props.customClasses?.label || []),\n])\n\nlet cleanupFloatingUi\n\nconst updatePosition = () => {\n  computePosition(referenceElement.value, floatingElement.value, {\n    placement: props.position,\n    middleware: [\n      offset(5),\n      inline(),\n      flip({\n        flipAlignment: false,\n        fallbackPlacements: ['top', 'bottom', 'left', 'right'],\n      }),\n    ],\n  }).then(({ x, y, placement }) => {\n    currentPosition.value = placement\n    currentCoordinates.value.left = `${x}px`\n    currentCoordinates.value.top = `${y}px`\n  })\n}\n\nwatch(isSet, currentlySet => {\n  nextTick(() => {\n    requestAnimationFrame(() => {\n      isVisible.value = currentlySet\n      // May be able to be removed once:\n      // https://github.com/uswds/uswds/issues/4458 is fixed.\n      currentCoordinates.value.opacity = currentlySet ? 1 : 0\n    })\n  })\n})\n\nonMounted(() => {\n  // `isSet` needs to be `true` until floating UI has initialized and has\n  // calculated it's initial position.\n  // May be able to be removed once:\n  //  https://github.com/uswds/uswds/issues/4458 is fixed.\n  isSet.value = true\n\n  cleanupFloatingUi = autoUpdate(\n    referenceElement.value,\n    floatingElement.value,\n    updatePosition\n  )\n\n  nextTick(() => {\n    requestAnimationFrame(() => {\n      isSet.value = false\n    })\n  })\n})\n\nonBeforeUnmount(() => {\n  cleanupFloatingUi()\n})\n</script>\n\n<template>\n  <component\n    :is=\"wrapperTag\"\n    class=\"usa-tooltip\"\n    :class=\"customClasses?.component\"\n  >\n    <component\n      :is=\"tag\"\n      ref=\"referenceElement\"\n      v-bind=\"$attrs\"\n      class=\"usa-tooltip__trigger\"\n      tabindex=\"0\"\n      :aria-describedby=\"computedId\"\n      @mouseenter=\"isSet = true\"\n      @mouseover=\"isSet = true\"\n      @mouseout=\"isSet = false\"\n      @focus=\"isSet = true\"\n      @blur=\"isSet = false\"\n      @keydown=\"isSet = false\"\n      ><slot></slot\n    ></component>\n    <span\n      :id=\"computedId\"\n      ref=\"floatingElement\"\n      role=\"tooltip\"\n      class=\"usa-tooltip__body\"\n      :class=\"labelClasses\"\n      :aria-hidden=\"!isVisible\"\n      :style=\"currentCoordinates\"\n      ><slot name=\"label\">{{ label }}</slot></span\n    >\n  </component>\n</template>\n", "<script setup>\nimport { computed, watch } from 'vue'\nimport { refDebounced } from '@vueuse/core'\nimport { objectHasKey } from '@/utils/common.js'\nimport { nextId } from '@/utils/unique-id.js'\nimport UsaAlert from '@/components/UsaAlert'\nimport UsaChecklist from '@/components/UsaChecklist'\n\nconst emit = defineEmits(['update:validationId', 'update:statusMessageId'])\n\nconst props = defineProps({\n  validations: {\n    type: Array,\n    default: () => [],\n  },\n  validationValue: {\n    type: [String, Number],\n    default: '',\n  },\n  heading: {\n    type: String,\n    default: '',\n  },\n  headingTag: {\n    type: String,\n    default: 'h2',\n  },\n  validLabel: {\n    type: String,\n    default: '%s status complete',\n  },\n  invalidLabel: {\n    type: String,\n    default: '%s status incomplete',\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  customClasses: {\n    type: Object,\n    default: () => ({\n      body: [],\n      heading: [],\n      checklist: [],\n    }),\n  },\n})\n\nconst computedId = computed(() => props.id || nextId('usa-validation'))\nconst computedStatusMessageId = computed(\n  () => `${computedId.value}-status-message`\n)\n\nconst validatedItems = computed(() =>\n  props.validations.reduce((acc, item) => {\n    const validatedItem = {\n      id: item?.id && !!`${item.id}` ? item.id : item.text,\n      text: item.text,\n    }\n\n    if (objectHasKey(item, 'checked')) {\n      validatedItem.checked = item.checked\n    } else if (typeof item?.validator === 'string') {\n      const regex = new RegExp(item.validator, 'g')\n\n      validatedItem.checked = regex.test(`${props.validationValue}`)\n    } else if (\n      typeof item?.validator === 'object' &&\n      item.validator instanceof RegExp\n    ) {\n      validatedItem.checked = item.validator.test(`${props.validationValue}`)\n    } else if (typeof item?.validator === 'function') {\n      validatedItem.checked = item.validator(props.validationValue) === true\n    } else {\n      validatedItem.checked = false\n    }\n\n    validatedItem.ariaLabel =\n      validatedItem.checked === true\n        ? props.validLabel.replaceAll('%s', validatedItem.text)\n        : props.invalidLabel.replaceAll('%s', validatedItem.text)\n\n    acc.push(validatedItem)\n\n    return acc\n  }, [])\n)\n\nconst statusMessage = refDebounced(\n  computed(() =>\n    validatedItems.value.map(item => `${item.ariaLabel}.`).join(' ')\n  ),\n  1000\n)\n\nwatch(computedId, () => emit('update:validationId', computedId), {\n  immediate: true,\n})\nwatch(\n  computedStatusMessageId,\n  () => emit('update:statusMessageId', computedStatusMessageId),\n  { immediate: true }\n)\n</script>\n\n<template>\n  <UsaAlert\n    v-bind=\"$attrs\"\n    variant=\"validation\"\n    :heading=\"heading\"\n    :heading-tag=\"headingTag\"\n    :custom-classes=\"customClasses\"\n  >\n    <template #message>\n      <UsaChecklist\n        v-if=\"validatedItems?.length\"\n        :id=\"computedId\"\n        :items=\"validatedItems\"\n        :class=\"customClasses?.checklist\"\n      ></UsaChecklist>\n    </template>\n  </UsaAlert>\n  <span\n    :id=\"computedStatusMessageId\"\n    data-validation-status\n    class=\"usa-sr-only\"\n    aria-live=\"polite\"\n    aria-atomic=\"true\"\n    >{{ statusMessage }}</span\n  >\n</template>\n", "import core from './core.js'\nimport * as components from '@/components/index.js'\n\nexport default function install(app, options) {\n  core.install(app, options)\n\n  // Register all components.\n  Object.keys(components).forEach(componentName => {\n    app.component(componentName, components[componentName])\n  })\n}\n"],
  "mappings": "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",
  "names": ["kebabCase", "justKebabCase", "split", "_sfc_main", "_createElementBlock", "_mergeProps", "_renderSlot", "_createBlock", "_resolveDynamicComponent", "__defProp", "__getOwnPropSymbols", "__hasOwnProp", "__propIsEnum", "__defNormalProp", "__spreadValues", "__default__", "minDate", "maxDate", "max", "min", "computePosition"]
}
